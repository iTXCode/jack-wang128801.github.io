<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jack-wang&#39;s blog</title>
  
  <subtitle>Fly to the distance</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jack-wang128801.github.io/"/>
  <updated>2019-05-05T15:02:09.753Z</updated>
  <id>https://jack-wang128801.github.io/</id>
  
  <author>
    <name>jack-wang128801</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 系统下cat指令与more指令的异同</title>
    <link href="https://jack-wang128801.github.io/2019/05/04/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8Bcat%E6%8C%87%E4%BB%A4%E4%B8%8Emore%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>https://jack-wang128801.github.io/2019/05/04/Linux-系统下cat指令与more指令的异同/</id>
    <published>2019-05-04T10:01:28.000Z</published>
    <updated>2019-05-05T15:02:09.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-系统下cat指令与more指令的异同"><a href="#Linux-系统下cat指令与more指令的异同" class="headerlink" title="Linux 系统下cat指令与more指令的异同"></a>Linux 系统下cat指令与more指令的异同</h3><a id="more"></a><h4 id="cat指令的功能"><a href="#cat指令的功能" class="headerlink" title="cat指令的功能"></a>cat指令的功能</h4><table><thead><tr><th>语法</th><th>cat 选项  文件</th></tr></thead><tbody><tr><td>功能</td><td>查看目标文件的内容</td></tr></tbody></table><p><strong>使用方法</strong><br><img src="https://img-blog.csdnimg.cn/20190504181218561.png" alt="在这里插入图片描述"><br><strong>主要选项</strong></p><blockquote><p>-b 对非空输出行编号<br>-n 对输出的所有行编号<br>-s 不输出多行空行</p></blockquote><h4 id="more的功能"><a href="#more的功能" class="headerlink" title="more的功能"></a>more的功能</h4><blockquote><ul><li>大体功能相同与cat指令相同</li></ul></blockquote><table><thead><tr><th>语法</th><th>more 选项 文件</th></tr></thead><tbody><tr><td>功能</td><td>more命令，功能类似 cat</td></tr></tbody></table><p><strong>使用方法</strong><br><img src="https://img-blog.csdnimg.cn/20190504182054916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>主要选项</strong></p><blockquote><p>-n 对输出的所有行编号<br>q 退出more</p></blockquote><h5 id="两者的相同点"><a href="#两者的相同点" class="headerlink" title="两者的相同点"></a>两者的相同点</h5><blockquote><p>相同点在于：都是用来查看文件内容的指令，两者用法基本相同<br><strong>两者的不同点</strong><br>不同点在于：cat指令查看完毕后会自动返回到正常模式而more指令则需要用户手动退出查看模式</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux-系统下cat指令与more指令的异同&quot;&gt;&lt;a href=&quot;#Linux-系统下cat指令与more指令的异同&quot; class=&quot;headerlink&quot; title=&quot;Linux 系统下cat指令与more指令的异同&quot;&gt;&lt;/a&gt;Linux 系统下cat指令与more指令的异同&lt;/h3&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://jack-wang128801.github.io/categories/Linux/"/>
    
    
      <category term="Linux 系统下cat指令与more指令的异同" scheme="https://jack-wang128801.github.io/tags/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8Bcat%E6%8C%87%E4%BB%A4%E4%B8%8Emore%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    
  </entry>
  
  <entry>
    <title>Vim使用手册</title>
    <link href="https://jack-wang128801.github.io/2019/05/01/Vim%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://jack-wang128801.github.io/2019/05/01/Vim使用手册/</id>
    <published>2019-05-01T10:16:29.000Z</published>
    <updated>2019-05-05T15:04:22.122Z</updated>
    
    <content type="html"><![CDATA[<p>VimTutor 中文版——vim 学习不二基础</p><a id="more"></a><p>===============================================================================</p><h1 id="欢-迎-阅-读-《-V-I-M-教-程-》-——-版本-1-5"><a href="#欢-迎-阅-读-《-V-I-M-教-程-》-——-版本-1-5" class="headerlink" title="=      欢     迎     阅     读   《 V I M  教  程 》   ——     版本 1.5      ="></a>=      欢     迎     阅     读   《 V I M  教  程 》   ——     版本 1.5      =</h1><pre><code>vim 是一个具有很多命令的功能非常强大的编辑器。限于篇幅，在本教程当中就不详细介绍了。本教程的设计目标是讲述一些必要的基本命令，而掌握好这些命令，您就能够很容易将 vim 当作一个通用的万能编辑器来使用了。完成本教程的内容大约需要 25-30 分钟，取决于您训练的时间。每一节的命令操作将会更改本文。推荐您复制本文的一个副本，然后在副本上进行训练 (如果您是通过 &quot;vimtutor&quot; 来启动教程的，那么本文就已经是副本了)。切记一点∶本教程的设计思路是在使用中进行学习的。也就是说，您需要通过执行命令来学习它们本身的正确用法。如果您只是阅读而不操作，那么您可能会很快遗忘这些命令的！好了，现在请确定您的 Shift-Lock(大小写锁定键) 还没有按下，然后按键盘上的字母键 j 足够多的次数来移动光标，直到第一节的内容能够完全充满屏幕。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   第一讲第一节∶移动光标</span><br><span class="line">   ※※ 要移动光标，请依照说明分别按下 h、j、k、l 键。 ※※</span><br><span class="line">      ^</span><br><span class="line">      k      提示∶ h 的键位于左边，每次按下就会向左移动。</span><br><span class="line"> &lt;h     l&gt;         l 的键位于右边，每次按下就会向右移动。</span><br><span class="line">      j          j 键看起来很象一支尖端方向朝下的箭头。</span><br><span class="line">      v</span><br><span class="line">  1. 请随意在屏幕内移动光标，直至您觉得舒服为止。</span><br><span class="line">  2. 按下下行键 (j)，直到出现光标重复下行。</span><br><span class="line">---&gt; 现在您应该已经学会如何移动到下一讲吧。</span><br><span class="line">  3. 现在请使用下行键，将光标移动到第二讲。</span><br><span class="line">提示∶如果您不敢确定您所按下的字母，请按下 &lt;ESC&gt; 键回到正常 (Normal) 模式。</span><br><span class="line">      然后再次从键盘输入您想要的命令。</span><br><span class="line">提示∶光标键应当也能正常工作的。但是使用 hjkl 键，在习惯之后您就能够快速</span><br><span class="line">      地在屏幕内四处移动光标了。</span><br></pre></td></tr></table></figure><p>   第一讲第二节∶VIM 的进入和退出<br>  !! 特别提示∶敬请阅读完整本一节的内容，然后才能执行以下所讲解的命令。</p><ol><li>请按 <esc> 键 (这是为了确保您处在正常模式)。</esc></li><li>然后输入∶   :q! &lt;回车&gt;<br>—&gt; 这种方式的退出编辑器绝不会保存您进入编辑器以来所做的改动。<pre><code> 如果您想保存更改再退出，请输入∶:wq  &lt;回车&gt;</code></pre></li><li>如果您看到了命令行提示符，请输入能够带您回到本教程的命令，那就是∶<br>vimtutor &lt;回车&gt;<pre><code>通常情况下您也可以用这种方式∶</code></pre>  vim tutor &lt;回车&gt;<br>—&gt; 这里的’vim’ 表示进入 vim 编辑器，而’tutor’则是您准备要编辑的文件。</li><li>如果您自信已经牢牢记住了这些步骤的话，请从步骤 1 执行到步骤 3 退出，然<br>后再次进入编辑器。接着将光标移动到第一讲第三节来继续我们的教程讲解。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   第一讲第三节∶文本编辑之删除</span><br><span class="line">   ** 在正常 (Normal) 模式下，可以按下 x 键来删除光标所在位置的字符。**</span><br><span class="line">  1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line">  2. 为了修正输入错误，请将光标移至准备删除的字符的位置处。</span><br><span class="line">  3. 然后按下 x 键将错误字符删除掉。</span><br><span class="line">  4. 重复步骤 2 到步骤 4，直到句子修正为止。</span><br><span class="line">---&gt; The ccow jumpedd ovverr thhe mooon.</span><br><span class="line">  5. 好了，该行已经修正了，下一节内容是第一讲第四节。</span><br><span class="line">特别提示∶在您浏览本教程时，不要强行记忆。记住一点∶在使用中学习。</span><br></pre></td></tr></table></figure><pre><code>第一讲第四节∶文本编辑之插入</code></pre><p>  <strong> 在正常模式下，可以按下 i 键来插入文本。</strong></p><ol><li>请将光标移动到本节中下面标记有 —&gt; 的第一行。</li><li>为了使得第一行内容雷同于第二行，请将光标移至文本第一个字符准备插入<br>的位置。</li><li>然后按下 i 键，接着输入必要的文本字符。</li><li>所有文本都修正完毕，请按下 &lt; ESC &gt; 键返回正常模式。<br>重复步骤 2 至步骤 4 以便修正句子。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---&gt; There is text misng this .</span><br><span class="line">---&gt; There is some text missing from this line.</span><br></pre></td></tr></table></figure><ol><li>如果您对文本插入操作已经很满意，请接着阅读下面的小结。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          第一讲小结</span><br><span class="line">  1. 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。</span><br><span class="line">  h (左移) j (下行)       k (上行)     l (右移)</span><br><span class="line">  2. 欲进入 vim 编辑器 (从命令行提示符)，请输入∶vim 文件名 &lt; 回车 &gt;</span><br><span class="line">  3. 欲退出 vim 编辑器，请输入以下命令放弃所有修改∶</span><br><span class="line"> &lt;ESC&gt;   :q!  &lt; 回车 &gt;</span><br><span class="line">     或者输入以下命令保存所有修改∶</span><br><span class="line"> &lt;ESC&gt;   :wq  &lt; 回车 &gt;</span><br><span class="line">  4. 在正常模式下删除光标所在位置的字符，请按∶ x</span><br><span class="line">  5. 在正常模式下要在光标所在位置开始插入文本，请按∶</span><br><span class="line">  i     输入必要文本 &lt;ESC&gt;</span><br><span class="line">特别提示∶按下 &lt;ESC&gt; 键会带您回到正常模式或者取消一个不期望或者部分完成</span><br><span class="line">的命令。</span><br><span class="line">好了，第一讲到此结束。下面接下来继续第二讲的内容。</span><br></pre></td></tr></table></figure><p>   第二讲第一节∶删除类命令<br>     <strong> 输入 dw 可以从光标处删除至一个单字 / 单词的末尾。</strong></p><ol><li>请按下 <esc> 键确保您处于正常模式。</esc></li><li>请将光标移动到本节中下面标记有 —&gt; 的那一行。</li><li>请将光标移至准备要删除的单词的开始。</li><li>接着输入 dw 删除掉该单词。<br>特别提示∶您所输入的 dw 会在您输入的同时出现在屏幕的最后一行。如果您输<br>  入有误，请按下 <esc> 键取消，然后重新再来。<br>—&gt; There are a some words fun that don’t belong paper in this sentence.</esc></li><li>重复步骤 3 至步骤 4，直至句子修正完毕。接着继续第二讲第二节内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        第二讲第二节∶其他删除类命令</span><br><span class="line">     ** 输入 d$ 从当前光标删除到行末。**</span><br><span class="line">  1. 请按下 &lt;ESC&gt; 键确保您处于正常模式。</span><br><span class="line">  2. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line">  3. 请将光标移动到该行的尾部 (也就是在第一个点号‘.’后面)。</span><br><span class="line">  4. 然后输入 d$ 从光标处删至当前行尾部。</span><br><span class="line">---&gt; Somebody typed the end of this line twice. end of this line twice.</span><br><span class="line">  5. 请继续学习第二讲第三节就知道是怎么回事了。</span><br></pre></td></tr></table></figure><pre><code>第二讲第三节∶关于命令和对象</code></pre><p>  删除命令 d 的格式如下∶<br>  [number]   d object     或者     d  [number]   object<br>  其意如下∶<br>    number - 代表执行命令的次数 (可选项，缺省设置为 1)。<br>    d - 代表删除。<br>    object - 代表命令所要操作的对象 (下面有相关介绍)。<br>  一个简短的对象列表∶<br>    w - 从当前光标当前位置直到单字 / 单词末尾，包括空格。<br>    e - 从当前光标当前位置直到单字 / 单词末尾，但是 <em> 不 </em> 包括空格。<br>    $ - 从当前光标当前位置直到当前行末。<br>特别提示∶<br>    对于勇于探索者，请在正常模式下面仅按代表相应对象的键而不使用命令，则<br>    将看到光标的移动正如上面的对象列表所代表的一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  第二讲第四节∶对象命令的特殊情况</span><br><span class="line">        ** 输入 dd 可以删除整一个当前行。 **</span><br><span class="line">  鉴于整行删除的高频度，VIM 的设计者决定要简化整行删除，仅需要在同一行上</span><br><span class="line">  击打两次 d 就可以删除掉光标所在的整行了。</span><br><span class="line">  1. 请将光标移动到本节中下面的短句段落中的第二行。</span><br><span class="line">  2. 输入 dd 删除该行。</span><br><span class="line">  3. 然后移动到第四行。</span><br><span class="line">  4. 接着输入 2dd (还记得前面讲过的 number-command-object 吗？) 删除两行。</span><br><span class="line">      1)  Roses are red,</span><br><span class="line">      2)  Mud is fun,</span><br><span class="line">      3)  Violets are blue,</span><br><span class="line">      4)  I have a car,</span><br><span class="line">      5)  Clocks tell time,</span><br><span class="line">      6)  Sugar is sweet</span><br><span class="line">      7)  And so are you.</span><br></pre></td></tr></table></figure><pre><code>第二讲第五节∶撤消类命令</code></pre><p>  <strong> 输入 u 来撤消最后执行的命令，输入 U 来修正整行。</strong></p><ol><li>请将光标移动到本节中下面标记有 —&gt; 的那一行，并将其置于第一个错误<br>处。</li><li>输入 x 删除第一个不想保留的字母。</li><li>然后输入 u 撤消最后执行的 (一次) 命令。</li><li>这次要使用 x 修正本行的所有错误。</li><li>现在输入一个大写的 U ，恢复到该行的原始状态。</li><li>接着多次输入 u 以撤消 U 以及更前的命令。</li><li>然后多次输入 CTRL-R (先按下 CTRL 键不放开，接着输入 R 键) ，这样就<br>可以执行恢复命令，也就是撤消掉撤消命令。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---&gt; Fiix the errors oon thhis line and reeplace them witth undo.</span><br></pre></td></tr></table></figure><ol><li>这些都是非常有用的命令。下面是第二讲的小结了。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          第二讲小结</span><br><span class="line">  1. 欲从当前光标删除至单字 / 单词末尾，请输入∶dw</span><br><span class="line">  2. 欲从当前光标删除至当前行末尾，请输入∶d$</span><br><span class="line">  3. 欲删除整行，请输入∶dd</span><br><span class="line">  4. 在正常模式下一个命令的格式是∶</span><br><span class="line">       [number]   command   object     或者     command [number]   object</span><br><span class="line">     其意是∶</span><br><span class="line">       number - 代表的是命令执行的次数</span><br><span class="line">       command - 代表要做的事情，比如 d 代表删除</span><br><span class="line">       object - 代表要操作的对象，比如 w 代表单字 / 单词，$ 代表到行末等等。</span><br><span class="line">  $ (to the end of line), etc.</span><br><span class="line">  5. 欲撤消以前的操作，请输入∶u (小写的 u)</span><br><span class="line">     欲撤消在一行中所做的改动，请输入∶U (大写的 U)</span><br><span class="line">     欲撤消以前的撤消命令，恢复以前的操作结果，请输入∶CTRL-R</span><br></pre></td></tr></table></figure><pre><code>第三讲第一节∶置入类命令    ** 输入 p 将最后一次删除的内容置入光标之后 **</code></pre><ol><li>请将光标移动到本节中下面示范段落的首行。</li><li>输入 dd 将该行删除，这样会将该行保存到 vim 的缓冲区中。</li><li>接着将光标移动到准备置入的位置的上方。记住∶是上方哦。</li><li>然后在正常模式下 (<esc> 键进入)，输入 p 将该行粘贴置入。</esc></li><li>重复步骤 2 至步骤 4，将所有的行依序放置到正确的位置上。<br>d) Can you learn too?</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       b) Violets are blue,</span><br><span class="line">       c) Intelligence is learned,</span><br><span class="line">       a) Roses are red,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         第三讲第二节∶替换类命令</span><br><span class="line">   ** 输入 r 和一个字符替换光标所在位置的字符。**</span><br><span class="line">  1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line">  2. 请移动光标到第一个错误的适当位置。</span><br><span class="line">  3. 接着输入 r ，这样就能将错误替换掉了。</span><br><span class="line">  4. 重复步骤 2 和步骤 3，直到第一行已经修改完毕。</span><br><span class="line">---&gt;  Whan this lime was tuoed in, someone presswd some wrojg keys!</span><br><span class="line">---&gt;  When this line was typed in, someone pressed some wrong keys!</span><br><span class="line">  5. 然后我们继续学校第三讲第三节。</span><br><span class="line">特别提示∶切记您要在使用中学习，而不是在记忆中学习。</span><br></pre></td></tr></table></figure><p>   第三讲第三节∶更改类命令<br>    <strong> 要改变一个单字 / 单词的部分或者全部，请输入 cw </strong></p><ol><li>请将光标移动到本节中下面标记有 —&gt; 的第一行。</li><li>接着把光标放在单词 lubw 的字母 u 的位置那里。</li><li>然后输入 cw 就可以修正该单词了 (在本例这里是输入 ine 。)</li><li>最后按 <esc> 键，然后光标定位到下一个错误第一个准备更改的字母处。</esc></li><li>重复步骤 3 和步骤 4，直到第一个句子完全雷同第二个句子。<br>—&gt; This lubw has a few wptfd that mrrf changing usf the change command.<br>  —&gt; This line has a few words that need changing using the change command.<br>  提示∶请注意 cw 命令不仅仅是替换了一个单词，也让您进入文本插入状态了。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         第三讲第四节∶使用 c 指令的其他更改类命令</span><br><span class="line">      ** 更改类指令可以使用同删除类命令所使用的对象参数。**</span><br><span class="line">  1. 更改类指令的工作方式跟删除类命令是一致的。操作格式是∶</span><br><span class="line">       [number]   c   object    或者     c [number]   object</span><br><span class="line">  2. 对象参数也是一样的，比如 w 代表单字 / 单词，$ 代表行末等等。</span><br><span class="line">  3. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line">  4. 接着将光标移动到第一个错误处。</span><br><span class="line">  5. 然后输入 c$ 使得该行剩下的部分更正得同第二行一样。最后按 &lt;ESC&gt; 键。</span><br><span class="line">---&gt; The end of this line needs some help to make it like the second.</span><br><span class="line">---&gt; The end of this line needs to be corrected using the  c$  command.</span><br></pre></td></tr></table></figure><pre><code>第三讲小结</code></pre><ol><li>要重新置入已经删除的文本内容，请输入小写字母 p。该操作可以将已删除<br>的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">       于当前光标所在行的下一行。</span><br></pre></td></tr></table></figure><ol><li>要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字<br>符即可。</li><li>更改类命令允许您改变指定的对象，从当前光标所在位置直到对象的末尾。<br>比如输入 cw 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">       前光标到行末的内容。</span><br></pre></td></tr></table></figure><ol><li>更改类命令的格式是∶<br>[number]   c object       或者 c   [number]   object<br>下面我们继续学习下一讲。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       第四讲第一节∶定位及文件状态</span><br><span class="line">  ** 输入 CTRL-g 显示当前编辑文件中当前光标所在行位置以及文件状态信息。</span><br><span class="line">     输入 SHIFT-G 则直接跳转到文件中的某一指定行。**</span><br><span class="line">  提示∶切记要先通读本节内容，之后才可以执行以下步骤!!!</span><br><span class="line">  1. 按下 CTRL 键不放开然后按 g 键。然后就会看到页面最底部出现一个状态信</span><br><span class="line">     息行，显示的内容是当前编辑的文件名和文件的总行数。请记住步骤 3 的行号。</span><br><span class="line">  2. 按下 SHIFT-G 键可以使得当前光标直接跳转到文件最后一行。</span><br><span class="line">  3. 输入您曾停留的行号，然后按下 SHIFT-G。这样就可以返回到您第一次按下</span><br><span class="line">     CTRL-g 时所在的行好了。注意∶输入行号时，行号是不会在屏幕上显示出来</span><br><span class="line">     的。</span><br><span class="line">  4. 如果愿意，您可以继续执行步骤 1 至步骤三。</span><br></pre></td></tr></table></figure><p>   第四讲第二节∶搜索类命令<br>     <strong> 输入 / 以及尾随的字符串可以用以在当前文件中查找该字符串。</strong></p><ol><li>在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底<br>部，这跟 : 命令是一样的。</li><li>接着输入 errroor &lt;回车&gt;。那个 errroor 就是您要查找的字符串。</li><li>要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字<br>符串，请输入 Shift-N 即可。</li><li>如果您想逆向查找字符串，请使用 ? 代替 / 进行。<br>—&gt; When the search reaches the end of the file it will continue at the start.<pre><code>&quot;errroor&quot; is not the way to spell error;  errroor is an error.提示∶如果查找已经到达文件末尾，查找会自动从文件头部继续查找。</code></pre></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     第四讲第三节∶配对括号的查找</span><br><span class="line">       ** 按 % 可以查找配对的括号 )、]、&#125;。**</span><br><span class="line">  1. 把光标放在本节下面标记有 --&gt; 那一行中的任何一个 (、[ 或 &#123; 处。</span><br><span class="line">  2. 接着按 % 字符。</span><br><span class="line">  3. 此时光标的位置应当是在配对的括号处。</span><br><span class="line">  4. 再次按 % 就可以跳回配对的第一个括号处。</span><br><span class="line">---&gt; This (is a test line with (&apos;s, [&apos;s] and &#123;&apos;s &#125; in it. ))</span><br><span class="line">提示∶在程序调试时，这个功能用来查找不配对的括号是很有用的。</span><br></pre></td></tr></table></figure><pre><code>第四讲第四节∶修正错误的方法之一</code></pre><p>  <strong> 输入 :s/old/new/g 可以替换 old 为 new。</strong></p><ol><li>请将光标移动到本节中下面标记有 —&gt; 的那一行。</li><li>输入 :s/thee/the &lt;回车&gt; 。请注意该命令只改变光标所在行的第一个匹配<br>串。</li><li>输入 :s/thee/the/g 则是替换全行的匹配串。<br>—&gt; the best time to see thee flowers is in thee spring.</li><li>要替换两行之间出现的每个匹配串，请输入 :#,#s/old/new/g (#,# 代表的是<br>两行的行号)。输入 :%s/old/new/g 则是替换整个文件中的每个匹配串。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          第四讲小结</span><br><span class="line">  1. Ctrl-g 用于显示当前光标所在位置和文件状态信息。Shift-G 用于将光标跳</span><br><span class="line">     转至文件最后一行。先敲入一个行号然后按 Shift-G 则是将光标移动至该行</span><br><span class="line">     号代表的行。</span><br><span class="line">  2. 输入 / 然后紧随一个字符串是则是在当前所编辑的文档中向后查找该字符串。</span><br><span class="line">     输入问号 ? 然后紧随一个字符串是则是在当前所编辑的文档中向前查找该字</span><br><span class="line">     符串。完成一次查找之后按 n 键则是重复上一次的命令，可在同一方向上查</span><br><span class="line">     找下一个字符串所在；或者按 Shift-N 向相反方向查找下该字符串所在。</span><br><span class="line">  3. 如果光标当前位置是括号 (、)、[、]、&#123;、&#125;，按 % 可以将光标移动到配对的</span><br><span class="line">     括号上。</span><br><span class="line">  4. 在一行内替换头一个字符串 old 为新的字符串 new，请输入  :s/old/new</span><br><span class="line">     在一行内替换所有的字符串 old 为新的字符串 new，请输入  :s/old/new/g</span><br><span class="line">     在两行内替换所有的字符串 old 为新的字符串 new，请输入  :#,#s/old/new/g</span><br><span class="line">     在文件内替换所有的字符串 old 为新的字符串 new，请输入  :%s/old/new/g</span><br><span class="line">     进行全文替换时询问用户确认每个替换需添加 c 选项，请输入 :%s/old/new/gc</span><br></pre></td></tr></table></figure><p>  第五讲第一节∶在 VIM 内执行外部命令的方法<br>    <strong> 输入 :! 然后紧随著输入一个外部命令可以执行该外部命令。</strong></p><ol><li>按下我们所熟悉的 : 命令设置光标到屏幕底部。这样就可以让您输入命令了。</li><li>接着输入感叹号 ! 这个字符，这样就允许您执行外部的 shell 命令了。</li><li>我们以 ls 命令为例。输入 !ls &lt;回车&gt; 。该命令就会列举出您当前目录的<br>内容，就如同您在命令行提示符下输入 ls 命令的结果一样。如果 !ls 没起</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     作用，您可以试试 :!dir 看看。</span><br><span class="line">---&gt; 提示∶ 所有的外部命令都可以以这种方式执行。</span><br><span class="line">---&gt; 提示∶ 所有的 : 命令都必须以 &lt;回车&gt; 告终。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        第五讲第二节∶关于保存文件的更多信息</span><br><span class="line">      ** 要将对文件的改动保存到文件中，请输入 :w FILENAME 。**</span><br><span class="line">  1. 输入 :!dir 或者 :!ls 获知当前目录的内容。您应当已知道最后还得敲</span><br><span class="line">     &lt;回车&gt; 吧。</span><br><span class="line">  2. 选择一个尚未存在文件名，比如 TEST 。</span><br><span class="line">  3. 接着输入 :w TEST  (此处 TEST 是您所选择的文件名。)</span><br><span class="line">  4. 该命令会以 TEST 为文件名保存整个文件 (VIM 教程)。为了确保正确保存，</span><br><span class="line">     请再次输入 :!dir 查看您的目录列表内容。</span><br><span class="line">---&gt; 请注意∶如果您退出 VIM 然后在以文件名 TEST 为参数进入，那么该文件内</span><br><span class="line">     容应该同您保存时的文件内容是完全一样的。</span><br><span class="line">  5. 现在您可以通过输入 :!rm TEST 来删除 TEST 文件了。</span><br></pre></td></tr></table></figure><pre><code>第五讲第三节∶一个具有选择性的保存命令</code></pre><p>  <strong> 要保存文件的部分内容，请输入 :#,# w FILENAME </strong></p><ol><li>再来执行一次 :!dir 或者 :!ls 获知当前目录的内容，然后选择一个合适的<br>不重名的文件名，比如 TEST 。</li><li>接着将光标移动至本页的最顶端，然后按 CTRL-g 找到该行的行号。别忘了<br>行号哦。</li><li>接着把光标移动至本页的最底端，再按一次 CTRL-g 。也别忘了这个行好哦。</li><li>为了只保存文章的某个部分，请输入 :#,# w TEST 。这里的 #,# 就是上面<br>要求您记住的行号 (顶端行号, 底端行号)，而 TEST 就是选定的文件名。</li><li>最后，用 :!dir 确认文件是否正确保存。但是这次先别删除掉。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     第五讲第四节∶提取和合并文件</span><br><span class="line">       ** 要向当前文件中插入另外的文件的内容，请输入 :r FILENAME **</span><br><span class="line">  1. 请键入 :!dir 确认您前面创建的 TEST 文件还在。</span><br><span class="line">  2. 然后将光标移动至当前页面的顶端。</span><br><span class="line">特别提示∶ 执行步骤 3 之后您将看到第五讲第三节，请届时再往下移动回到这里来。</span><br><span class="line">  3. 接着通过 :r TEST 将前面创建的名为 TEST 的文件提取进来。</span><br><span class="line">特别提示∶您所提取进来的文件将从光标所在位置处开始置入。</span><br><span class="line">  4. 为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份第</span><br><span class="line">     五讲第三节，一份是原本，另外一份是来自文件的副本。</span><br></pre></td></tr></table></figure><pre><code>第五讲小结</code></pre><ol><li>:!command 用于执行一个外部命令 command。<br>请看一些实际例子∶</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     :!dir  -  用于显示当前目录的内容。</span><br><span class="line">     :!rm FILENAME  - 用于删除名为 FILENAME 的文件。</span><br></pre></td></tr></table></figure><ol><li>:w FILENAME  可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文<br>件中。</li><li>:#,#w FILENAME 可将当前编辑文件第 # 行至第 # 行的内容保存到文件<br>FILENAME 中。</li><li>:r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置<br>后面。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    第六讲第一节∶打开类命令</span><br><span class="line">  ** 输入 o 将在光标的下方打开新的一行并进入插入模式。**</span><br><span class="line">  1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line">  2. 接着输入小写的 o 在光标 * 下方 * 打开新的一行并进入插入模式。</span><br><span class="line">  3. 然后复制标记有 ---&gt; 的行并按 &lt;ESC&gt; 键退出插入模式而进入正常模式。</span><br><span class="line">---&gt; After typing  o  the cursor is placed on the open line in Insert mode.</span><br><span class="line">  4. 为了在光标 * 上方 * 打开新的一行，只需要输入大写的 O 而不是小写的 o</span><br><span class="line">     就可以了。请在下行测试一下吧。当光标处在在该行上时，按 Shift-O 可以</span><br><span class="line">     在该行上方新开一行。</span><br><span class="line">Open up a line above this by typing Shift-O while the cursor is on this line.</span><br></pre></td></tr></table></figure><p>   第六讲第二节∶光标后插入类命令<br>       <strong> 输入 a 将可在光标之后插入文本。 </strong></p><ol><li>请在正常模式下通过输入 $ 将光标移动到本节中下面标记有 —&gt; 的第一行<br>的末尾。</li><li>接着输入小写的 a 则可在光标之后插入文本了。大写的 A 则可以直接在行<br>末插入文本。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示∶输入大写 A 的操作方法可以在行末插入文本，避免了输入 i，光标定位到</span><br><span class="line">      最后一个字符，输入的文本，&lt;ESC&gt; 回复正常模式，箭头右键移动光标以及</span><br><span class="line">      x 删除当前光标所在位置字符等等诸多繁杂的操作。</span><br></pre></td></tr></table></figure><ol><li>操作之后第一行就可以补充完整了。请注意光标后插入文本与插入模式是基<br>本完全一致的，只是文本插入的位置定位稍有不同罢了。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---&gt; This line will allow you to practice</span><br><span class="line">---&gt; This line will allow you to practice appending text to the end of a line.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      第六讲第三节∶另外一个置换类命令的版本</span><br><span class="line">        ** 输入大写的 R 可连续替换多个字符。**</span><br><span class="line">  1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line">  2. 移动光标到第一行中不同于标有 ---&gt; 的第二行的第一个单词的开始，即单</span><br><span class="line">     词 last 处。</span><br><span class="line">  3. 然后输入大写的 R 开始把第一行中的不同于第二行的剩余字符逐一输入，就</span><br><span class="line">     可以全部替换掉原有的字符而使得第一行完全雷同第二行了。</span><br><span class="line">---&gt; To make the first line the same as the last on this page use the keys.</span><br><span class="line">---&gt; To make the first line the same as the second, type R and the new text.</span><br><span class="line">  4. 请注意∶如果您按 &lt;ESC&gt; 退出置换模式回复正常模式，尚未替换的文本将仍</span><br><span class="line">     然保持原状。</span><br></pre></td></tr></table></figure><pre><code>   第六讲第四节∶设置类命令的选项** 设置可使查找或者替换可忽略大小写的选项 **</code></pre><ol><li>要查找单词 ignore 可在正常模式下输入 /ignore 。要重复查找该词，可以<br>重复按 n 键。</li><li>然后设置 ic 选项 (ic 就是英文忽略大小写 Ignore Case 的首字母缩写词)，即<br>输入∶</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   :set ic</span><br></pre></td></tr></table></figure><ol><li>现在可以通过键入 n 键再次查找单词 ignore。重复查找可以重复键入 n 键。</li><li>然后设置 hlsearch 和 incsearch 这两个选项，输入以下内容∶<br>:set hls is</li><li>现在可以再次输入查找命令，看看会有什么效果∶<br>/ignore</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">          第六讲小结</span><br><span class="line">  1. 输入小写的 o 可以在光标下方打开新的一行并将光标置于新开的行首，进入</span><br><span class="line">     插入模式。</span><br><span class="line">     输入大写的 O 可以在光标上方打开新的一行并将光标置于新开的行首，进入</span><br><span class="line">     插入模式。</span><br><span class="line">  2. 输入小写的 a 可以在光标所在位置之后插入文本。</span><br><span class="line">     输入大写的 A 可以在光标所在行的行末之后插入文本。</span><br><span class="line">  3. 输入大写的 R 将进入替换模式，直至按 &lt;ESC&gt; 键退出替换模式而进入正常</span><br><span class="line">     模式。</span><br><span class="line">  4. 输入 :set xxx 可以设置 xxx 选项。</span><br></pre></td></tr></table></figure><pre><code> 第七讲∶在线帮助命令** 使用在线帮助系统 **</code></pre><p>  Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方<br>  法之一∶</p><ul><li>按下 <help> 键 (如果键盘上有的话)</help></li><li>按下 <f1> 键 (如果键盘上有的话)</f1></li><li>输入 :help &lt;回车&gt;<br>输入 :q &lt;回车&gt; 可以关闭帮助窗口。<br>  提供一个正确的参数给 “:help” 命令，您可以找到关于该主题的帮助。请试验以<br>  下参数 (可别忘了按回车键哦。:)∶<br>   :help w &lt;回车&gt;<br>   :help c_&lt;T &lt; 回车&gt;<br>   :help insert-index &lt;回车&gt;<br>   :help user-manual &lt;回车&gt;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">         第八讲∶创建一个启动脚本</span><br><span class="line">     ** 启用 vim 的功能 **</span><br><span class="line">  Vim 的功能特性要比 vi 多得多，但大部分功能都没有缺省激活。为了启动更多的</span><br><span class="line">  功能，您得创建一个 vimrc 文件。</span><br><span class="line">  1. 开始编辑 vimrc 文件，这取决于您所使用的操作系统∶</span><br><span class="line">     :edit ~/.vimrc  这是 Unix 系统所使用的命令</span><br><span class="line">     :edit $VIM/_vimrc  这是 Windows 系统所使用的命令</span><br><span class="line">  2. 接着导入 vimrc 范例文件∶</span><br><span class="line">     :read $VIMRUNTIME/vimrc_example.vim</span><br><span class="line">  3. 保存文件，命令为∶</span><br><span class="line">     :write</span><br><span class="line">  在下次您启动 vim 的时候，编辑器就会有了语法高亮的功能。您可以继续把您喜</span><br><span class="line">  欢的其它功能设置添加到这个 vimrc 文件中。</span><br></pre></td></tr></table></figure><p>  vim 教程到此结束。本教程只是为了简明地介绍一下 vim 编辑器，但已足以让您<br>  很容易学会使用本编辑器了。全文完本文由 简悦 SimpRead 优化，用以提升阅读体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VimTutor 中文版——vim 学习不二基础&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://jack-wang128801.github.io/categories/Linux/"/>
    
    
      <category term="Vim 使用手册" scheme="https://jack-wang128801.github.io/tags/Vim-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://jack-wang128801.github.io/2019/05/01/%E6%8E%92%E5%BA%8F/"/>
    <id>https://jack-wang128801.github.io/2019/05/01/排序/</id>
    <published>2019-05-01T05:00:35.000Z</published>
    <updated>2019-05-05T15:03:40.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><a id="more"></a><h5 id="排序的概念"><a href="#排序的概念" class="headerlink" title="排序的概念"></a>排序的概念</h5><blockquote></blockquote><h4 id="常见的排序种类"><a href="#常见的排序种类" class="headerlink" title="常见的排序种类"></a>常见的排序种类</h4><p><img src="https://wx4.sinaimg.cn/mw690/0071OE7sly1g2lqu7swexj30qv0jktcm.jpg" alt></p><h5 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h5><blockquote><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。</p></blockquote><h5 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h5><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h3&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://jack-wang128801.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://jack-wang128801.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux的开发工具</title>
    <link href="https://jack-wang128801.github.io/2019/04/29/Linux%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>https://jack-wang128801.github.io/2019/04/29/Linux的开发工具/</id>
    <published>2019-04-29T14:49:24.000Z</published>
    <updated>2019-05-05T15:05:04.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-下的开发工具"><a href="#Linux-下的开发工具" class="headerlink" title="Linux 下的开发工具"></a>Linux 下的开发工具</h3><a id="more"></a><p><strong>vs是一个IDE(集成开发环境)</strong></p><blockquote><p>1.代码编辑器</p><p>2.编译器</p><p>3.调试器</p><p>4.工程管理工具</p><p>5其他 ….</p></blockquote><p><strong>Java</strong></p><blockquote><p>Eclipse ===&gt;也可以开发C++</p><p>IDEA  ====&gt;也可开发c++</p></blockquote><p><strong>JetBrains(全家桶)</strong></p><blockquote><p>CLion(C++)</p><p>PHP(PHPStorm)</p><p>PyCharm(Python)</p><p>JavaScript(WebStorm)</p><p>Go(GoLand)</p></blockquote><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><p><strong>1.代码编辑：vim</strong></p><p><strong>2.编译：gcc</strong></p><p><strong>3.调试：gdb </strong></p><p><strong>4.工程管理:makefile</strong></p><h5 id="包管理器-：-yum-命令行版的应用商店"><a href="#包管理器-：-yum-命令行版的应用商店" class="headerlink" title="包管理器 ：  yum(命令行版的应用商店)"></a>包管理器 ：  yum(命令行版的应用商店)</h5><p><strong>对应的服务器叫做软件源</strong></p><p><strong>yum的所有操作都要在网络畅通的情况下使用</strong></p><p><strong>yum的局限性: 只能安装一些比较知名的软件(也可以直接以源代码的方式进行安装)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yun list | grep tree</span><br></pre></td></tr></table></figure><blockquote><p>“ | “   左边的输出内容做为右边的输入</p><p>“ |”   叫做管道,能够链接两条指令</p><p>通过  “|”  将左边的指令执行结果进行过滤</p></blockquote><h5 id="yum-的基本用法"><a href="#yum-的基本用法" class="headerlink" title="yum  的基本用法"></a>yum  的基本用法</h5><blockquote><p>1.yum list    //查找需要的软件(一般不按回车,服务器上的软件过多会导致电脑卡死)</p><p>2.yum install 安装(必须有管理员权限)</p><p>3.yum  remove (卸载软件)</p><p><strong>除了yum安装之外，还可以使用源代码直接编译的方式安装(极其复杂，非专业人士不要尝试)</strong></p></blockquote><p><strong>su 能够切到管理员用户</strong></p><p><strong>退出管理员:exit 或者 Ctrl + d</strong></p><p><strong>sudo  不切换用户，但是要使用管理员权限运行程序</strong></p><h4 id="vim编辑器-神之编辑器"><a href="#vim编辑器-神之编辑器" class="headerlink" title="vim编辑器(神之编辑器)"></a>vim编辑器(神之编辑器)</h4><p><strong>史上最牛逼的文本编辑器之一</strong>            </p><p><strong>并肩的存在:Emacs(编辑器之神)—-&gt;依赖的编程语言Lisp(与c语言齐名)</strong></p><h5 id="Vim的强大之处"><a href="#Vim的强大之处" class="headerlink" title="Vim的强大之处"></a>Vim的强大之处</h5><blockquote><ol><li>支持非常丰富的快捷键(操作效率非常高，学习成本比较高)演化成了一种思想。</li><li>支持非常强大的扩展能力(插件机制)。背后依赖着一个编程语言(VimL)</li></ol></blockquote><h5 id="Vim-的竞争对手"><a href="#Vim-的竞争对手" class="headerlink" title="Vim 的竞争对手"></a>Vim 的竞争对手</h5><blockquote><p>notepad++ /  notepadplus /utrla edit /source insight</p></blockquote><h5 id="Vim-基于模式的方式完成编辑"><a href="#Vim-基于模式的方式完成编辑" class="headerlink" title="Vim 基于模式的方式完成编辑"></a>Vim 基于模式的方式完成编辑</h5><blockquote><p>Vim  刚刚启动的时候是普通模式(vimtutor)，普通模式下不能直接输入内容。此时敲下的按键多半是带有特殊功能的快捷键，需要进入插入模式才能进行编辑</p><p>1.”：w “ 进行保存</p><p>2.”：q”   进行退出</p><p>3.普通模式下按 “:” 进入底行模式</p></blockquote><h5 id="vim-文件"><a href="#vim-文件" class="headerlink" title="vim[文件]"></a>vim[文件]</h5><blockquote><p>打开一个文件，不存在就会创建新文件</p><p>vim是一个多模式的文本编辑器</p></blockquote><h4 id="能够与Vim并肩的编辑器"><a href="#能够与Vim并肩的编辑器" class="headerlink" title="能够与Vim并肩的编辑器"></a>能够与Vim并肩的编辑器</h4><h5 id="Sublimme-Text-史上最性感的编辑器"><a href="#Sublimme-Text-史上最性感的编辑器" class="headerlink" title="Sublimme Text(史上最性感的编辑器)"></a>Sublimme Text(史上最性感的编辑器)</h5><blockquote><p>1.界面好看</p><p>2.支持vim风格的快捷键</p></blockquote><h5 id="Atom-Github官方编辑器"><a href="#Atom-Github官方编辑器" class="headerlink" title="Atom(Github官方编辑器 )"></a>Atom(Github官方编辑器 )</h5><blockquote><p>1.界面好看</p><p>2.支持Vim风格的快捷键</p><p>3.支持非常强大的扩展(安装插件非常方便)</p><p>4.致命缺陷：启动非常慢</p></blockquote><h5 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h5><blockquote><p>真正有望取代Vim的软件</p></blockquote><h5 id="VScode-MS-—-》依赖图形界面"><a href="#VScode-MS-—-》依赖图形界面" class="headerlink" title="VScode(MS)  —-》依赖图形界面"></a>VScode(MS)  —-》依赖图形界面</h5><blockquote><p>1.界面好看</p><p>2.支持Vim 的扩展功能(安装插件极其方便)</p><p>3.启动速度很快</p></blockquote><h5 id="vim-打开的同是会产生一个-swap文件"><a href="#vim-打开的同是会产生一个-swap文件" class="headerlink" title="vim 打开的同是会产生一个     . swap文件"></a>vim 打开的同是会产生一个     . swap文件</h5><h5 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h5><blockquote><p>预处理： 头文件替换，宏展开，去掉注释，条件编译，其他预处理指令</p><p>编译：源代码文件转换成汇编代码</p><p>汇编：汇编代码转换成二进制文件</p><p>链接：把所有的二进制文件和依赖的库合到一块，得到可执行程序</p></blockquote><blockquote><p>gcc test.c -o test //生成一个叫 test 的可执行文件 ，默认生成的是  a.out</p><p>gcc    -E //只进行预处理,不生成文件，你需要把他重定向到一个输出文件里面</p><p>gcc    -E  test.c   -o test.i    //对test.c进行预处理</p><p>vim test.i     //查看预处理后的结果</p><p>gcc   -S  test.i   - 0   test.s     //进行编译得到汇编代码</p></blockquote><blockquote><p>-g 选项  编译的时候保留调试信息         </p></blockquote><p><strong>gcc 下的选项</strong></p><blockquote><p>-E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面<br>-S  编译到汇编语言不进行汇编和链接<br>-c  编译到目标代码<br>-o 文件输出到 文件<br>-static 此选项对生成的文件采用静态链接<br>-g 生成调试信息。GNU 调试器可利用该信息。<br>-shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.<br>-O0<br>-O1<br>-O2<br>-O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高<br>-w  不生成任何警告信息。<br>-Wall 生成所有警告信息</p></blockquote><p><strong>优化级别越高程序的实际执行顺序就和原来的执行顺序差别越大必须 要关闭优化才能进行调试 </strong></p><p><strong>一般调试的时候用  -O0</strong></p><h5 id="gbd-：-Linux下的命令行调试工具"><a href="#gbd-：-Linux下的命令行调试工具" class="headerlink" title="gbd ： Linux下的命令行调试工具"></a>gbd ： Linux下的命令行调试工具</h5><p><strong>Linux下调试的背景</strong></p><blockquote><ul><li>程序的发布方式有两种，debug模式和release模式</li><li>Linux gcc/g++出来的二进制程序，默认是release模式</li><li>要使用gdb调试，必须在源代码生成二进制程序的时候, 加上 -g 选项［重要］</li></ul></blockquote><p><strong>使用场景</strong></p><blockquote><p>break  n   //在第n 行打断点，参数可以是一个行号，也可以是函数名</p><p>run/r     : 开始执行</p><p>next/n   :单步执行(逐过程)</p><p>stp/s      :单步执行(逐语句)</p><p>bt           : 调用函数栈帧</p><p>Ctrl + r   :快速搜索</p><p>frame/f  :  切换到某个指定栈帧</p></blockquote><p><strong>gdb的使用场景</strong></p><blockquote><p>1.使用gdb调试coredump(核心转储文件)文件<strong>(coredump是程序的临终遗言，最后的 运行状况</strong>)     </p><p>​                                                                           程序奔溃：可以利用空指针的方式 </p><p>​                                                                           事后调试:   </p><p>2.使用gdb attach(附加) 上一个程序。</p><p>​                                                                        TODO(进程相关的内容)</p></blockquote><p><strong>cgdb：更方便一点</strong></p><h5 id="调试一个问题的步骤和思路"><a href="#调试一个问题的步骤和思路" class="headerlink" title="调试一个问题的步骤和思路"></a>调试一个问题的步骤和思路</h5><blockquote><p>1.确认是不是bug：唯一依据就是产品需求</p><p>2.确认有bug后，开始定位bug ：找到是那行代码引起的bug</p><p>3.分析问题的原因(幸福感).</p><p>4.提出方案并修改问题</p><p>5.测试(回归测试,防止代码的修改引入新的问题).由于回归测试 ，成本比较高</p><p>往往以自动化测试为主。</p></blockquote><h5 id="vs-中-调试的操作"><a href="#vs-中-调试的操作" class="headerlink" title="vs 中 调试的操作"></a>vs 中 调试的操作</h5><blockquote><p>1.打断点</p><p>2.</p></blockquote><h4 id="工程管理工具-c-java中存在"><a href="#工程管理工具-c-java中存在" class="headerlink" title="工程管理工具(c++,java中存在)"></a>工程管理工具(c++,java中存在)</h4><p><strong>解决大型项目中的模块之间的依赖问题</strong></p><p><strong>工具名称：makefile(40年前的技术)</strong></p><p><strong>当前的现代c/c++工程管理工具本质都是通过自动化 的方式生成makefile</strong></p><blockquote><p>1.先在当前目录中查找Makefile/Makefile 文件</p><p>2.找到要生成的目标(决定是否要真的生成)</p><p>3.检查以来的文件是否存在</p><p>4.执行生成动作的命令</p></blockquote><p><strong>增量编译</strong> </p><h3 id="vim-的配置"><a href="#vim-的配置" class="headerlink" title="vim 的配置"></a>vim 的配置</h3><p><strong>码云  Vimforcpp</strong></p><blockquote><p>按下Esc进入普通模式，按空格进人编辑器功能 选择模式</p><p>退出选择模式的方法 按下空格键然后按下 f 和a</p></blockquote><h5 id="其他的vim配置"><a href="#其他的vim配置" class="headerlink" title="其他的vim配置"></a>其他的vim配置</h5><blockquote><p>spacevim 一套比较知名的配置(对于新手特别不友好)</p><p>vimplus   稍微旧一点的，有些功能不是很科学</p><p>vimforcpp ：为比特同学量身定做</p></blockquote><h5 id="vimtutor下几种模式间的相互转换"><a href="#vimtutor下几种模式间的相互转换" class="headerlink" title="vimtutor下几种模式间的相互转换"></a>vimtutor下几种模式间的相互转换</h5><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g2jl08p9xfj30un0gddhv.jpg" alt></p><p>《龙书》，《虎书》，《鲸书》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux-下的开发工具&quot;&gt;&lt;a href=&quot;#Linux-下的开发工具&quot; class=&quot;headerlink&quot; title=&quot;Linux 下的开发工具&quot;&gt;&lt;/a&gt;Linux 下的开发工具&lt;/h3&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://jack-wang128801.github.io/categories/Linux/"/>
    
    
      <category term="Linux的开发工具" scheme="https://jack-wang128801.github.io/tags/Linux%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>系统编程</title>
    <link href="https://jack-wang128801.github.io/2019/04/29/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>https://jack-wang128801.github.io/2019/04/29/系统编程/</id>
    <published>2019-04-29T12:36:03.000Z</published>
    <updated>2019-05-09T03:34:52.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux进程的概念"><a href="#Linux进程的概念" class="headerlink" title="Linux进程的概念"></a>Linux进程的概念</h2><p><strong>1.冯诺依曼体系</strong></p><p><strong>2. 操作系统</strong></p><p><strong>3.进程</strong></p><p><strong>3.1 主要：僵尸进程</strong></p><a id="more"></a><h3 id="系统编程"><a href="#系统编程" class="headerlink" title="系统编程"></a>系统编程</h3><h4 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h4><h4 id="1-图示"><a href="#1-图示" class="headerlink" title="1.图示"></a>1.图示</h4><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g2qw6d7t2yj30v40f1aao.jpg" alt></p><h4 id="2-计算机的组成分类"><a href="#2-计算机的组成分类" class="headerlink" title="2.计算机的组成分类"></a>2.计算机的组成分类</h4><ul><li style="list-style: none"><input type="checkbox"> 1.输入单元：包括键盘、鼠标、卡片阅读器、扫描仪、手写板、触摸屏等</li><li style="list-style: none"><input type="checkbox"> 中央处理器(CPU):含有算术逻辑、控制、记忆等单元</li><li style="list-style: none"><input type="checkbox"> 输出设备:例如屏幕、打印机等</li></ul><p><strong>CPU: </strong></p><blockquote><p>也可以通过”<strong>寄存器</strong>“存储少量的数据，寄存器的访问速度特别快</p></blockquote><p><strong>门电路: </strong></p><table><thead><tr><th style="text-align:center">与门</th><th>遇0则0</th></tr></thead><tbody><tr><td style="text-align:center">或</td><td>遇1则1</td></tr><tr><td style="text-align:center">非</td><td>改变状态</td></tr><tr><td style="text-align:center">异或门</td><td>相同为0，相异为1</td></tr></tbody></table><p><strong>储存设备:</strong></p><blockquote><p>内存:   空间比较小，访问速度快，成本较高，断电之后数据丢失</p><p>外存：空间较大。访问速度慢成本较低，断电之后数据依然存在</p></blockquote><p><strong>强调的点</strong></p><blockquote><p>这里的存储器指的是内存不考虑缓存情况，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)外设(输入或输出设备)要输入或者输出数据，也只能写入内存或者从内存中读取。<br><strong>一句话，所有设备都只能直接和内存打交道</strong>。</p></blockquote><h3 id="操作系统-搞管理的软件"><a href="#操作系统-搞管理的软件" class="headerlink" title="操作系统(搞管理的软件)"></a>操作系统(搞管理的软件)</h3><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g2qwkplzovj30v20dmdgo.jpg" alt></p><ul><li style="list-style: none"><input type="checkbox"> 管理硬件设备</li><li style="list-style: none"><input type="checkbox"> 管理软件资源</li></ul><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><ul><li>内核（进程管理，内存管理、文件管理、驱动管理）</li><li>其他程序(例如函数库，shell程序等等)</li></ul></blockquote><h4 id="设计操作系统的目的"><a href="#设计操作系统的目的" class="headerlink" title="设计操作系统的目的"></a>设计操作系统的目的</h4><blockquote><ul><li>与硬件交互，管理所有的软硬件资源</li><li>为用户程序(应用程序)提供一个良好的执行环境</li></ul></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>计算机管理硬件</strong></p><blockquote><p>1.描述起来 :用struct结构体</p><p>2.组织起来: 用链表或者其他高效的数据结构</p></blockquote><h3 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h3><ul><li style="list-style: none"><input type="checkbox"> <strong>ps</strong> 相当于任务管理去器，能够查看系统都有哪些进程</li><li style="list-style: none"><input type="checkbox"> <strong>ps   aux</strong>  查看所有进程</li><li style="list-style: none"><input type="checkbox"> <strong>ps   aux  | less</strong>  配合<strong>less</strong> 对查看结果进行翻页和其他操作</li><li style="list-style: none"><input type="checkbox"> <strong>ps   aux   | grep [进程名]</strong>   查看匹配的结果</li><li style="list-style: none"><input type="checkbox"> <strong>Ctrl   +   z</strong>  将一个程序放到后台，但是不退出程序</li><li style="list-style: none"><input type="checkbox"> 按下  <strong>fg</strong>   将后台的程序调到前台继续执行</li><li style="list-style: none"><input type="checkbox"> <strong>Ctrl     +  c</strong>    关闭一个正在执行的进程</li></ul><blockquote><p>敲下的命令，在命令执行的过程中也是一个进程</p></blockquote><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g2stgtf6i7j316206g0th.jpg" alt></p><h5 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h5><h5 id="1-描述进程-PCB进程控制块-–-gt-就是一个结构-task-struct"><a href="#1-描述进程-PCB进程控制块-–-gt-就是一个结构-task-struct" class="headerlink" title="1.描述进程(PCB进程控制块 –&gt; 就是一个结构(task_struct))"></a>1.描述进程(PCB进程控制块 –&gt; 就是一个结构(task_struct))</h5><p><strong>PCB：针对通常情况</strong></p><p><strong>task_struct：只针对Linux</strong></p><blockquote><p>​      task_struct 是一个很大的结构体，包含很多的内容</p><p>​       <strong>a.进程标识符(pid)</strong></p><p>​        <strong>b.内存指针(告诉 进程代码/数据都存在内存的那个部分)</strong></p><hr><p>​       <strong>c.进程状态</strong></p><p>​       <strong>d.优先级:数字，表示这个进程是先被调度还是后被调度执行</strong></p><p>​       <strong>PR:</strong>      数字越小，优先级别越高</p><p>​        <strong>NI(nice):</strong>      优先级的修正值，<strong>PR+NI =&gt; 最终的PR</strong></p><p>通过指令可以调整nice，宏观上往往看不出效果</p><p><strong>e:上下文(寄存器)</strong></p><p>   cpu 可能又几十个寄存器，</p><p>​    作用：<strong>保存上下文</strong>，cpu寄存器的内容保存到内存中</p><p>​               <strong>恢复向下文</strong>，内存中的寄存器值恢复到cpu中</p><p><strong>f:记账信息;每个进程已经在C</strong>PU上执行<strong>多久统计数据</strong></p></blockquote><h5 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h5><blockquote><p>R 就绪状态，进程在就绪队列中，就会处于这个状态</p><p>S   睡眠状态，单身状态，暂时还轮不到他</p><p>D   深度睡眠状态，密集地进行IO操作的时候(吐coredump)</p><p>T    暂停stop</p><p>t    跟踪trace</p><p>X    进程已经结束，只是在Linux 源代码中存在，真实是看不到的</p><p>Z     <strong>僵尸进程</strong>  和父进程子进程这些有关联</p></blockquote><h4 id="父进程-ppid-与子进程-pid"><a href="#父进程-ppid-与子进程-pid" class="headerlink" title="父进程(ppid)与子进程(pid)"></a>父进程(ppid)与子进程(pid)</h4><p><strong>使用代码来创建子进程</strong></p><blockquote><p>fork ()</p><p>fork有两个返回值<br>父子进程代码共享，数据各自开辟空间，私有一份（采用写时拷贝）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      fork();</span><br><span class="line">    <span class="comment">//gitpid 获取进程的进程</span></span><br><span class="line">    <span class="comment">//gitppid 获取夫进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>,getpid(),getppid());</span><br><span class="line">    sleep(<span class="number">1</span>);                                                                           </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>fork 之后通常要用 if 进行分流</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> ret = fork();</span><br><span class="line"> <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> perror(<span class="string">"fork"</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; <span class="comment">//child</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"I am child : %d!, ret: %d\n"</span>, getpid(), ret);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123; <span class="comment">//father</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"I am father : %d!, ret: %d\n"</span>, getpid(), ret);</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fork"><a href="#fork" class="headerlink" title="fork ()"></a>fork ()</h5><p><strong>1.返回值：一次调用两个返回值</strong></p><blockquote><p>  父进程返回子进程的pid</p><p>​    子进程返回 0</p><p>​     通常需要让父子进程执行不同的逻辑，就可以借助<strong>fork</strong>的返回值来进行区分</p><p><strong>如果失败  返回&lt; 0 的结果(可能原因)</strong></p><p>   a. 内存不够</p><p>   b. 进程太多达到上限</p><p>​    RLIMIT_NPROC</p></blockquote><p><strong>2. 执行过程</strong></p><blockquote><p>父子进程都是紧接着fork继续执行</p></blockquote><p><strong>3. 先后顺序</strong></p><blockquote><p>不确定，取决于操作系统的调度器</p></blockquote><h5 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h5><p><strong>让少量的CPU能够满足大量的进程同时执行的需求</strong></p><p><strong>并行：两个CPU分别执行两个进程</strong></p><p><strong>并发:一个CPU”同时”执行两个进程，切换执行，并非同时进行</strong></p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p><strong>成因:子进程结束之后，父进程没有回收子进程的资源，为了解决子进程向父进程汇报工作的问题</strong></p><p><strong>危害：处理不当会造成内存泄漏</strong></p><p><strong>处理：直kill 僵尸进程是kill 不掉的，可以kill 僵尸进程的父进程。更科学的处理办法是: 进程等待</strong></p><p><strong>为什么 kill 父进程僵尸进程没了？</strong></p><blockquote><p>当kill 掉父进程之后，<strong>子进程就被称为孤儿进程</strong>，孤儿进程会<strong>被 1 号进程(init进程)收养</strong>，从而释放资源</p></blockquote><p><strong>init进程：开机时运行的第一个进程</strong></p><h5 id="2-组织进程"><a href="#2-组织进程" class="headerlink" title="2.组织进程"></a>2.组织进程</h5><blockquote><p>双向链表进行组织，每个结点就是一个task_ struct(只针对Linux)</p></blockquote><h5 id="除了ps-之外top也可以查看进程的状态"><a href="#除了ps-之外top也可以查看进程的状态" class="headerlink" title="除了ps 之外top也可以查看进程的状态"></a>除了ps 之外top也可以查看进程的状态</h5><blockquote><p><strong>PR:</strong>数字越小，优先级别越高</p><p><strong>NI(nice):</strong>优先级的修正值，<strong>PR+NI =&gt; 最终的PR</strong></p><p>通过指令可以调整nice，宏观上往往看不出效果</p></blockquote><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><blockquote><p> 环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些参数</p><p>环境<a href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">变量</a>是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">程序</a>所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525" target="_blank" rel="noopener">程序</a>而没有告诉它程序所在的完整路径时，系统除了在<a href="https://baike.baidu.com/item/%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95/7205107" target="_blank" rel="noopener">当前目录</a>下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境<a href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">变量</a>，来更好的运行进程。 </p><p>环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性</p></blockquote><h5 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h5><p><strong>PATH : 指定命令的搜索路径</strong><br><strong>HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)</strong><br><strong>SHELL : 当前Shell,它的值通常是/bin/bash</strong>。</p><h5 id="查看环境变量的命令"><a href="#查看环境变量的命令" class="headerlink" title="查看环境变量的命令"></a>查看环境变量的命令</h5><p><strong>echo $NAME //NAME:你的环境变量名称</strong></p><blockquote><p>例如: <strong>echo $PATH 或者echo $HOME</strong></p></blockquote><h4 id="键值对-key-value"><a href="#键值对-key-value" class="headerlink" title="键值对(key_value)"></a>键值对(key_value)</h4><p><strong>环境变量是一个键值对结构</strong></p><blockquote><p>键：变量名</p><p>值：变量内容</p></blockquote><h5 id="和环境变量相关的命令"><a href="#和环境变量相关的命令" class="headerlink" title="和环境变量相关的命令"></a>和环境变量相关的命令</h5><blockquote><ol><li>echo: 显示某个环境变量值［重点］</li><li>export: 设置一个新的环境变量［重点］</li><li>env: 显示所有环境变量［重点］</li><li>unset: 清除环境变量</li><li>set: 显示本地定义的shell变量和环境变量</li></ol></blockquote><p><strong>Linux 上查看键值对命令:env</strong></p><blockquote><p>env : 查看系统上所有的环境变量</p><p>echo $ (环境变量名)  查看某个环境变量</p><p>export  修改环境变量，对于PATH 修改一般只是进行追加，不会把原来内容(路径)去掉</p><p><strong>可以通过重启终端来恢复PATH</strong></p><p><strong>PATH：shell中敲下的指令，去哪些目录中查找对应的可执行程序</strong></p><p>修改这个文件 ~ /.  bashrc 能够让环境变量持久生效</p></blockquote><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g2uwedpisyj30lt06nwg6.jpg" alt></p><h5 id="mian函数的参数"><a href="#mian函数的参数" class="headerlink" title="mian函数的参数"></a>mian函数的参数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc <span class="comment">/*命令行参数个数*/</span> ,<span class="keyword">char</span>* argv[]<span class="comment">/*命令行参数命令*/</span> )</span></span></span><br><span class="line"><span class="function"><span class="comment">//没参数</span></span></span><br><span class="line"><span class="function"><span class="comment">//int argc,char* argv[] </span></span></span><br><span class="line"><span class="function"><span class="comment">//int argc,char* argv[],char* env[] （env 数组的结束标志 NULL）</span></span></span><br></pre></td></tr></table></figure><h5 id="程序地址空间"><a href="#程序地址空间" class="headerlink" title="程序地址空间"></a>程序地址空间</h5><p><strong>栈</strong></p><blockquote><p>保存局部变量</p><p>在(centors 上大小约为8M)</p><p>栈的大小可以配置(要看平台)</p><p>如果是小对象，并且需要频繁创建和销毁，推荐在栈上分配栈上空间内存更高效</p></blockquote><p><strong>堆</strong></p><blockquote><p>动态申请的空间</p><p>如果是大对象，必须在堆上分配</p><p>malloc/new 申请空间</p></blockquote><p><strong>数据段</strong></p><blockquote><p>全局变量/静态变量</p></blockquote><p><strong>代码段</strong></p><blockquote><p>存放二进制代码/字符串的字面常量</p></blockquote><p><strong>内存池</strong></p><blockquote><p>需要比较大的内存又需要频繁的申请和释放的就用内存池比较好</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux进程的概念&quot;&gt;&lt;a href=&quot;#Linux进程的概念&quot; class=&quot;headerlink&quot; title=&quot;Linux进程的概念&quot;&gt;&lt;/a&gt;Linux进程的概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.冯诺依曼体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 操作系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 主要：僵尸进程&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://jack-wang128801.github.io/categories/Linux/"/>
    
    
      <category term="系统编程" scheme="https://jack-wang128801.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="https://jack-wang128801.github.io/2019/04/23/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>https://jack-wang128801.github.io/2019/04/23/Linux基础/</id>
    <published>2019-04-23T10:02:26.000Z</published>
    <updated>2019-05-05T15:02:25.875Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：Linux-的基本指令"><a href="#一：Linux-的基本指令" class="headerlink" title="一：Linux 的基本指令"></a>一：Linux 的基本指令</h3><a id="more"></a><p><strong>1.Linux 的基本指令和开发环境(操作方式：命令行操作)</strong></p><p><strong>2.Linux 系统编程</strong></p><p><strong>3. Linux网络编程</strong></p><h4 id="Linux-的简介"><a href="#Linux-的简介" class="headerlink" title="Linux 的简介"></a>Linux 的简介</h4><blockquote><p>Linux是 一个 操作系统内核(操作系统=内核+一组配套的应用程序)</p><p>内核来负责对于软件资源和硬件设备的管理</p><p>我们使用的是Centos 操作系统(内核为Linux)</p><p>Android   (内核也为LInux),Ubuntu</p><p>Redhat    (大部分公司中使用的发行版)</p></blockquote><p><strong>搭建Linux环境需要拷贝那些内容</strong></p><blockquote><p>1.安装 Vmware</p><p>​          Linux 可以直接安装到物理电脑上,操作起来不方便</p><p>2.拷贝Centos 镜像</p><p>3.安装 Xshell   (远程终端工具,依赖网络登陆)    远程终端工具。</p></blockquote><p><strong>Unix 高级环境编程 ， Unix 网络编程</strong></p><h4 id="学习Linux-的原因"><a href="#学习Linux-的原因" class="headerlink" title="学习Linux 的原因"></a>学习Linux 的原因</h4><p><strong>全世界市场份额最高的操作系统，任何一个程序猿都会用的操作系统</strong></p><blockquote><p> 1.移动端领域(安卓)</p><p>2.服务器领域(90% 的服务器使用Linux)3</p><p>3.嵌入式领域</p><p>4.桌面领域(Linux 在桌面领域表现不佳)</p></blockquote><h4 id="怎么学Linux"><a href="#怎么学Linux" class="headerlink" title="怎么学Linux"></a>怎么学Linux</h4><blockquote><p>敲代码</p><p>Linux难度远高于c/c++、数据结构</p><p>花时间 = 理论(理论+读书海报的管家年书籍) + 自己总结博客 + 多看其他相关资料 )+ 实践(多敲相关代码)</p></blockquote><h4 id="Linux-基本操作"><a href="#Linux-基本操作" class="headerlink" title="Linux 基本操作"></a>Linux 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls(list):相当于windows上的文件资源管理器</span><br><span class="line">ls /  </span><br><span class="line">ls  / xxx （进入根目录下的 xxx 目录）</span><br><span class="line">ls -l &lt;==&gt; ll (一种更详细的显示文件信息)</span><br><span class="line">Tab 键快速完成补全，</span><br><span class="line">快速按两下Tab显示改目录下所有可能的情况</span><br></pre></td></tr></table></figure><blockquote><p>在Linux终端和 shell中复制与粘贴不能用 Ctrl +c y与  Ctrl+v</p><p>要用Ctrl+Insert 和Shift +Insert 来完成复制与粘贴</p><p>ls / 进入当前机器的根目录(/: 根目录)</p><p>ll 的结果的第一个字母为 - 表示不同文件，为 d 表示为目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><blockquote><p>命令用途： 查看Linux机器 的 IP 地址</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear/Ctrl + l</span><br></pre></td></tr></table></figure><blockquote><p>命令作用：清屏</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><blockquote><p>查看当前目录的路径</p><p>/home/jack 是一登陆主机就进入的默认目录，这个目录就叫做jack用户的home 目录  </p><p>“~”  表示home目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd (change  )</span><br></pre></td></tr></table></figure><blockquote><p>修改当前目录 </p><p>绝对路径： /home/jack  以/开头的</p><p>相对路径： 从当前目录出发经历若干个结点到达最终目录 以. /..开头</p><p>其中  “ . “ 表示当前目录   “..”  表示当前目录的上级目录</p></blockquote><h5 id="cd-总结"><a href="#cd-总结" class="headerlink" title="cd 总结"></a>cd 总结</h5><blockquote><p>cd .. : 返回上级目录 </p><p>cd /home/litao/linux/ : 绝对路径</p><p>cd ../day02/ : 相对路径 </p><p>cd ~：进入用户家目录(cd  啥都不加也是同样的效果)</p><p>cd -：返回最近访问目录(完成两个目录之间的快速来回切换)</p><p>cd .. /x ：返回 上级目录并且进入到与当前目录同级的x 目录下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+c</span><br></pre></td></tr></table></figure><blockquote><p>命令用途： 有特的功能，终止当前程序，或者重新输入一个命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch</span><br></pre></td></tr></table></figure><blockquote><p>命令用途： 创建一个新的文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo</span><br></pre></td></tr></table></figure><blockquote><p>命令用途： 写文件</p></blockquote><h5 id="echo总结"><a href="#echo总结" class="headerlink" title="echo总结"></a>echo总结</h5><blockquote><p> echo “hello”   //显示到屏幕上，输出一个字符串</p><p>echo “hello” &gt; a.txt            把字符串写道文件中</p><p>向文件 a.txt中写入内容 “hello”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat</span><br></pre></td></tr></table></figure><blockquote><p>命令用途： 查看文件内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir</span><br></pre></td></tr></table></figure><blockquote><p>命令用途：创建目录</p></blockquote><h5 id="rm-的相关操作命令"><a href="#rm-的相关操作命令" class="headerlink" title="rm 的相关操作命令"></a>rm 的相关操作命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  bd.txt</span><br></pre></td></tr></table></figure><blockquote><p>删出 bd.txt 文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r bd</span><br></pre></td></tr></table></figure><blockquote><p>删除 bd 目录（递归删除）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r -i bd</span><br></pre></td></tr></table></figure><blockquote><p>不仅递归删除而且提示你是否要删除文件/目录(先删除目录中的文件，在删除指定的目录)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf bd</span><br></pre></td></tr></table></figure><blockquote><p>彻底删除</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><blockquote><p>切换到   <strong>root </strong>  用户(管理员用户)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install XXXX</span><br></pre></td></tr></table></figure><blockquote><p>安装一个XXX程序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure><blockquote><p>检查网络的联通状态</p></blockquote><p><strong>git</strong></p><blockquote><p>1.代码被喵星人吃掉的问题</p><p>2.产品经理被程序猿打死的问题</p><p>3.程序猿之间的互殴问题</p></blockquote><h5 id="mv的使用"><a href="#mv的使用" class="headerlink" title="mv的使用"></a>mv的使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv(move)</span><br></pre></td></tr></table></figure><blockquote><p>移动文件/目录，也能重命名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move 1.txt b</span><br></pre></td></tr></table></figure><blockquote><p>移动1.txt 文件 到 b 目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv a/2.txt c</span><br></pre></td></tr></table></figure><blockquote><p>将a  目录下的 2.txt 文件移动到 c目录中  (此时用户在a,c目录的上级目录中)</p></blockquote><h5 id="cp的用法"><a href="#cp的用法" class="headerlink" title="cp的用法"></a>cp的用法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp</span><br></pre></td></tr></table></figure><blockquote><p>拷贝文件/目录    </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp   -r</span><br></pre></td></tr></table></figure><blockquote><p>拷贝目录(递归式的拷贝)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp xxx ../ x</span><br></pre></td></tr></table></figure><blockquote><p>将当前目录下的xxx文件复制到与当前目录同级的x目录下 </p></blockquote><h5 id="man的用法"><a href="#man的用法" class="headerlink" title="man的用法"></a>man的用法</h5><p><strong>man：</strong>能够查看命令的使用方法，</p><blockquote><p>可以使用 k/向上键    向上翻屏</p><p>使用         j/向下键     向下翻屏</p><p>按  q    退出man</p></blockquote><h5 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h5><blockquote><p>使用less可以打开一个比较大的文件</p><p>less可以打开大文件效率很高，尤其是几个G大小的文件</p><p><strong>less在打开文件的时候，只把一小部分数据加载到内存中二大部分其他的编辑器都是直接吧整个文件都加载,而大部分其他的编辑器都是直接把整个文件都加载(延时加载/懒加载)</strong></p></blockquote><h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><p><strong>用途：查看文件的前几行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 10 yum.conf         #只看yum.conf文档的前10行</span><br></pre></td></tr></table></figure><blockquote><p>查看文档的前几行</p></blockquote><h5 id="tail的用途"><a href="#tail的用途" class="headerlink" title="tail的用途"></a>tail的用途</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10 yum.conf         #只看yum.conf文档的后10行</span><br></pre></td></tr></table></figure><p><strong>命令用途：只看yum.conf文档的后10行</strong></p><h5 id="date-获取当前时间"><a href="#date-获取当前时间" class="headerlink" title="date:获取当前时间"></a>date:获取当前时间</h5><blockquote><p>1.获取到任意格式化的时间。</p><p>2.格式化时间和时间戳的换算。</p><p>srand()  设置随机种子</p><p>使用格式:</p><p>rand()     </p><p>date  +%s                   获取到当前时间戳</p><p>date -d@[时间戳]      将时间戳转换成当前时间</p><p><strong>时间戳:当前时间与1970年1月1号0时0分0秒时刻的秒数差</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +&quot;%Y-%m-%d %H:%M:%S&quot;</span><br></pre></td></tr></table></figure><blockquote><p>获取当前的时间</p></blockquote><h5 id="与操作系统无关的数据类型写法"><a href="#与操作系统无关的数据类型写法" class="headerlink" title="与操作系统无关的数据类型写法"></a>与操作系统无关的数据类型写法</h5><blockquote><h6 id="头文件-：-include-lt-stdint-h-gt"><a href="#头文件-：-include-lt-stdint-h-gt" class="headerlink" title="头文件 ： #include&lt;stdint.h&gt;"></a>头文件 ： #include&lt;stdint.h&gt;</h6></blockquote><blockquote><p>int8_t</p><p>int16_t</p><p>int32_t</p><p>int 64_t</p><p><strong>这种类型的数字在任何平台下它的大小是固定的</strong></p></blockquote><p><strong>开始时间是  b</strong></p><blockquote><p>计算一段程序运算时间</p><p>结束时间是  a</p><p>a - b&lt; 0 时</p><p><strong>时间在出现闰秒的情况下可能为负，所以记录时间要用有符号数</strong></p></blockquote><h5 id="Cal-指令"><a href="#Cal-指令" class="headerlink" title="Cal 指令"></a>Cal 指令</h5><blockquote><p>日历的调用</p></blockquote><h5 id="find-name-按照文件名字查找文件"><a href="#find-name-按照文件名字查找文件" class="headerlink" title="find -name (按照文件名字查找文件 )"></a>find -name (按照文件名字查找文件 )</h5><blockquote><p>“*” 表示通配符，代表着任意多个字符，</p><p>大部分Linux 命令都支持统配符</p></blockquote><h5 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩/解压缩"></a>压缩/解压缩</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip 1.txt.zip</span><br></pre></td></tr></table></figure><blockquote><p>将1.txt文件压缩生成1.txt.zip 压缩包 </p><p>zip a.zip   a/* -r   将a 目录递归压缩</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip  1.txt.zip</span><br></pre></td></tr></table></figure><blockquote><p>将  1.txt.zip  解压</p></blockquote><h4 id="shell（普通的应用程序）"><a href="#shell（普通的应用程序）" class="headerlink" title="shell（普通的应用程序）"></a>shell（普通的应用程序）</h4><blockquote><p>shell 可以理解为用户和操作系统之间的桥梁</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure><blockquote><p>shell 是一个统称，当前系统上默认的shell 程序叫做 bash</p><p>bash这样的程序是使用最广泛的Linux Shell 程序</p></blockquote><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><blockquote><p>读： r</p><p>写： w</p><p>执行： x    (./xxx)</p><p>任何一个文件具体的权限，针对不同的用户是不一样的。</p><p>第一组rwx 表示的是文件的拥有者的权限</p><p>第二组rwx 表示的是和文件拥有者同组的用户的权限</p><p>第三组rwx 表示的是其他用户的权限</p></blockquote><blockquote><p>d：文件夹<br>-：普通文件<br>l：软链接（类似Windows的快捷方式）<br>b：块设备文件（例如硬盘、光驱等）<br>p：管道文件<br>c：字符设备文件（例如屏幕等串口设备）<br>s：套接口文件</p></blockquote><p><strong>在Linux中其实还有一个特殊的用户，凌驾于权限体系之上的–&gt;root</strong></p><h5 id="chmod-指令"><a href="#chmod-指令" class="headerlink" title="chmod 指令"></a>chmod 指令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod</span><br></pre></td></tr></table></figure><blockquote><p>chmode   -r xxx 去掉xxx文件的读权限</p><p>chmod   +r  xxxx 增加xxx文件的读权限</p><p>chmod u-r xxx 只处理文件拥有着的写权限</p><p>chmod u+r xxx 只处理文件拥有者的写权限</p><p>chmod    g-r     操作同组用户的权限</p><p>chmod    o-r     操作其他用户的权限</p><p>chmod   [三位八进制的数字]   修改文件权限</p><p>chmod   [9位二进制的数字]   修改文件权限</p><p>​    二进制的 000 110 100</p><p>​    八进制的     0     6    4  </p><p><strong>所谓的执行权限是一个程序能执行的必要条件，但不是充要条件</strong></p><p><strong>文件必须要满足系统可执行的格式要求文件才能够执行</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf a/       //删除a 目录</span><br><span class="line"></span><br><span class="line">rm -rf a /     //删除a文件 并且删除了根目录</span><br></pre></td></tr></table></figure><h5 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis xxx</span><br></pre></td></tr></table></figure><blockquote><p>能够找到某个指令xxx对应的可执行程序路径</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz</span><br></pre></td></tr></table></figure><blockquote><p><strong>把linux 上的文件发送到 Windows上</strong></p><p><strong>Windows上的文件弄到Linux 上只需要拖拽到Linux上即可(Xshell上的功能）</strong></p><p><strong>不同平台上的可执行程序它们的格式都是不一样的，不可以混着执行</strong></p></blockquote><h5 id="对于普通文件"><a href="#对于普通文件" class="headerlink" title="对于普通文件"></a>对于普通文件</h5><blockquote><p>1.读意味着能够查看文件的内容</p><p>2.写意味着能够修改文件内容</p><p>3.执行意味着能够运行程序</p></blockquote><h5 id="对于目录文件来说"><a href="#对于目录文件来说" class="headerlink" title="对于目录文件来说"></a>对于目录文件来说</h5><blockquote><p>1.读意味着能够查看目录中包含了那些文件和目录</p><p>2.写意味着能够修改目录中包含的内容(新增/删除文件)(-w 就不能在目录中创建文件或者目录)</p><p>3.执行意味着能够进入到目录中(cd)(- x 就不能进入到目录中)</p></blockquote><p><strong>只要用户拥有了目录的写权限，不管用户能否具有文件的读写权限，都能删除文件</strong></p><p><strong>粘滞位 ： chmod +t</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一：Linux-的基本指令&quot;&gt;&lt;a href=&quot;#一：Linux-的基本指令&quot; class=&quot;headerlink&quot; title=&quot;一：Linux 的基本指令&quot;&gt;&lt;/a&gt;一：Linux 的基本指令&lt;/h3&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://jack-wang128801.github.io/categories/Linux/"/>
    
    
      <category term="基本指令" scheme="https://jack-wang128801.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux下.c文件与.cpp文件的编辑和运行命令</title>
    <link href="https://jack-wang128801.github.io/2019/04/22/Linux%E4%B8%8B-c%E6%96%87%E4%BB%B6%E4%B8%8E-cpp%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%BE%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <id>https://jack-wang128801.github.io/2019/04/22/Linux下-c文件与-cpp文件的编辑和运行命令/</id>
    <published>2019-04-22T12:28:40.000Z</published>
    <updated>2019-05-05T15:02:19.005Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux平台下-c文件的编辑和运行命令"><a href="#Linux平台下-c文件的编辑和运行命令" class="headerlink" title="Linux平台下.c文件的编辑和运行命令"></a>Linux平台下.c文件的编辑和运行命令</h4><a id="more"></a><p><strong>在 Linux 平台下我是用vim文本编辑器编写代码的</strong></p><p><strong>一：在Linux环境下编辑、编译并执行一个 xxx.c 文件步骤</strong></p><p><strong>1.首先要创建一个test.c文件</strong></p><blockquote><p>输入命令:   touch test.c</p></blockquote><p><strong>2. 开始写代码</strong></p><blockquote><p>输入命令 : vim test.c (前提是你已经安装了vim文本编辑器)</p><p>进入编辑器后：按 英文字母”i”进入编辑模式</p></blockquote><p><strong>3. 退出文本文档</strong></p><blockquote><p>按一下Esc ，然后按出”:”冒号</p><p>接着输入对应字母</p><p><strong>输入字母 q 表示退出(既不保存你输入的代码直接退出)</strong></p><p><strong>输入字母 w 和字母 q 表示保存并且退出</strong></p></blockquote><p><strong>4. 编译代码</strong></p><blockquote><p>输入命令: gcc test.c</p><p>完成对test.c 文件的编译工作</p></blockquote><p><strong>5. 执行代码</strong></p><blockquote><p>输入命令： ./a.out test.c </p><p>即可执行你所写的test.c 文件，并输出对应结果</p></blockquote><p><strong>二：在 Linux 环境下编辑、编译并执行一个 xxx.cpp 文件步骤</strong></p><p><strong>1..首先要创建一个test.cpp文件</strong></p><blockquote><p>输入命令:   touch test.cpp</p></blockquote><p><strong>2. 开始写代码</strong></p><blockquote><p>输入命令 : vim test.cpp (前提是你已经安装了vim文本编辑器)</p><p>进入编辑器后：输入英文字母”i”进入编辑模式</p></blockquote><p><strong>3. 退出文本文档</strong></p><blockquote><p>按一下Esc ，然后按出”:”冒号</p><p>接着输入对应字母</p><p><strong>输入字母 q 表示退出(既不保存你输入的代码直接退出)</strong></p><p><strong>输入字母 w 和字母 q 表示保存并且退出</strong></p></blockquote><p><strong>4. 编译代码</strong></p><blockquote><p>输入命令: g++ test.cpp</p><p>完成对 test.cpp 文件的编译工作</p></blockquote><p><strong>5. 执行代码</strong></p><blockquote><p>输入命令： ./a.out test.cpp </p><p>即可执行你所写的test.cpp 文件，并输出对应结果</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Linux平台下-c文件的编辑和运行命令&quot;&gt;&lt;a href=&quot;#Linux平台下-c文件的编辑和运行命令&quot; class=&quot;headerlink&quot; title=&quot;Linux平台下.c文件的编辑和运行命令&quot;&gt;&lt;/a&gt;Linux平台下.c文件的编辑和运行命令&lt;/h4&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://jack-wang128801.github.io/categories/Linux/"/>
    
    
      <category term="Linux下.c文件与.cpp文件的编辑和运行命令" scheme="https://jack-wang128801.github.io/tags/Linux%E4%B8%8B-c%E6%96%87%E4%BB%B6%E4%B8%8E-cpp%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%BE%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="https://jack-wang128801.github.io/2019/04/20/%E5%A4%9A%E6%80%81/"/>
    <id>https://jack-wang128801.github.io/2019/04/20/多态/</id>
    <published>2019-04-20T08:30:41.000Z</published>
    <updated>2019-05-05T15:03:48.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><a id="more"></a><h4 id="一：多态的简介"><a href="#一：多态的简介" class="headerlink" title="一：多态的简介"></a>一：多态的简介</h4><h5 id="1-多态的概念"><a href="#1-多态的概念" class="headerlink" title="1.多态的概念"></a>1.多态的概念</h5><p><strong>复习</strong></p><blockquote><p>多态：不同对象 执行同一种行为的多种表现形态(或者执行同一种行为产生的不同结果)</p><p>0.前提是继承</p><p>1.调用函数的对象必须是引用或指针</p><p>2.被调用的函数必须为虚函数，且在子类当中被重写 </p><p>非多态看类型：</p><p>多态看对象：</p></blockquote><p><strong>函数重写：</strong> 函数分别存在于子类和父类，函数名，参数，返回值都相同(可以是协变)</p><p><strong>协变：</strong> 返回值的类型可以是构造父子关系的指针或者引用</p><p><strong>非多态</strong></p><blockquote><p>汇编代码： 语句简单</p></blockquote><p><strong>多态</strong></p><blockquote></blockquote><p><strong>如何实现多态</strong></p><blockquote><p>多态的对象模型：只要类中有虚函数，对象 模型中就存放了一个虚标指针，虚表指针指向虚表，虚表本质上为函数指针数组，虚表在vs下存在代码段、</p><p>1.本质上是通过虚表实现：程序在运行的 时候，根据引用或者指针指向的对象，访问对象模型中虚表指针，获取虚表中对应位置的函数指针，</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp多态" scheme="https://jack-wang128801.github.io/tags/Cpp%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="https://jack-wang128801.github.io/2019/04/18/%E7%BB%A7%E6%89%BF/"/>
    <id>https://jack-wang128801.github.io/2019/04/18/继承/</id>
    <published>2019-04-18T09:26:16.000Z</published>
    <updated>2019-05-05T15:03:13.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><a id="more"></a><h4 id="1-对继承的理解"><a href="#1-对继承的理解" class="headerlink" title="1. 对继承的理解"></a>1. 对继承的理解</h4><p><strong>a.继承的理解：</strong> class(类)级别的代码复用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name:"</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">string</span> _name = <span class="string">"peter"</span>; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">int</span> _age = <span class="number">18</span>; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person  <span class="comment">//继承了Person 的内容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> _stuid= <span class="number">4170903</span>; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> _jobid=<span class="number">147632</span>; <span class="comment">// 工号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line">Teacher t;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>监视结果</strong></p><p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g27uin55epj30eg0adwf5.jpg" alt></p><blockquote><p>由上图可以看到Student和Teacher类中多出了自己内部并没有定义过的Person类中的内容。他们从Person类中  <strong>继承</strong> 了Person类中的内容。</p></blockquote><p><strong>继承的图例说明</strong></p><p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g27ww13nf1j30fo0a4q2x.jpg" alt></p><p><strong>注意：Student类中此时只有<strong>name,</strong>age__stuid三个变量，并没有Person这个内部类，Teacher类中也没有Person这个类</strong></p><p><strong>运行结果</strong></p><p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g27urs6g2gj30dw06sq31.jpg" alt></p><p><strong>继承的格式</strong></p><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g27ux3jq6hj30iq0a2q4n.jpg" alt></p><p><strong>b.继承关系和访问权限</strong></p><p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g27uzo1k8sj30mm06n3zu.jpg" alt></p><blockquote><p>1.继承方式和基类中的访问方式结合起来就有9种子类的访问方式，在子类中的访问方式取两者中权限最小的。</p><p>2.不管在子类中是如何继承的基类中的私有成员在子类中都是不可见的,但是它确实存在与子类中。</p><p>3.基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。</p><p>5.基类中的保护类型在子类中可以被访问，但是在子类之外定义的变量不可以访问。</p><p>6.使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过最好显示的写出继承方式</p><p>7.基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它</p></blockquote><blockquote><p>protected:在类外无法访问，但是在子类内部可以访问</p><p>private：在类外和子类中都无法访问</p><p>public继承：不改变基类成员在子类中的访问权限</p><p>protected继承：基类成员在子类中的最低访问权限为protected的</p><p>private继承：基类成员在子类中的最低访问权限为private的</p></blockquote><h4 id="2-基类和派生类对象赋值转换"><a href="#2-基类和派生类对象赋值转换" class="headerlink" title="2.基类和派生类对象赋值转换"></a>2.基类和派生类对象赋值转换</h4><p><strong>切片操作图示</strong></p><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g27wiawhu9j30kx08igmo.jpg" alt></p><p><strong>切片理解</strong></p><blockquote><p>1.派生类对象可以赋值给基类的对象 / 基类的指针 / 基类的引用。这里有个形象的说法叫切片或者切割。寓意把派生类的内容中将父类中的那部分切下来赋值给父类。</p><p>2.父类对象不能赋值给子类对象</p></blockquote><blockquote><p>父类指针只能看到和自己类型大小的空间,所以不能赋给子类指针<br>char<em> :一个字节<br>int </em> : 四个字节<br>子类对象的地址可以赋给父类的指针(父类指针可以在子类对象所占空间大小中只访问自己能访问到的大小)<br>指针类型决定访问的空间大小</p></blockquote><blockquote><p>子类可以赋值给父类引用：引用的底层就是指针<br>父类的指针不能赋给子类指针：可能会存在访问越界的风险(若子类中没有定义新的成员，则基类于与子类的大小相同就不存在访问越界的情况)</p></blockquote><blockquote><p>需要做强制类型转换：Student <em>ptr =(Studennt </em>) &p;</p><p>强转存在风险:若子类中定义了新的变量，强转父类指针类型就存在访问越界的风险。</p></blockquote><blockquote><p>int a=10;<br>float  b=1.5;<br>隐式类型转换：类型相似的变量可以进行相互赋值，通过隐式类型转换。</p></blockquote><h4 id="3-继承中的作用域"><a href="#3-继承中的作用域" class="headerlink" title="3.继承中的作用域"></a>3.继承中的作用域</h4><blockquote><ol><li>在继承体系中基类和派生类都有独立的作用域。</li><li>子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显示访问）</li><li>需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。</li><li>注意在实际中在继承体系里面最好不要定义同名的成员</li></ol></blockquote><p><strong>类的成员变量的隐藏</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">string</span> _name = <span class="string">"小李子"</span>; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">int</span> _num = <span class="number">111</span>; <span class="comment">// 身份证号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 姓名:"</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 身份证号:"</span> &lt;&lt; Person::_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 学号:"</span> &lt;&lt; _num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> _num = <span class="number">999</span>; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student s1;</span><br><span class="line">s1.Print();</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当定义类只尽量将变量名取的不一样</span></span><br><span class="line"><span class="comment">//子类与父类中定义的变量名相同时，子类变量会将父类变量隐藏</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> _name = <span class="string">"小李子"</span>; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">int</span> _num = <span class="number">111</span>; <span class="comment">// 身份证号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 姓名:"</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 身份证号:"</span> &lt;&lt; Person::_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 学号:"</span> &lt;&lt; _num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> _num = <span class="number">999</span>; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student s1;</span><br><span class="line">s1.Print();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s._num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Person::_num &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//可以通过这种方法访问父类中的对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p._num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Student::_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类中函数的同名隐藏</strong></p><p><strong>条件：子类中的函数与父类中的函数名字相同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数的隐藏</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A::fun();<span class="comment">//指明调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"func(int i)-&gt;"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">b.fun(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载：函数在同以作用域，函数名相同，参数不同</span></span><br><span class="line"><span class="comment">//重定义：重定义/隐藏：子类函数和父类函数名相同就会构成隐藏</span></span><br><span class="line"><span class="comment">//子类会把父类同名的函数隐藏掉</span></span><br></pre></td></tr></table></figure><h4 id="4-派生类的默认成员函数"><a href="#4-派生类的默认成员函数" class="headerlink" title="4.派生类的默认成员函数"></a>4.派生类的默认成员函数</h4><blockquote><ul><li>6个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类中，这几个成员函数是如何生成的呢？</li><li>a.派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</li><li>b.派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化</li><li>c.派生类的operator=必须要调用基类的operator=完成基类的复制。</li><li>d.派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</li><li>e.派生类对象初始化先调用基类构造再调派生类构造。</li><li>f.派生类对象析构清理先调用派生类析构再调基类的析构</li></ul></blockquote><p><img src="https://wx4.sinaimg.cn/mw690/0071OE7sly1g27yqubukqj30mm07omyw.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"peter"</span>)</span><br><span class="line">: _name(name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">: _name(p._name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Person(const Person&amp; p)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Person operator=(const Person&amp; p)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;p)</span><br><span class="line">_name = p._name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">string</span> _name; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//完成父类对象的初始化，子类的构造函数先调用基类的构造函数，</span></span><br><span class="line"><span class="comment">//再执行子类的构造函数</span></span><br><span class="line"><span class="comment">//必须先调用父类的构造函数和拷贝构造进行初始化</span></span><br><span class="line">Student(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> num)</span><br><span class="line">: Person(name)</span><br><span class="line"></span><br><span class="line">, _num(num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Student()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果子类不显示的调用父类的拷贝构造，则调用父类的默认构造函数</span></span><br><span class="line"><span class="comment">//如果子类显示的调用父类类的拷贝构造，就不会再去调用父类的默认构造</span></span><br><span class="line">Student(<span class="keyword">const</span> Student&amp; s) </span><br><span class="line"><span class="comment">//(Student *this,const Student &amp;s)还发生了指针的欺骗。</span></span><br><span class="line">: Person(s)<span class="comment">//此处是一个切片的操作，调用父类的拷贝构造</span></span><br><span class="line">, _num(s._num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Student(const Student&amp; s)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类的成员变量可以直接在子类的赋值运算符重载函数长中直接赋值</span></span><br><span class="line"><span class="comment">//如果是编译器默认生成的子类赋值运算符重载函数，会调用父类的</span></span><br><span class="line"><span class="comment">//赋值运算符重载函数进行赋值</span></span><br><span class="line">Student&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Student&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Student&amp; operator= (const Student&amp; s)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//建议直接显示调用父类的赋值运算符重载函数，代码复用</span></span><br><span class="line"><span class="comment">//operator =(s);不可以这样写</span></span><br><span class="line">Person::<span class="keyword">operator</span> =(s);<span class="comment">//此处调用的this指针为子类对象的this指针</span></span><br><span class="line">_num = s._num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//若if中没有显示的写出父类的赋值运算符重载的话，</span></span><br><span class="line"><span class="comment">//子类中不会调用父类的赋值运算符重载</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数:不允许显示调用父类的析构函数</span></span><br><span class="line">~Student()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//~Person();坑:同名隐藏，编译器底层对析构函数的名字做了</span></span><br><span class="line"><span class="comment">//修改为了使用多条调不动</span></span><br><span class="line"><span class="comment">//Person::~Person(); //可以调动</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> _num; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"jack"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">s3</span><span class="params">(<span class="string">"rose"</span>, <span class="number">17</span>)</span></span>;</span><br><span class="line">s1 = s3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造顺序：先是基类构造————》派生类构造 </span></span><br><span class="line"><span class="comment">//析构顺序：派生类析构--》基类析构</span></span><br><span class="line"><span class="comment">//原因为函数栈帧的排列顺序</span></span><br></pre></td></tr></table></figure><p><strong>常见面试题：实现一个不能被继承的类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> NonInherit <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> NonInherit();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> NonInherit()</span><br><span class="line"> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// C++11给出了新的关键字final禁止继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span> <span class="title">final</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>复习</strong></p><blockquote><p><strong>继承：</strong>   类级别的代码复用</p><p> <strong>继承方式：</strong> public,protectd,private</p><p>基类成员在子类中的访问权限：min(在基类中的限定符，继承方式)</p><p>​                                                              基类的私有成员在子类中不可见</p></blockquote><blockquote><p><strong>protected</strong>    ：在基类和子类中可见，在类外不可见<br> <strong>private</strong>    :只在基类中可见，其他地方不可见<br>  <strong>类域：</strong>   基类和子类的作用域独立<br><strong>成员隐藏</strong><br>       1.成员变量隐藏：子类相同名称的成员隐藏基类同名的成员，通过基类作用域访问基类成员变量<br>        2.成员函数隐藏：函数名相同既构成隐藏.同名函数会隐藏基类函数，和参数无关</p></blockquote><blockquote><p><strong>函数重载：</strong>    在同一个作用域，函数名相同，参数不同。</p><p><strong>函数隐藏：</strong>    函数一个在子类，一个在父类，函数名相同。</p></blockquote><blockquote><p><strong>子类的6大成员函数</strong><br><strong>构造：</strong>     1.默认生成的，首先会自动调用父类的默认构造函数，再调用自己的构造函数<br>                 2.显示定义：如果父类有默认构造，可以不显示调用，如果父类无默认构造函数，需要在初始化列表显示调用。</p></blockquote><blockquote><p><strong>拷贝构造：</strong>     1.默认构成的，编译器会自动调用父类的拷贝构造</p><p>​                         2.显示定义：如果不显式调用父类拷贝构造，编译器会调用父类的默认构造</p></blockquote><blockquote><ul><li><strong>赋值运算符：</strong>    1.默认生成的，编译器会自动调用父类的赋值运算符重载函数</li><li>​                            2.显示定义：如果不显示的调用父类的赋值运算符重载函数，编译器不会调用父类的任何成员函数</li></ul></blockquote><blockquote><ul><li><strong>析构：</strong> 1.默认生成：先执行自己的析构函数，编译器再调用父类的析构</li><li>​             2.显示定义：不需要显示调用父类的析构，编译器会自动调用，注意父类析构和子类析构构成函数隐藏。</li><li><strong>取地址：</strong>使用编译器默认生成的即可</li></ul></blockquote><blockquote><p><strong>父类子类对象之间的赋值：</strong>  切片操作</p><p>​     1.子类对象可以赋值给父类对象，指针，引用</p><p>​     2.父类对象不能赋值给子类对象，可能会造成访问异常</p><p>​     3.父类指针在特定条件下可以赋值给子了指针，如果父类指针本身指向的为子类对象的空间，赋值时是安全的，否则不安全 ，会导致访问异常。</p></blockquote><p><strong>友元关系不能继承</strong></p><blockquote><p>继承体系 中的静态</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="c++ 进阶 继承" scheme="https://jack-wang128801.github.io/tags/c-%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://jack-wang128801.github.io/2019/04/14/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://jack-wang128801.github.io/2019/04/14/二叉树/</id>
    <published>2019-04-13T16:14:30.000Z</published>
    <updated>2019-05-05T15:03:56.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><a id="more"></a><h4 id="一：二叉树的概述"><a href="#一：二叉树的概述" class="headerlink" title="一：二叉树的概述"></a>一：二叉树的概述</h4><h5 id="1-二叉树的概念"><a href="#1-二叉树的概念" class="headerlink" title="1.二叉树的概念"></a>1.二叉树的概念</h5><blockquote><p>一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵别称为左子树和右子树的二叉树组成</p></blockquote><h5 id="2-二叉树的特点："><a href="#2-二叉树的特点：" class="headerlink" title="2.二叉树的特点："></a>2.二叉树的特点：</h5><ol><li>每个结点最多有两棵子树，即二叉树不存在度大于2的结点。</li><li>二叉树的子树有左右之分，其子树的次序不能颠倒。</li></ol><h5 id="3-二叉树的几种形态"><a href="#3-二叉树的几种形态" class="headerlink" title="3.二叉树的几种形态"></a>3.二叉树的几种形态</h5><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g21gxhf3h6j30hl07gq3i.jpg" alt></p><h5 id="4-两种特殊的二叉树"><a href="#4-两种特殊的二叉树" class="headerlink" title="4.两种特殊的二叉树"></a>4.两种特殊的二叉树</h5><p><strong>4.1：满二叉树</strong></p><blockquote><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p></blockquote><p><strong>满二叉树的图例</strong></p><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g21h3ea5v4j308k06qq4j.jpg" alt></p><p><strong>满二叉树的特点</strong></p><blockquote><p>如果二叉树的高度为 h </p><p>则满二叉树的节点个数为 2^h - 1;</p><p>而除了最后一层外。剩余的节点个数为2 ^ (h-1) -1个</p><p>最后一层的节点个数为 2 ^ (h-1) -1个 </p><p><strong>特点</strong>：满二叉树的最后一层节点个数为其他层数的结点个数之和 - 1‘</p></blockquote><p><strong>4.2完全二叉树</strong></p><blockquote><p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 </p></blockquote><p><strong>完全二叉树的特点</strong></p><blockquote><p>已知:父亲节点的下标为[parent]</p><p>则其左孩子的结点下标为[left] = 2* [parent] + 1</p><p>其右孩子的下标为[right] = 2 * [parent] + 2</p><p>已知：左孩子或者右孩子的下标[child]</p><p>其双亲结点的下标为[parent] = ( [child] - 1 ) / 2(结果取整)</p></blockquote><p><strong>要注意的是满二叉树是一种特殊的完全二叉树</strong></p><p><strong>满二叉树与完全二叉树的联系与区别</strong></p><blockquote><p><strong>满二叉树一定是完全二叉树，但是完全二叉树并不一定是满二叉树 </strong></p></blockquote><p><strong>二叉树的重要特征</strong></p><blockquote><p>1.二叉树上第i层上至多有2^(i-1)个结点（i&gt;=1）</p><p>2.深度为h的二叉树至多有2^h - 1个结点</p><p>3.对于任意一颗二叉树，如果其叶子结点数为n，度为2 的结点数为n1,则n=n1+1;</p><p>4.具有n个结点的完全二叉树的深度为[log2 (n+1)]或者为[log2 n]+1(备注:此处的[]为取整，不是中括号)</p><p>5.</p></blockquote><h4 id="二叉树存储"><a href="#二叉树存储" class="headerlink" title="二叉树存储"></a>二叉树存储</h4><p> <strong>1.顺序存储</strong></p><blockquote><p>顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</p></blockquote><p><strong>2. 链式存储</strong></p><blockquote><p><strong>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 </strong></p></blockquote><h4 id="三：二叉树链式存储结构及实现"><a href="#三：二叉树链式存储结构及实现" class="headerlink" title="三：二叉树链式存储结构及实现"></a>三：二叉树链式存储结构及实现</h4><h5 id="1-二叉树的遍历"><a href="#1-二叉树的遍历" class="headerlink" title="1.二叉树的遍历"></a>1.二叉树的遍历</h5><p><strong>A:前序遍历</strong></p><blockquote><p>前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前</p></blockquote><p><strong>B:中序遍历</strong></p><blockquote><p>中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。</p></blockquote><p><strong>C:后序遍历</strong></p><blockquote><p>后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。</p></blockquote><p><strong>三种遍历的使用</strong></p><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g21yczmt1sj30mw09swhy.jpg" alt></p><p><strong>二叉树的层序遍历</strong></p><blockquote><p><strong>在遍历二叉树时按照层的方式遍历</strong></p></blockquote><h4 id="二叉树的代码实现模块"><a href="#二叉树的代码实现模块" class="headerlink" title="二叉树的代码实现模块"></a>二叉树的代码实现模块</h4><h5 id="1-二叉树结构体的定义"><a href="#1-二叉树结构体的定义" class="headerlink" title="1.二叉树结构体的定义"></a>1.二叉树结构体的定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTDdataType int</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTDataType _data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* _<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* _<span class="title">right</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"><span class="comment">//以左孩子右孩子的方式定义</span></span><br></pre></td></tr></table></figure><h5 id="2-二叉树的前序遍历"><a href="#2-二叉树的前序遍历" class="headerlink" title="2.二叉树的前序遍历"></a>2.二叉树的前序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTreePrevOrder</span><span class="params">(BTNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;val);</span><br><span class="line">    BinaryTreePrevOrder(root-&gt;left);</span><br><span class="line">    BinaryTreePrevOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照递归的形式遍历二叉树的每一个结点</span></span><br></pre></td></tr></table></figure><h5 id="3-二叉树的中序遍历"><a href="#3-二叉树的中序遍历" class="headerlink" title="3.二叉树的中序遍历"></a>3.二叉树的中序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTreeInOrder</span><span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">BinaryTreeInOrder(root-&gt;left);<span class="comment">// 左子树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;val);<span class="comment">// 根</span></span><br><span class="line">BinaryTreeInOrder(root-&gt;right);<span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-二叉树的后序遍历"><a href="#4-二叉树的后序遍历" class="headerlink" title="4.二叉树的后序遍历"></a>4.二叉树的后序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTreePostOrder</span><span class="params">(BTNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    BinaryTreePostOrder(root-&gt;left);</span><br><span class="line">    BinaryTreePostOrder(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-二叉树的层序遍历"><a href="#5-二叉树的层序遍历" class="headerlink" title="5.二叉树的层序遍历"></a>5.二叉树的层序遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode *&gt;qu;</span><br><span class="line"></span><br><span class="line">qu.push(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!qu.empty()) &#123;</span><br><span class="line">TreeNode *front = qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, front-&gt;val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">qu.push(front-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">qu.push(front-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此算法是用c++语言实现的。</span></span><br><span class="line"><span class="comment">//队列存放结点的地址</span></span><br></pre></td></tr></table></figure><blockquote><p>总体思想：首先需要另外创建一个空的队列，在判断二叉树不为空树的情况下,先将二叉树的根节点入队，然后在根节点出队的时候将它的左右孩子放到队列中，下一次它的左右孩子又是它左右子树的根节点，依次放到队列中，然后出栈，直到队列为空。</p></blockquote><p><strong>总结</strong></p><p><strong>前序|中序|后序      深度优先    栈</strong></p><p><strong>层序     广度优先     队列</strong></p><h4 id="四-二叉树面试题"><a href="#四-二叉树面试题" class="headerlink" title="四:二叉树面试题"></a>四:二叉树面试题</h4><h5 id="1-判断两个二叉树是否相等"><a href="#1-判断两个二叉树是否相等" class="headerlink" title="1.判断两个二叉树是否相等"></a>1.判断两个二叉树是否相等</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line">bool isSameTree(struct TreeNode* p,struct TreeNode *q)；</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><blockquote><p>首先考虑到如果两棵树都为空，则两棵树是相等的；如果两者中的一个为空，另外一个不为空，则两棵树肯定不相等。若两者都不为空，则需要将两颗二叉树分别分成三部分：1.根结点，2.左子树，3.右子树。然后按照递归的思想一直递推下去。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用递归的思想，先判断根的情况，再判断左右子树的情况</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(struct TreeNode* p,struct TreeNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;_data==q-&gt;_data</span><br><span class="line">        &amp;&amp;isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp;isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-判断对称树"><a href="#2-判断对称树" class="headerlink" title="2.判断对称树"></a>2.判断对称树</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line">bool isMirror(struct TreeNode *p, struct TreeNode *q)；</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><blockquote><p>还是利用递推的思想,将所传的两个结点先进行检查。而后在确保两个结点的值相等的情况下，判断一个根节点的左孩子与另一个根结点的右孩子的情况继而判断这个根节点的右孩子和另外一个根节点的左孩子的情况。</p></blockquote><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g24tvyq65rj30cd066dfr.jpg" alt></p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(struct TreeNode *p, struct TreeNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;val==q-&gt;val</span><br><span class="line">        &amp;&amp;isMirror(p-&gt;left,q-&gt;right)</span><br><span class="line">        &amp;&amp;isMirrorq-&gt;left,p-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-判断一棵树是否为另外一棵树的子树"><a href="#3-判断一棵树是否为另外一棵树的子树" class="headerlink" title="3.判断一棵树是否为另外一棵树的子树"></a>3.判断一棵树是否为另外一棵树的子树</h5><p><strong>接口</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(struct TreeNode* root)</span></span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><blockquote><p>判断是否是子树<br>1）前序遍历(查找父树上节点的值和子树上结点的值相等的第一个节点，当所要查找的父树上结点的值和子树上根结点的值相等时再判断各自子树的情况)<br>2）判断两棵树是否相同<br>3）对于返回值的处理是难点</p></blockquote><p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g24ttrnpw0j30d30cg3yo.jpg" alt></p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当子树的根结点的值和父树上对应的值相等时，判断两者对应的子树是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(struct TreeNode* p, struct TreeNode* q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;val == q-&gt;val</span><br><span class="line">&amp;&amp; isSameTree(p-&gt;left, q-&gt;left)</span><br><span class="line">&amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历，在父树上找与子树根节点值相等的结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">preorderTraversal</span><span class="params">(struct TreeNode *root, struct TreeNode *t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;val == t-&gt;val &amp;&amp; isSameTree(root, t)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左子树</span></span><br><span class="line"><span class="keyword">bool</span> left = preorderTraversal(root-&gt;left, t);</span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右子树</span></span><br><span class="line"><span class="keyword">bool</span> right = preorderTraversal(root-&gt;right, t);</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该问题所对应的接口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(struct TreeNode* s, struct TreeNode* t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> preorderTraversal(s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-求一棵二叉树的最大深度"><a href="#4-求一棵二叉树的最大深度" class="headerlink" title="4.求一棵二叉树的最大深度"></a>4.求一棵二叉树的最大深度</h5><p><strong>接口</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)；</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><blockquote><p>拿到一颗二叉树</p></blockquote><p><img src="C:\Users\王世贤\AppData\Local\Temp\1555424148907.png" alt></p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">int</span> left= MaxDepth(root-&gt;left);</span><br><span class="line">   <span class="keyword">int</span> right=MaxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (left&gt;right?left:right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.判断平衡二叉树</strong></p><blockquote><p>判断依据：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。 </p></blockquote><p><strong>接口</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(struct TreeNode* root)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><blockquote><p>首先要判断所传的树是否为空树，是空树就为真，不是空树就对根节点的左右子树进行必要的判断。如果都满足则求出左右子树的高度，然后判断根结点对应的左右子树的高度差，并判断高度差满足的条件</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c语言版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(struct TreeNode *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = getHeight(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right = getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (left&gt;right?left:right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//处理左子树</span></span><br><span class="line"><span class="keyword">bool</span> is_left_balance = isBalanced(root-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (is_left_balance == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">//处理右子树</span></span><br><span class="line"><span class="keyword">bool</span> is_right_balance = isBalanced(root-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (is_right_balance == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//求左子树的高度</span></span><br><span class="line"><span class="keyword">int</span> left_height = getHeight(root-&gt;left);</span><br><span class="line">    <span class="comment">//求右子树的高度 </span></span><br><span class="line"><span class="keyword">int</span> right_height = getHeight(root-&gt;right);</span><br><span class="line"><span class="keyword">int</span> diff = left_height - right_height;</span><br><span class="line"><span class="keyword">if</span> (diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//处理左子树</span></span><br><span class="line"><span class="keyword">bool</span> is_left_balance = isBalanced(root-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (is_left_balance == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">//处理右子树</span></span><br><span class="line"><span class="keyword">bool</span> is_right_balance = isBalanced(root-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (is_right_balance == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//求左子树的高度</span></span><br><span class="line"><span class="keyword">int</span> left_height = getHeight(root-&gt;left);</span><br><span class="line">    <span class="comment">//求右子树的高度 </span></span><br><span class="line"><span class="keyword">int</span> right_height = getHeight(root-&gt;right);</span><br><span class="line"><span class="keyword">int</span> diff = left_height - right_height;</span><br><span class="line"><span class="keyword">if</span> (diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(struct TreeNode *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = getHeight(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right = getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (left&gt;right?left:right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="6-完全二叉树的判断"><a href="#6-完全二叉树的判断" class="headerlink" title="6.完全二叉树的判断"></a>6.完全二叉树的判断</h5><p><strong>判定依据</strong></p><blockquote><p>在层序遍历二叉树的过程中如果没有遍历完所有结点之前就遇到了空结点的话，就说明该树不是完全二叉树</p></blockquote><p><strong>解题思路</strong></p><blockquote><p>解题思路大致与层序遍历的相同，不同之处在于。判断二叉树的结点情况的时候两次判断了队列是否为空的情况，第一次遇到空结点就跳出循环，第二次判断队列是否为空</p></blockquote><p><strong>接口</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinaryTreeComplete</span><span class="params">(TreeNode* root)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinaryTreeComplete</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode *&gt;  qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        TreeNode *front=qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        <span class="keyword">if</span>(front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            qu.push(root-&gt;left);</span><br><span class="line">            qu.push(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查队列中是否还有其他元素</span></span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        TreeNode *node=qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五：二叉树的前序-中序-后序的非递归实现，自己用栈来实现"><a href="#五：二叉树的前序-中序-后序的非递归实现，自己用栈来实现" class="headerlink" title="五：二叉树的前序|中序|后序的非递归实现，自己用栈来实现"></a>五：二叉树的前序|中序|后序的非递归实现，自己用栈来实现</h4><blockquote><p>栈(用来存放结点地址)</p></blockquote><p><strong>前序的非递归实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversalNor</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TreeNode *cur = root;<span class="comment">// 遍历结点的指针</span></span><br><span class="line">TreeNode *top;<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line">TreeNode *last = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 第一次访问结点：cur</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, cur-&gt;val);</span><br><span class="line">st.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top = st.top();<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line">st.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (top-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 既是第二次访问，也是第三次访问</span></span><br><span class="line">cur = top-&gt;right;</span><br><span class="line">st.pop();</span><br><span class="line">last = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (top-&gt;right != last) &#123;</span><br><span class="line"><span class="comment">// 第二次访问</span></span><br><span class="line">cur = top-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 第三次访问</span></span><br><span class="line">st.pop();</span><br><span class="line">last = top;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversalNor2</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TreeNode *cur = root;<span class="comment">// 遍历结点的指针</span></span><br><span class="line">TreeNode *top;<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std:: 命名空间</span></span><br><span class="line"><span class="comment">// &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode *</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 第一次访问结点：cur</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, cur-&gt;val);</span><br><span class="line">st.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top = st.top();<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line">st.pop();</span><br><span class="line">cur = top-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversalNor</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TreeNode *cur = root;<span class="comment">// 遍历结点的指针</span></span><br><span class="line">TreeNode *top;<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line">TreeNode *last = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std:: 命名空间</span></span><br><span class="line"><span class="comment">// &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode *</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 第一次访问结点：cur</span></span><br><span class="line">st.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">top = st.top();<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line"><span class="keyword">if</span> (top-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 既是第二次访问，也是第三次访问</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">cur = top-&gt;right;</span><br><span class="line">st.pop();</span><br><span class="line">last = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (top-&gt;right != last) &#123;</span><br><span class="line"><span class="comment">// 第二次访问</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">cur = top-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 第三次访问</span></span><br><span class="line">st.pop();</span><br><span class="line">last = top;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversalNor2</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TreeNode *cur = root;<span class="comment">// 遍历结点的指针</span></span><br><span class="line">TreeNode *top;<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std:: 命名空间</span></span><br><span class="line"><span class="comment">// &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode *</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 第一次访问结点：cur</span></span><br><span class="line">st.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">top = st.top();<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line"><span class="comment">// 既是第二次访问，也是第三次访问</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">cur = top-&gt;right;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTraversalNor</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TreeNode *cur = root;<span class="comment">// 遍历结点的指针</span></span><br><span class="line">TreeNode *top;<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line">TreeNode *last = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std:: 命名空间</span></span><br><span class="line"><span class="comment">// &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode *</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 第一次访问结点：cur</span></span><br><span class="line">st.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">top = st.top();<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line"><span class="keyword">if</span> (top-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 既是第二次访问，也是第三次访问</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">cur = top-&gt;right;</span><br><span class="line">st.pop();</span><br><span class="line">last = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (top-&gt;right != last) &#123;</span><br><span class="line"><span class="comment">// 第二次访问</span></span><br><span class="line">cur = top-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 第三次访问</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">st.pop();</span><br><span class="line">last = top;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">递归的写法</span><br><span class="line">       根    左子树  右子树</span><br><span class="line">       左子树 根 右子树</span><br><span class="line">       左子树  右子树  根</span><br><span class="line">       </span><br><span class="line">非递归写法  ： 便利的同时，找到第一次，第二次，第三次 访问点</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://jack-wang128801.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://jack-wang128801.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>特殊的一些用法</title>
    <link href="https://jack-wang128801.github.io/2019/04/05/%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"/>
    <id>https://jack-wang128801.github.io/2019/04/05/特殊的一些用法/</id>
    <published>2019-04-05T13:16:32.000Z</published>
    <updated>2019-05-05T15:03:33.700Z</updated>
    
    <content type="html"><![CDATA[<h4 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h4><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.操作数入栈</span><br><span class="line">2.遇到操作符，从栈中取出操作数需要的操作数，取出的操作数的位置应该为从右到左</span><br><span class="line">，进行运算，运算结果继续压栈</span><br><span class="line">3.复制1，2</span><br><span class="line">4：返回栈顶元素，即为表达式的最终运行结果</span><br></pre></td></tr></table></figure><p><strong>二叉树的镜像</strong></p><blockquote><p>1.递归做法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">        swap(pRoot-&gt;left,pRoot-&gt;right);</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>2.非递归</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(pRoot)&#123;</span><br><span class="line">            q.push(pRoot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            q.push();</span><br><span class="line">            <span class="keyword">if</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;     <span class="comment">//需要补充</span></span><br></pre></td></tr></table></figure><p><strong>第k大个元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>利用适配器模拟实现deque</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">container</span> = <span class="title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">_con.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">_con.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">Front</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> size()&#123;</span><br><span class="line"><span class="keyword">return</span> _con.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">Back</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">container _con;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.Push(<span class="number">1</span>);</span><br><span class="line">q.Push(<span class="number">2</span>);</span><br><span class="line">q.Push(<span class="number">3</span>);</span><br><span class="line">q.Push(<span class="number">4</span>);</span><br><span class="line">q.Push(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span> (!q.Empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q.Front() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q.Pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;逆波兰表达式&quot;&gt;&lt;a href=&quot;#逆波兰表达式&quot; class=&quot;headerlink&quot; title=&quot;逆波兰表达式&quot;&gt;&lt;/a&gt;逆波兰表达式&lt;/h4&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="一些特殊的用法" scheme="https://jack-wang128801.github.io/tags/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://jack-wang128801.github.io/2019/04/05/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://jack-wang128801.github.io/2019/04/05/栈与队列/</id>
    <published>2019-04-05T11:41:14.000Z</published>
    <updated>2019-05-05T15:02:41.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><a id="more"></a><h4 id="1-栈的实现"><a href="#1-栈的实现" class="headerlink" title="1.栈的实现"></a>1.栈的实现</h4><h5 id="A：栈的介绍"><a href="#A：栈的介绍" class="headerlink" title="A：栈的介绍"></a>A：栈的介绍</h5><blockquote><p><strong>栈</strong> ：<strong>一种特殊的线性表其只允许在固定的一端进行插入和删除元素操作 </strong>   进行数据插入和删除操作的一端称为  <strong>栈顶</strong> ，另一端称为栈底。栈中的数据元素遵守 <strong>后进先出LIFO（Last In First Out）的原则</strong><br><strong>压栈</strong> ：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。<br><strong>出栈</strong> ：栈的删除操作叫做出栈。出数据也在栈顶</p></blockquote><p><strong>特点</strong> ：只允许在一端进行插入弹出操作。</p><p><strong>例如</strong> ：手枪里的子弹，在装子弹时先装进去的子弹在射击过程中是最后射出来的，而最后装进去的子弹却是最先射出来的 。砌墙的石头后来居上有木有？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈与队列&quot;&gt;&lt;a href=&quot;#栈与队列&quot; class=&quot;headerlink&quot; title=&quot;栈与队列&quot;&gt;&lt;/a&gt;栈与队列&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="栈与队列" scheme="https://jack-wang128801.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>deque</title>
    <link href="https://jack-wang128801.github.io/2019/04/05/stack&amp;deque/"/>
    <id>https://jack-wang128801.github.io/2019/04/05/stack&amp;deque/</id>
    <published>2019-04-05T10:34:07.000Z</published>
    <updated>2019-05-05T15:04:53.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="deque的使用"><a href="#deque的使用" class="headerlink" title="deque的使用"></a>deque的使用</h3><a id="more"></a><h4 id="1-队列"><a href="#1-队列" class="headerlink" title="1.队列"></a>1.队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> &gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Deque</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span> :</span><br><span class="line">        iterator</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>二叉树的遍历</strong></p><blockquote><p>用非得递归的方法来前序遍历二叉树</p><p>1.先遍历左节点，左节点全部压栈，左节点遍历完成</p><p>2.按照栈 的顺序后进先出，取出每一个压栈的结点，从下向上遍历右结点]</p></blockquote><p><strong>找最近公共祖先</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;deque的使用&quot;&gt;&lt;a href=&quot;#deque的使用&quot; class=&quot;headerlink&quot; title=&quot;deque的使用&quot;&gt;&lt;/a&gt;deque的使用&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="deque" scheme="https://jack-wang128801.github.io/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>vector</title>
    <link href="https://jack-wang128801.github.io/2019/04/04/vector/"/>
    <id>https://jack-wang128801.github.io/2019/04/04/vector/</id>
    <published>2019-04-04T12:26:44.000Z</published>
    <updated>2019-05-05T15:04:29.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vector-的相关知识"><a href="#vector-的相关知识" class="headerlink" title="vector 的相关知识"></a>vector 的相关知识</h3><a id="more"></a><h4 id="1-vector的概述"><a href="#1-vector的概述" class="headerlink" title="1.vector的概述"></a>1.vector的概述</h4><h5 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h5><blockquote><p>cbegin()与cend ()迭代器内的值不可修改</p></blockquote><blockquote><p>头文件#include<algorithm></algorithm></p></blockquote><h4 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h4><h5 id="出现实现的代码"><a href="#出现实现的代码" class="headerlink" title="出现实现的代码"></a>出现实现的代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = v.begin();</span><br><span class="line"><span class="keyword">while</span> (it != v.end())&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"> v.erase(it);</span><br><span class="line">&#125;</span><br><span class="line">++it;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针指向了 原来的空间，使得指针你已失效的内存地址。</span></span><br></pre></td></tr></table></figure><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = v.begin();</span><br><span class="line"><span class="keyword">while</span> (it != v.end())&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">it = v.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;e&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为 1 3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = v.begin();</span><br><span class="line"><span class="keyword">while</span> (it != v.end())&#123;</span><br><span class="line">it = v.erase(it);</span><br><span class="line">++it;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为2 4</span></span><br></pre></td></tr></table></figure><h5 id="vector在oj中的使用"><a href="#vector在oj中的使用" class="headerlink" title="vector在oj中的使用"></a>vector在oj中的使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">size_t</span> i =<span class="number">0</span> ; i &lt; nums.size(); ++i)&#123;</span><br><span class="line"> value ^= nums[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在c++11中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e:nums)&#123;</span><br><span class="line"> value ^= e;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器值的交换接口</span></span><br><span class="line">v1.swap(v2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vector-的相关知识&quot;&gt;&lt;a href=&quot;#vector-的相关知识&quot; class=&quot;headerlink&quot; title=&quot;vector 的相关知识&quot;&gt;&lt;/a&gt;vector 的相关知识&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="vector" scheme="https://jack-wang128801.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>string类</title>
    <link href="https://jack-wang128801.github.io/2019/03/30/string%E7%B1%BB/"/>
    <id>https://jack-wang128801.github.io/2019/03/30/string类/</id>
    <published>2019-03-30T09:04:54.000Z</published>
    <updated>2019-05-05T15:04:48.754Z</updated>
    
    <content type="html"><![CDATA[<p>###String </p><a id="more"></a><p><strong>一点关于转义字符的知识</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a1[]= <span class="string">"\0"</span>;<span class="comment">//\0 被认为是一个字符，转义字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a1) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(a1) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a2[] = <span class="string">"\\0"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(a2) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a3[]= <span class="string">"0000"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a3) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(a3) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a4[]= <span class="string">"\0000"</span>;  <span class="comment">// \000 0 \0      </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a4) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(a4) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a5[] = <span class="string">"\000 0"</span>;        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a5) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(a5) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a6[] = <span class="string">"\0 000"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a5) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//6</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(a5) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复习转义字符</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理动态增长字符串的数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">basic_string</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        T* _str;</span><br><span class="line">        <span class="keyword">size_t</span> _size;   <span class="comment">//Linux 下不要这句</span></span><br><span class="line">        <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string构造时最常见的几种方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span> <span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"world!"</span>;</span><br><span class="line"><span class="comment">//单参数的构造函数的隐式类型转换(explicit)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;s1&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-string-的简介"><a href="#1-string-的简介" class="headerlink" title="1.string 的简介"></a>1.string 的简介</h3><blockquote><ol><li>字符串是表示字符序列的类</li><li>标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作<br>单字节字符字符串的设计特性。</li><li>string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信<br>息，请参阅basic_string)。</li><li>string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits<br>和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。</li><li>注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个<br>类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作</li></ol></blockquote><blockquote><p>总结：</p><ol><li>string是表示字符串的字符串类</li><li>该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。</li><li>string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt;<br>string;</li><li>不能操作多字节或者变长字符的序列。<br>在使用string类时，必须包含头文件以及using namespace std;</li></ol></blockquote><h4 id="1-1用法接口"><a href="#1-1用法接口" class="headerlink" title="1.1用法接口"></a>1.1用法接口</h4><h5 id="1-1-1-string常用的构造方式"><a href="#1-1-1-string常用的构造方式" class="headerlink" title="1.1.1 string常用的构造方式"></a>1.1.1 string常用的构造方式</h5><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g1luo2p8vpj30ky07nmyq.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">string</span> s1;    <span class="comment">// 构造空的string类对象s1</span></span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"hello bit"</span>)</span></span>;  <span class="comment">// 用C格式字符串构造string类对象s2</span></span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">10</span>, <span class="string">'a'</span>)</span></span>;   <span class="comment">// 用10个字符'a'构造string类对象s3</span></span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(s2)</span></span>;    <span class="comment">// 拷贝构造s4</span></span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">s5</span><span class="params">(s3, <span class="number">5</span>)</span></span>;    <span class="comment">// 用s3中前5个字符构造string对象s5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整示例</span></span><br><span class="line"><span class="comment">//string构造时最常见的几种方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span> <span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"world!"</span>;</span><br><span class="line"><span class="comment">//单参数的构造函数的隐式类型转换(explicit)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;s1&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-2-string类对象的容量操作"><a href="#1-1-2-string类对象的容量操作" class="headerlink" title="1.1.2 string类对象的容量操作"></a>1.1.2 string类对象的容量操作</h5><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g1lux7kheij30kd0atwgo.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size/length/clear/resize</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestString1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// 注意：string类对象支持直接用cin和cout进行输入和输出</span></span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello, bit!!!"</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s.length();</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 将s中的字符串清空，注意清空时只是将size清0，不改变底层空间的大小</span></span><br><span class="line"> s.clear();</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">// 将s中有效字符个数增加到10个，多出位置用'a'进行填充</span></span><br><span class="line"> <span class="comment">// “aaaaaaaaaa”</span></span><br><span class="line"> s.resize(<span class="number">10</span>, <span class="string">'a'</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">// 将s中有效字符个数增加到15个，多出位置用缺省值'\0'进行填充</span></span><br><span class="line"> <span class="comment">// "aaaaaaaaaa\0\0\0\0\0"</span></span><br><span class="line"> <span class="comment">// 注意此时s中有效字符个数已经增加到15个</span></span><br><span class="line"> s.resize(<span class="number">15</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">// 将s中有效字符个数缩小到5个</span></span><br><span class="line"> s.resize(<span class="number">5</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====================================================================================</span></span><br><span class="line">==</span><br><span class="line"><span class="keyword">void</span> TestString2()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">string</span> s;</span><br><span class="line"> <span class="comment">// 测试reserve是否会改变string中有效元素个数</span></span><br><span class="line"> s.reserve(<span class="number">100</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">// 测试reserve参数小于string的底层空间大小时，是否会将空间缩小</span></span><br><span class="line"> s.reserve(<span class="number">50</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h6><blockquote><ol><li>size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。</li><li>clear()只是将string中有效字符清空，不改变底层空间大小。</li><li>resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的<br>元素空间。注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。</li><li>reserve(size_t res_arg=0)：为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserver不会改变容量大小.</li></ol></blockquote><h5 id="1-1-3-string-类对象的访问操作"><a href="#1-1-3-string-类对象的访问操作" class="headerlink" title="1.1.3 string 类对象的访问操作"></a>1.1.3 string 类对象的访问操作</h5><p><strong>用法 </strong></p><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g1lv3djuf9j30jq04gq3o.jpg" alt></p><p><strong>示例代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">"hello Bit"</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">const</span> String <span class="title">s2</span><span class="params">(<span class="string">"Hello Bit"</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="string">" "</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s1[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;s2[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> s1[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i)</span><br><span class="line">     &#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s1[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// s2[0] = 'h'; 代码编译失败，因为const类型对象不能修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-4-string类对象的修改操作"><a href="#1-1-4-string类对象的修改操作" class="headerlink" title="1.1.4. string类对象的修改操作"></a>1.1.4. string类对象的修改操作</h5><p><strong>用法接口</strong></p><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g1lv6i5x5qj30jz0ebadi.jpg" alt></p><p><strong>示例代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">string</span> str;</span><br><span class="line"> str.push_back(<span class="string">' '</span>); <span class="comment">// 在str后插入空格</span></span><br><span class="line"> str.append(<span class="string">"hello"</span>); <span class="comment">// 在str后追加一个字符"hello"</span></span><br><span class="line"> str += <span class="string">'b'</span>; <span class="comment">// 在str后追加一个字符'b' </span></span><br><span class="line"> str += <span class="string">"it"</span>; <span class="comment">// 在str后追加一个字符串"it"</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;str.c_str()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 以C语言的方式打印字符串</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 获取file的后缀</span></span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">file1</span><span class="params">(<span class="string">"string.cpp"</span>)</span></span>;</span><br><span class="line"> <span class="keyword">size_t</span> pos = file.rfind(<span class="string">'.'</span>);</span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">suffix</span><span class="params">(file.substr(pos, file.size()-pos))</span></span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; suffix &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// npos是string里面的一个静态成员变量</span></span><br><span class="line"> <span class="comment">// static const size_t npos = -1;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 取出url中的域名</span></span><br><span class="line"> <span class="function">sring <span class="title">url</span><span class="params">(<span class="string">"http://www.cplusplus.com/reference/string/string/find/"</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; url &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">size_t</span> start = url.find(<span class="string">"://"</span>);</span><br><span class="line"> <span class="keyword">if</span> (start == <span class="built_in">string</span>::npos)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid url"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> start += <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">size_t</span> finish = url.find(<span class="string">'/'</span>, start);</span><br><span class="line"> <span class="built_in">string</span> address = url.substr(start, finish - start);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; address &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 删除url的协议前缀</span></span><br><span class="line"> pos = url.find(<span class="string">"://"</span>);</span><br><span class="line"> url.erase(<span class="number">0</span>, pos+<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;url&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用reserve提高插入数据的效率，避免增容带来的开销</span></span><br><span class="line"><span class="comment">//====================================================================================</span></span><br><span class="line">==</span><br><span class="line"><span class="keyword">void</span> TestPushBack()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">string</span> s;</span><br><span class="line"> <span class="keyword">size_t</span> sz = s.capacity();</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"making s grow:\n"</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line"> &#123;</span><br><span class="line"> s += <span class="string">'c'</span>;</span><br><span class="line"> <span class="keyword">if</span> (sz != s.capacity())</span><br><span class="line"> &#123;</span><br><span class="line"> sz = s.capacity();</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity changed: "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPushBack_P</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">string</span> s;</span><br><span class="line"> s.reserve(<span class="number">100</span>);</span><br><span class="line"> <span class="keyword">size_t</span> sz = s.capacity();</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"making s grow:\n"</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line"> &#123;</span><br><span class="line"> s += <span class="string">'c'</span>;</span><br><span class="line"> <span class="keyword">if</span> (sz != s.capacity())</span><br><span class="line"> &#123;</span><br><span class="line"> sz = s.capacity();</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity changed: "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> </p><blockquote><ol><li>在string尾部追加字符时，s.push_back(c) / s.append(1, c) / s += ‘c’三种的实现方式差不多，一般<br>情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。</li><li>对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留好。</li></ol></blockquote><h5 id="1-1-5-string类非成员函数"><a href="#1-1-5-string类非成员函数" class="headerlink" title="1.1.5. string类非成员函数"></a>1.1.5. string类非成员函数</h5><p><strong>一些用法</strong></p><p><img src="https://wx4.sinaimg.cn/mw690/0071OE7sly1g1m4djxywmj30t70akjsw.jpg" alt></p><h5 id="1-1-6-面试题目"><a href="#1-1-6-面试题目" class="headerlink" title="1.1.6 面试题目"></a>1.1.6 面试题目</h5><p><strong>翻转字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(s.empty())</span><br><span class="line"> <span class="keyword">return</span> s;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">size_t</span> start = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">size_t</span> end = s.size()<span class="number">-1</span>; <span class="comment">//末尾的元素下标</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span>(start &lt; end)</span><br><span class="line"> &#123;</span><br><span class="line"> swap(s[start], s[end]);<span class="comment">//将两个元素交换，</span></span><br><span class="line"> ++start;</span><br><span class="line"> --end;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>只出现一次的字符的下标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字符串里面最后一个单词的长度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>验证一个字符串是否为回文结构 </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字符串相加 </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="string-的迭代器"><a href="#string-的迭代器" class="headerlink" title="string 的迭代器"></a>string 的迭代器</h4><h5 id="1-迭代器的使用"><a href="#1-迭代器的使用" class="headerlink" title="1.迭代器的使用"></a>1.迭代器的使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器的使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_string</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> num = <span class="string">"1234"</span>;</span><br><span class="line">    <span class="comment">//迭代器的优势：迭代器给出了统一的方法去访问容器，屏蔽掉底层复杂的结构细节</span></span><br><span class="line"><span class="built_in">string</span>::iterator it = num.begin();</span><br><span class="line">    <span class="comment">//string::iterator 是一个类型</span></span><br><span class="line">    <span class="comment">//it 为类名</span></span><br><span class="line">    <span class="comment">//num.begin 为返回值指向字符串的第一个位置的迭代器</span></span><br><span class="line">    <span class="comment">//num.end 为指向字符串的最后一个数据的下一个位置的迭代器('\0')的</span></span><br><span class="line"><span class="keyword">while</span> (it!=num.end())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test_string();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g1l1znv8wvj30wu0hkqqa.jpg" alt></p><h6 id="三种不同迭代器的使用"><a href="#三种不同迭代器的使用" class="headerlink" title="三种不同迭代器的使用"></a>三种不同迭代器的使用</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器的使用，打印出原来的字符串方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_string</span><span class="params">( )</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> num = <span class="string">"1234"</span>;</span><br><span class="line"><span class="built_in">string</span>::iterator it = num.begin();</span><br><span class="line">    <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it != num.end())&#123;</span><br><span class="line">        value*=<span class="number">10</span>;</span><br><span class="line">value+=*it-<span class="string">'0'</span>;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ::iterator vit = v.begin();</span><br><span class="line"><span class="keyword">while</span> (vit != v.end())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">++vit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;</span><br><span class="line">l.push_back(<span class="number">3</span>);</span><br><span class="line">l.push_back(<span class="number">4</span>);</span><br><span class="line">l.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator lit = l.begin();</span><br><span class="line"><span class="keyword">while</span> (lit != l.end())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *lit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">++lit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test_string();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器的使用，倒叙访问字符串"><a href="#迭代器的使用，倒叙访问字符串" class="headerlink" title="迭代器的使用，倒叙访问字符串"></a>迭代器的使用，倒叙访问字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test_string3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> num = <span class="string">"1234"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反向迭代器</span></span><br><span class="line"><span class="built_in">string</span>::reverse_iterator rit = num.rbegin();</span><br><span class="line"><span class="keyword">while</span> (rit != num.rend())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">++rit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test_string3();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const-迭代器"><a href="#const-迭代器" class="headerlink" title="const 迭代器"></a>const 迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToNum</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span>::const_iterator it = str.begin();</span><br><span class="line"><span class="keyword">while</span> (it != str.end())&#123;</span><br><span class="line">value *= <span class="number">10</span>;</span><br><span class="line">value += (*it - <span class="string">'0'</span>);</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test_string3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> num = <span class="string">"1234"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反向迭代器</span></span><br><span class="line"><span class="built_in">string</span>::reverse_iterator rit = num.rbegin();</span><br><span class="line"><span class="keyword">while</span> (rit != num.rend())&#123;</span><br><span class="line">(*rit) += <span class="number">1</span>;</span><br><span class="line">++rit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; StrToNum(num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test_string3();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器的总结"><a href="#迭代器的总结" class="headerlink" title="迭代器的总结"></a>迭代器的总结</h5><blockquote><p>涉及模式：访问机制</p><p>在外部：看指针使用，内部实现上，不同容器有不同的实现方式，不一定是原生指针。</p><p>迭代器分类：</p><p>1.正向迭代器(可读可写)</p><p>2.反向迭代器(可读可写)</p><p>3.const迭代器(只读)</p><p>begin: 第一个元素的位置</p><p>end:最后一个元素的下一个位置</p><p>rbegin :最后一个元素的位置</p><p>rend:第一个元素的前一个位置</p><p>迭代器所指的空间为一个左闭右开的空间</p></blockquote><h3 id="string-新的访问方式"><a href="#string-新的访问方式" class="headerlink" title="string 新的访问方式"></a>string 新的访问方式</h3><blockquote><p>1.迭代器—-不常用，跟其他容器保持统一的访问方式</p><p>2.for+下标 — 更常用</p><p>3.c++ 11 语法糖</p></blockquote><h5 id="for循环-下标"><a href="#for循环-下标" class="headerlink" title="for循环+下标"></a>for循环+下标</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环+下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToNum</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str.size();++i)&#123;</span><br><span class="line">value *= <span class="number">10</span>;</span><br><span class="line">value += (str[i]-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test_string3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> num = <span class="string">"1234"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反向迭代器</span></span><br><span class="line"><span class="built_in">string</span>::iterator rit = num.begin();</span><br><span class="line"><span class="keyword">while</span> (rit != num.end())&#123;</span><br><span class="line">(*rit) += <span class="number">1</span>;</span><br><span class="line">++rit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; StrToNum(num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test_string3();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-11-语法糖"><a href="#c-11-语法糖" class="headerlink" title=".c++ 11 语法糖"></a>.c++ 11 语法糖</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToNum</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e:str)&#123;</span><br><span class="line">value *= <span class="number">10</span>;</span><br><span class="line">value += (e - <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test_string</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> num = <span class="string">"1234"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反向迭代器</span></span><br><span class="line"><span class="built_in">string</span>::iterator rit = num.begin();</span><br><span class="line"><span class="keyword">while</span> (rit != num.end())&#123;</span><br><span class="line">(*rit) += <span class="number">1</span>;</span><br><span class="line">++rit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; StrToNum(num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test_string();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string-的capacity"><a href="#string-的capacity" class="headerlink" title="string 的capacity"></a>string 的capacity</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test_string</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world!"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//为字符串预留空间 reserve</span></span><br><span class="line">s.reserve(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s.resize(<span class="number">51</span>);</span><br><span class="line"><span class="comment">//resize 空间不够的话增容，空间够的话剩余位置用</span></span><br><span class="line"><span class="comment">//0 补，若给定值得话就会把剩余位置补成给定的值</span></span><br><span class="line"><span class="comment">//s.resize(80,'1');</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test_string();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="string-类的对象的访问操作"><a href="#string-类的对象的访问操作" class="headerlink" title="string 类的对象的访问操作"></a>string 类的对象的访问操作</h5><p><img src="https://wx4.sinaimg.cn/mw690/0071OE7sly1g1l4kmtzjkj30ko052q3p.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="string-类对象的修改操作"><a href="#string-类对象的修改操作" class="headerlink" title="string 类对象的修改操作"></a>string 类对象的修改操作</h5><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g1l4nhlm75j30jv0e041x.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test_string</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line">s1 += <span class="string">' '</span>;</span><br><span class="line">s1 += <span class="string">"world"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"!!!!"</span>;</span><br><span class="line">s1 += s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test_string();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c_str的用法</span></span><br></pre></td></tr></table></figure><h5 id="string的相加"><a href="#string的相加" class="headerlink" title="string的相加"></a>string的相加</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test_string</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello "</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"world!!"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 + <span class="string">"world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello "</span> + s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1+s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test_string();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//效率比较低</span></span><br></pre></td></tr></table></figure><p>###### </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashtable[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">            hanshtable[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable[s[i]-<span class="string">'a'</span>==<span class="number">1</span>])   &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">operator</span>+  (<span class="built_in">string</span> s1,<span class="built_in">string</span> s2)&#123;</span><br><span class="line">    <span class="built_in">string</span> s=s1;</span><br><span class="line">    s1+=s2;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span> +=(stirng s2)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//+的效率比较低</span></span><br></pre></td></tr></table></figure><h6 id="计算字符串最后一个单词的长度，单词以空格隔开。"><a href="#计算字符串最后一个单词的长度，单词以空格隔开。" class="headerlink" title="计算字符串最后一个单词的长度，单词以空格隔开。"></a>计算字符串最后一个单词的长度，单词以空格隔开。</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="判断字符串是否是回文结构-看例子，自己写"><a href="#判断字符串是否是回文结构-看例子，自己写" class="headerlink" title="判断字符串是否是回文结构(看例子，自己写)"></a>判断字符串是否是回文结构(看例子，自己写)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addstrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> end1 = num1.size() - <span class="number">1</span>, end2 = num2.size() - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">string</span> retstr;</span><br><span class="line"><span class="comment">//进位</span></span><br><span class="line"><span class="keyword">char</span> next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (end1 &gt;= <span class="number">0</span> &amp;&amp; end2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">char</span> value1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (end1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">value1 = num1[end1] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>  value2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (end2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">value2 = num2[end2] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> addvalue = value1 + value2 + next;</span><br><span class="line"><span class="keyword">if</span> (addvalue&gt;<span class="number">90</span>)&#123;</span><br><span class="line">next = <span class="number">1</span>;</span><br><span class="line">addvalue -= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">retstr.insert(retstr.begin(), addvalue + <span class="string">'0'</span>);</span><br><span class="line">            <span class="comment">//头插</span></span><br><span class="line">--end1;</span><br><span class="line">--end2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next == <span class="number">1</span>)</span><br><span class="line">retstr.insert(retstr.begin(), <span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">return</span> retstr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="版本改进"><a href="#版本改进" class="headerlink" title="版本改进"></a>版本改进</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addstrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> end1 = num1.size() - <span class="number">1</span>, end2 = num2.size() - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">string</span> retstr;</span><br><span class="line">       retstr.reserve(num1.size()&gt;num2.size()?          num1.size()+<span class="number">1</span>:um2.szie()+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//进位</span></span><br><span class="line"><span class="keyword">char</span> next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (end1 &gt;= <span class="number">0</span> &amp;&amp; end2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">char</span> value1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (end1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">value1 = num1[end1] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>  value2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (end2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">value2 = num2[end2] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> addvalue = value1 + value2 + next;</span><br><span class="line"><span class="keyword">if</span> (addvalue&gt;<span class="number">90</span>)&#123;</span><br><span class="line">next = <span class="number">1</span>;</span><br><span class="line">addvalue -= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">retstr+=(addvalue+<span class="string">'0'</span>);</span><br><span class="line">--end1;</span><br><span class="line">--end2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next == <span class="number">1</span>)</span><br><span class="line">retstr+=<span class="string">'1'</span>;</span><br><span class="line">        <span class="comment">//reverse(retstr.begin(),retstr.end());</span></span><br><span class="line">        <span class="comment">//和上面的注释掉的那句搭配使用</span></span><br><span class="line"><span class="keyword">return</span> retstr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="stringf的部分实现"><a href="#stringf的部分实现" class="headerlink" title="stringf的部分实现"></a>stringf的部分实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span></span><br></pre></td></tr></table></figure><h5 id="浅拷贝-按字节拷贝"><a href="#浅拷贝-按字节拷贝" class="headerlink" title="浅拷贝:按字节拷贝"></a>浅拷贝:按字节拷贝</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>写时考贝</strong></p><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g1m0fhdp68j30pj0fvjsb.jpg" alt></p><blockquote><p>kmp 在字符串相似度较高时效率才比较高 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###String &lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="string类" scheme="https://jack-wang128801.github.io/tags/string%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="https://jack-wang128801.github.io/2019/03/27/%E6%A8%A1%E6%9D%BF/"/>
    <id>https://jack-wang128801.github.io/2019/03/27/模板/</id>
    <published>2019-03-27T10:42:10.000Z</published>
    <updated>2019-05-05T15:02:34.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板初阶"><a href="#模板初阶" class="headerlink" title="模板初阶"></a>模板初阶</h2><h3 id="1-泛型编程"><a href="#1-泛型编程" class="headerlink" title="1.泛型编程"></a>1.泛型编程</h3><a id="more"></a><blockquote><p>实现函数的交换</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span>&amp; left, <span class="keyword">int</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">double</span>&amp; left, <span class="keyword">double</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">double</span> temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span>&amp; left, <span class="keyword">char</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="函数重载的缺点"><a href="#函数重载的缺点" class="headerlink" title="函数重载的缺点"></a>函数重载的缺点</h6><blockquote><p>1.重载函数仅仅是类型不同，代码的复用率比较低，只要有新的类型出现就需要</p><p>增加对应的重载函数。</p><p>2.代码的可维护性查，一个出错可能所有的重都会出现问题</p></blockquote><blockquote><p> 模板：相当于一个模型，让编辑器通过它来推演不同的函数。</p><p>比如：造泥人的模子只有一个，而造出来的你人却有很多不同颜色的 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span>&amp; <span class="title">left</span>, <span class="title">T</span>&amp; <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T temp = left;</span><br><span class="line">left = right;</span><br><span class="line">right = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> aa = <span class="number">1.0000000</span>, bb = <span class="number">2.000000</span>;</span><br><span class="line">swap(a,b);</span><br><span class="line">swap(aa,bb);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g1hkd9mh20j30dv0b30st.jpg" alt></p><h6 id="c-模板的示意图"><a href="#c-模板的示意图" class="headerlink" title="c++ 模板的示意图"></a>c++ 模板的示意图</h6><p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g1hkewaignj30yn0k1teo.jpg" alt></p><h3 id="2-模板的分类"><a href="#2-模板的分类" class="headerlink" title="2.模板的分类"></a>2.模板的分类</h3><h4 id="2-1函数模板"><a href="#2-1函数模板" class="headerlink" title="2.1函数模板"></a>2.1函数模板</h4><h6 id="2-1-1概念："><a href="#2-1-1概念：" class="headerlink" title="2.1.1概念："></a>2.1.1概念：</h6><h6 id="函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。"><a href="#函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。" class="headerlink" title="函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。"></a>函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。</h6><h6 id="2-1-2函数模板格式："><a href="#2-1-2函数模板格式：" class="headerlink" title="2.1.2函数模板格式："></a>2.1.2函数模板格式：</h6><blockquote><p> template<typename t1, typename t2,......,typename tn>  (语法格式)</typename></p><p>返回值类型 函数名(参数列表){}</p></blockquote><h6 id="2-13-模板的引用方式"><a href="#2-13-模板的引用方式" class="headerlink" title="2.13 模板的引用方式"></a>2.13 模板的引用方式</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">( T&amp; left, T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> T temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中typename是用来定义模板参数的关键字，可以用class 来代替，但是不可以用struct来替换</span></span><br></pre></td></tr></table></figure><h6 id="本质的理解-看起来是调用一个函数，实际调用的是不同的函数。"><a href="#本质的理解-看起来是调用一个函数，实际调用的是不同的函数。" class="headerlink" title="本质的理解:看起来是调用一个函数，实际调用的是不同的函数。"></a>本质的理解:看起来是调用一个函数，实际调用的是不同的函数。</h6><h4 id="2-2-函数模板的实例化"><a href="#2-2-函数模板的实例化" class="headerlink" title="2.2 函数模板的实例化"></a>2.2 函数模板的实例化</h4><blockquote><p>用不同类型的参数使用函数模板时，称为函数模板的实例化。</p><h6 id="模板参数实例化分为：隐式实例化和显式实例化。"><a href="#模板参数实例化分为：隐式实例化和显式实例化。" class="headerlink" title="模板参数实例化分为：隐式实例化和显式实例化。"></a>模板参数实例化分为：隐式实例化和显式实例化。</h6></blockquote><h5 id="2-2-1-隐式实例化：让编辑器根据实参推演模板参数的实际类型"><a href="#2-2-1-隐式实例化：让编辑器根据实参推演模板参数的实际类型" class="headerlink" title="2.2.1 隐式实例化：让编辑器根据实参推演模板参数的实际类型"></a>2.2.1 隐式实例化：让编辑器根据实参推演模板参数的实际类型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">left</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">right</span>)//调用方式为引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a1 = <span class="number">10</span>, a2 = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">double</span> d1 = <span class="number">10.0</span>, d2 = <span class="number">20.0</span>;</span><br><span class="line"> Add(a1, a2);</span><br><span class="line"> Add(d1, d2);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int 或者 double类型而报错</span></span><br><span class="line"><span class="comment"> 注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅</span></span><br><span class="line"><span class="comment"> Add(a1, d1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 此时有两种处理方式：1. 用户自己来强制转化 2. 使用显式实例化</span></span><br><span class="line"> Add(a, (<span class="keyword">int</span>)d);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Add(a1,d1)编译器编译不通过，两个参数类型不同，将一个强转成另一个的类型``</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-显式实例化：在函数名后面的-lt-gt-中指定模板参数的实际类型"><a href="#2-2-2-显式实例化：在函数名后面的-lt-gt-中指定模板参数的实际类型" class="headerlink" title="2.2.2 显式实例化：在函数名后面的&lt;&gt;中指定模板参数的实际类型"></a>2.2.2 显式实例化：在函数名后面的&lt;&gt;中指定模板参数的实际类型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">double</span> b = <span class="number">20.0</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 显式实例化的两种方式</span></span><br><span class="line"> Add&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line"> Add(a,(<span class="keyword">int</span>)b);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。</span></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>( <span class="title">T</span> <span class="title">left</span>,  <span class="title">T</span> <span class="title">right</span>)//此时不需要引用，引用出错</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> aa = <span class="number">1.0000000</span>, bb = <span class="number">2.000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum=Add(a,b);</span><br><span class="line"><span class="keyword">double</span> sum1 = Add(aa, bb);</span><br><span class="line"> Add&lt;<span class="keyword">int</span>&gt;(a, aa);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sum="</span>&lt;&lt;sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sum1="</span>&lt;&lt;sum1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Add&lt;<span class="keyword">int</span>&gt;(a, aa) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Add(a,(<span class="keyword">int</span>)bb) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-模板参数的匹配原则"><a href="#2-3-模板参数的匹配原则" class="headerlink" title="2.3 模板参数的匹配原则"></a>2.3 模板参数的匹配原则</h4><h6 id="1-一个非模板函数可以和同名的模板函数同时存在，而且该函数还可以被实例化为这个非模板实例化函数"><a href="#1-一个非模板函数可以和同名的模板函数同时存在，而且该函数还可以被实例化为这个非模板实例化函数" class="headerlink" title="1.一个非模板函数可以和同名的模板函数同时存在，而且该函数还可以被实例化为这个非模板实例化函数"></a>1.一个非模板函数可以和同名的模板函数同时存在，而且该函数还可以被实例化为这个非模板实例化函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门处理int的加法函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通用加法函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T</span> <span class="title">left</span>, <span class="title">T</span> <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 与非模板函数匹配，编译器不需要推演，直接调用int型的Add函数</span></span><br><span class="line"> Add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用编译器特化的Add版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数，-那么将选择模板"><a href="#2-对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数，-那么将选择模板" class="headerlink" title="2.对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板"></a>2.对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门处理int的加法函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通用加法函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">Add</span>(<span class="title">T1</span> <span class="title">left</span>, <span class="title">T2</span> <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 与非函数模板类型完全匹配，不需要函数模板实例化</span></span><br><span class="line"> Add(<span class="number">1</span>, <span class="number">2.0</span>); <span class="comment">// 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配  &#125;            //的Add函数</span></span><br></pre></td></tr></table></figure><h4 id="3-类模板"><a href="#3-类模板" class="headerlink" title="3. 类模板"></a>3. 类模板</h4><h5 id="3-1-类模板的定义格式"><a href="#3-1-类模板的定义格式" class="headerlink" title="3.1 类模板的定义格式"></a>3.1 类模板的定义格式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>,....,<span class="title">class</span> <span class="title">Tn</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> 类模板名&#123;</span></span><br><span class="line"><span class="comment">//类内成员定义</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><blockquote><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>看vector 文档（任务）string</p><p>内存管理的面试题，模板基础语法。string使用及其obj的面试题</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模板初阶&quot;&gt;&lt;a href=&quot;#模板初阶&quot; class=&quot;headerlink&quot; title=&quot;模板初阶&quot;&gt;&lt;/a&gt;模板初阶&lt;/h2&gt;&lt;h3 id=&quot;1-泛型编程&quot;&gt;&lt;a href=&quot;#1-泛型编程&quot; class=&quot;headerlink&quot; title=&quot;1.泛型编程&quot;&gt;&lt;/a&gt;1.泛型编程&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="模板" scheme="https://jack-wang128801.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>c++类与对象(下)</title>
    <link href="https://jack-wang128801.github.io/2019/03/24/CPP%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B8%8B/"/>
    <id>https://jack-wang128801.github.io/2019/03/24/CPP类与对象下/</id>
    <published>2019-03-24T02:02:00.000Z</published>
    <updated>2019-05-05T15:01:21.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-再谈构造函数"><a href="#1-再谈构造函数" class="headerlink" title="1. 再谈构造函数"></a>1. 再谈构造函数</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year)&#123;  <span class="comment">//构造函数用来初始变量</span></span><br><span class="line">        _year = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2019</span>)</span></span>;</span><br><span class="line">    <span class="comment">//自动调用Date(int year ) 函数</span></span><br><span class="line">    Date d2 = <span class="number">2018</span>;</span><br><span class="line">    <span class="comment">//也可以自动调用Date(int year ) 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-初始化列表"><a href="#1-2-初始化列表" class="headerlink" title="1.2 初始化列表"></a>1.2 初始化列表</h4><blockquote><ul><li>存在于函数名与函数体之间</li><li>初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个”成员变量”后面跟一个放在括号中的初始值或表达式。</li><li>默认构造函数:无参或者全缺省</li></ul></blockquote><h5 id="如下例"><a href="#如下例" class="headerlink" title="如下例"></a>如下例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line"> : _year(year)</span><br><span class="line"> , _month(month)</span><br><span class="line"> , _day(day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-3关键字explicit"><a href="#1-3关键字explicit" class="headerlink" title="1.3关键字explicit"></a>1.3关键字explicit</h4><blockquote><p>构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Date(<span class="keyword">int</span> year)</span><br><span class="line">:_year(year)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">/*explicit Date(int year)</span></span><br><span class="line"><span class="comment">:_year(year)</span></span><br><span class="line"><span class="comment">&#123;&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个整形变量给日期类型对象赋值</span></span><br><span class="line"><span class="comment">// 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值</span></span><br><span class="line">d1 = <span class="number">2019</span>;<span class="comment">//使用explicit时这种赋值也可以使用,阻止单三形式的隐式转换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">TestDate();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码可读性不是很好，用explicit修饰构造函数，将会禁止单参构造函数的隐式转换。</p></blockquote><h4 id="​-2-关键字-static"><a href="#​-2-关键字-static" class="headerlink" title="​ 2.关键字  static"></a>​ 2.关键字  static</h4><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><h6 id="声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；"><a href="#声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；" class="headerlink" title="声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；"></a>声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；</h6><h6 id="用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化"><a href="#用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化" class="headerlink" title="用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化"></a>用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化</h6><h6 id="对于静态成员函数不能访问它的成员变量，因为他没有this指针"><a href="#对于静态成员函数不能访问它的成员变量，因为他没有this指针" class="headerlink" title="对于静态成员函数不能访问它的成员变量，因为他没有this指针"></a>对于静态成员函数不能访问它的成员变量，因为他没有this指针</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Date()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">Date (<span class="keyword">const</span> Date&amp;d1)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Date::count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d.count&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//公有成员的访问方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态函数需要用类名+作用限定符去调用或者用对象去调用(. 操作符);</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此情况为static定义的函数为公有的</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Date(<span class="keyword">int</span> year)&#123;</span><br><span class="line">      _count++;</span><br><span class="line">      _year = year;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Date(int)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  Date(<span class="keyword">const</span> Date&amp; d1)&#123;</span><br><span class="line"></span><br><span class="line">      _count++;</span><br><span class="line">      _year = d1._year;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Dtae(const Date&amp; d1)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private: //将static定义为私有成员时就不能用d1._count 的方式访问了。</span></span><br><span class="line">  <span class="keyword">int</span> _year;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _count; </span><br><span class="line">  <span class="comment">//static定义的变量在类外面进行初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Date::_count = <span class="number">0</span>; <span class="comment">//static定义的变量在类外初始化格式为"类型+作用域"</span></span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">fun1</span><span class="params">(Date d1)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2019</span>)</span></span>;</span><br><span class="line">  <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2015</span>)</span></span>;</span><br><span class="line">  <span class="function">Date <span class="title">d3</span><span class="params">(<span class="number">2015</span>)</span></span>;<span class="comment">//到此为止已经调用了3次构造函数</span></span><br><span class="line">  fun1(d1);    <span class="comment">//</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; d1._count&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;d1._count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;d2._count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;d3._count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此情况为static定义的函数为私有的</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  Date(<span class="keyword">int</span> year)&#123;</span><br><span class="line">      _count++;</span><br><span class="line">      _year = year;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Date(int)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Date(<span class="keyword">const</span> Date&amp; d1)&#123;</span><br><span class="line"></span><br><span class="line">      _count++;</span><br><span class="line">     _year = d1._year;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"Dtae(const Date&amp; d1)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//作用是将count 的值传到需要调用count的地方</span></span><br><span class="line">      <span class="keyword">return</span> _count;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//改为静态函数后,出现错误，静态函数不能调用非静态函数     </span></span><br><span class="line"> <span class="comment">// static int getCount()&#123;</span></span><br><span class="line"> <span class="comment">//                    //</span></span><br><span class="line"> <span class="comment">//       return _count;</span></span><br><span class="line"> <span class="comment">//  &#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _year;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _count;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Date::_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static定义的变量在类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">fun1</span><span class="params">(Date d1)</span></span>&#123;             <span class="comment">//fun(Date *this)</span></span><br><span class="line">                      <span class="comment">//非静态函数可以调用非静态函数</span></span><br><span class="line">  <span class="keyword">return</span> d1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2019</span>)</span></span>;</span><br><span class="line">  <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2015</span>)</span></span>;</span><br><span class="line">  <span class="function">Date <span class="title">d3</span><span class="params">(<span class="number">2015</span>)</span></span>;</span><br><span class="line">  fun1(d1);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; d1.getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2       特性"></a>2.2       特性</h4><blockquote><p>静态成员为所有类对象所共享，不属于某个具体的实例</p><p>静态成员变量必须在类外定义，定义时不添加static关键字</p><p> 类静态成员即可用类名::静态成员或者对象.静态成员来访问</p><p>静态成员函数没有隐藏的this指针，不能访问任何非静态成员</p><p> 静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值，const修饰符等参数</p></blockquote><h3 id="3-c-11的成员初始化新玩法"><a href="#3-c-11的成员初始化新玩法" class="headerlink" title="3.c++ 11的成员初始化新玩法"></a>3.c++ 11的成员初始化新玩法</h3><h6 id="c-11-支持非静态的成员变量在声明时直接进行初始化"><a href="#c-11-支持非静态的成员变量在声明时直接进行初始化" class="headerlink" title="c++11 支持非静态的成员变量在声明时直接进行初始化"></a>c++11 支持非静态的成员变量在声明时直接进行初始化</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Date(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)<span class="comment">//构造函数</span></span><br><span class="line">:_year(year)      <span class="comment">//初始化可以放在初始化列表哪里构造函数赋值实现                               //也可以在声明时直接赋值</span></span><br><span class="line">,_month(month)</span><br><span class="line">,_day(day)</span><br><span class="line">        <span class="comment">//既在这里完成了函数参数的初始化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _year &lt;&lt;<span class="string">"-"</span>&lt;&lt; _month&lt;&lt;<span class="string">"-"</span> &lt;&lt; _day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//输出的结果即为传参时传递上来的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2019</span>,<span class="number">3</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>###### </p></blockquote><h3 id="4-友元"><a href="#4-友元" class="headerlink" title="4. 友元"></a>4. 友元</h3><blockquote><h6 id="友元分为：友元函数和友元类"><a href="#友元分为：友元函数和友元类" class="headerlink" title="友元分为：友元函数和友元类"></a>友元分为：友元函数和友元类</h6><h6 id="友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用"><a href="#友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用" class="headerlink" title="友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用"></a>友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用</h6></blockquote><h4 id="4-1友元函数"><a href="#4-1友元函数" class="headerlink" title="4.1友元函数"></a>4.1友元函数</h4><blockquote><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line"> : _year(year)</span><br><span class="line"> , _month(month)</span><br><span class="line"> , _day(day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout)</span><br><span class="line"> &#123;</span><br><span class="line"> _cout&lt;&lt;d._year&lt;&lt;<span class="string">"-"</span>&lt;&lt;d._month&lt;&lt;<span class="string">"-"</span>&lt;&lt;d._day;</span><br><span class="line"> <span class="keyword">return</span> _cout;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">prvate:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"> d&lt;&lt;<span class="built_in">cout</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, <span class="keyword">const</span> Date&amp; d);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin, <span class="keyword">const</span> Date&amp; d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line"> : _year(year)</span><br><span class="line">     , _month(month)</span><br><span class="line"> , _day(day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">prvate:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, <span class="keyword">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line"> _cout&lt;&lt;d._year&lt;&lt;<span class="string">"-"</span>&lt;&lt;d._month&lt;&lt;<span class="string">"-"</span>&lt;&lt;d._day;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin, <span class="keyword">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line"> _cin&gt;&gt;d._year;</span><br><span class="line"> _cin&gt;&gt;d._month;</span><br><span class="line"> _cin&gt;&gt;d._day;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Date d;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;d;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明:<br>友元函数可访问类的私有成员，但不是类的成员函数<br>友元函数不能用const修饰<br>友元函数可以在类定义的任何地方声明，不受类访问限定符限制<br>一个函数可以是多个类的友元函数<br>友元函数的调用与普通函数的调用和原理相同</p></blockquote><h4 id="4-2-友元类"><a href="#4-2-友元类" class="headerlink" title="4.2 友元类"></a>4.2 友元类</h4><blockquote><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。</p><p>友元关系是单向的，不具有交换性。</p><p>比如下述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time</p><p>类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。</p><p>友元关系不能传递.如果B是A的友元，C是B的友元，则不能说明C时A的友元</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span>             //<span class="title">Time</span> 可以访问 <span class="title">Date</span> 对象的所有成员</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span>            //<span class="title">Date</span> 可以访问 <span class="title">Time</span> 对象的所以成员</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure><h6 id="友元关系不能传递"><a href="#友元关系不能传递" class="headerlink" title="友元关系不能传递"></a>友元关系不能传递</h6><p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g1ds7y7iolj30pu0b90ta.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span> <span class="comment">// 前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span> <span class="comment">// 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Time(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span><br><span class="line"> : _hour(hour)</span><br><span class="line"> , _minute(minute)</span><br><span class="line"> , _second(second)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _hour;</span><br><span class="line"> <span class="keyword">int</span> _minute;</span><br><span class="line"> <span class="keyword">int</span> _second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> : _year(year)</span><br><span class="line"> , _month(month)</span><br><span class="line"> , _day(day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">SetTimeOfDate</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">// 直接访问时间类私有的成员变量</span></span><br><span class="line"> <span class="keyword">_t</span>._hour = hour;</span><br><span class="line"> <span class="keyword">_t</span>._minute = minute;</span><br><span class="line"> <span class="keyword">_t</span>.second = second;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line"> Time <span class="keyword">_t</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5. 内部类"></a>5. 内部类</h3><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><h6 id="内部类可以定义在外部类的public、protected、private都是可以的。"><a href="#内部类可以定义在外部类的public、protected、private都是可以的。" class="headerlink" title="内部类可以定义在外部类的public、protected、private都是可以的。"></a>内部类可以定义在外部类的public、protected、private都是可以的。</h6><h6 id="注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象-类名。"><a href="#注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象-类名。" class="headerlink" title="注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。"></a>注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。</h6><h6 id="sizeof-外部类-外部类，和内部类没有任何关系。"><a href="#sizeof-外部类-外部类，和内部类没有任何关系。" class="headerlink" title="sizeof(外部类)=外部类，和内部类没有任何关系。"></a>sizeof(外部类)=外部类，和内部类没有任何关系。</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//B是A的内部类,相当于B是A的友元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(A&amp; a)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a._a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//外部类的普通的私有成员只能通过 对象. 的方式访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _s &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//直接访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a._s &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//对象. 的方式访问</span></span><br><span class="line"><span class="comment">//外部类的静态的私有成员可以通过 对象. 的方式访问 也可以直接访问</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(B&amp; b)</span></span>&#123;</span><br><span class="line"><span class="comment">//外部类对于内部类没有任何优越的访问权限，不能访问内部的私有成(_b)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b._b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _a=<span class="number">10</span>;<span class="comment">//非静态变可以直接在定义的时候初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _s;<span class="comment">//静态变量必须在类外面进行初始化</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::_s = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> A::B b;</span><br><span class="line"> A a;</span><br><span class="line"> b.display(a);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="comment">//B是A的内部类，相当于B是A的友元类</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//若不写作用限定符则会出现访问不了B的现象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(A&amp; a)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a._a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//外部类的普通成员必须通过“对象 . ”的方式去访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _s &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">//外部类的静态成员可以通过“对象 .”的方式去访问</span></span><br><span class="line"><span class="comment">// 也可以直接去访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a._s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(B&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//外部类对于内部类没有任何优越的访问权限，不能访问</span></span><br><span class="line"><span class="comment">//内部类的私有成员</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; b._b &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::_s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A::B a;</span><br><span class="line">a.Print(A());</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h6 id="2-求1-2-3-…-n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A-B-C"><a href="#2-求1-2-3-…-n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A-B-C" class="headerlink" title="2.求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C)."></a>2.求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C).</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Sum()&#123;</span><br><span class="line"></span><br><span class="line">            _sum += _i;</span><br><span class="line"></span><br><span class="line">            ++_i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_solution</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        _sum=<span class="number">0</span>;    <span class="comment">//重新初始化，防止多次调用造成多加的情况</span></span><br><span class="line">        _i=<span class="number">1</span>;</span><br><span class="line">        Sum arr[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">return</span> _sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _sum;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::_i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.Sum_solution(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="输入年月日-判断改天是今年的多少天"><a href="#输入年月日-判断改天是今年的多少天" class="headerlink" title="输入年月日,判断改天是今年的多少天"></a>输入年月日,判断改天是今年的多少天</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> days[<span class="number">13</span>] = &#123; <span class="number">0</span>, <span class="number">31</span>, <span class="number">59</span>, <span class="number">90</span>, <span class="number">120</span>, <span class="number">151</span>, <span class="number">181</span>, <span class="number">212</span>, <span class="number">243</span>, <span class="number">273</span>, <span class="number">304</span>, <span class="number">334</span>, <span class="number">365</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> year, month, day;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; year&gt;&gt; month&gt;&gt; day;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = days[month - <span class="number">1</span>] + day;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (month&gt;<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>))&#123;</span><br><span class="line"></span><br><span class="line">            total += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-再谈构造函数&quot;&gt;&lt;a href=&quot;#1-再谈构造函数&quot; class=&quot;headerlink&quot; title=&quot;1. 再谈构造函数&quot;&gt;&lt;/a&gt;1. 再谈构造函数&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="类与对象" scheme="https://jack-wang128801.github.io/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>c语言内存管理</title>
    <link href="https://jack-wang128801.github.io/2019/03/22/c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://jack-wang128801.github.io/2019/03/22/c语言内存管理/</id>
    <published>2019-03-22T08:57:25.000Z</published>
    <updated>2019-05-05T15:01:28.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：数据在内存中的存储"><a href="#一：数据在内存中的存储" class="headerlink" title="一：数据在内存中的存储"></a>一：数据在内存中的存储</h1><a id="more"></a><h3 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h3><h4 id="1-基本的内存类型："><a href="#1-基本的内存类型：" class="headerlink" title="1.基本的内存类型："></a>1.基本的内存类型：</h4><p>类型的意义<br>1.使用这个类型开辟内存空间的大小（大小决定了使用范围）。<br>2.如何看待内存空间的视角。</p><blockquote><p>char                                       //字符数据类型占1个字节<br>shot                                       //短整形占2个字节<br>int                                          //整形占4个字节<br>long                                       // 长整形占4个字节<br>long long                               //更长的整形占8个字节<br>float                                        //单精度浮点数占4个字节<br>double                                     // 双精度浮点数占8个字节</p></blockquote><h5 id="验证这些类型长度"><a href="#验证这些类型长度" class="headerlink" title="验证这些类型长度"></a>验证这些类型长度</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span> ));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20181111173806517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-整形家族："><a href="#2-整形家族：" class="headerlink" title="2.整形家族："></a>2.整形家族：</h4><blockquote><p>1.char<br>————————&gt;                              unsigned char                      //无符号字符形<br>———————— &gt;                              signed char                          //有符号字符形<br>2.short<br>———————— &gt;                             unsigned  short[int ]           //无符号短整形<br>———————— &gt;                              signed short [int]               //有符号短整形<br>3.int<br>———————— &gt;                             unsigned int                        //无符号整形<br>————————&gt;                               signed  int                          //有符号整形<br>4.long<br>————————&gt;                              unsigned long [int]             //无符号长整形<br> ————————&gt;                               signed  long [int]              //有符号长整形</p></blockquote><h4 id="3-浮点数家族-："><a href="#3-浮点数家族-：" class="headerlink" title="3.浮点数家族 ："></a>3.浮点数家族 ：</h4><blockquote><p>float<br>double</p></blockquote><h4 id="4-构造类型："><a href="#4-构造类型：" class="headerlink" title="4.构造类型："></a>4.构造类型：</h4><blockquote><p>数组类型<br>结构体类型  ————————&gt;        struct<br>枚举类型—————————–&gt;       enum<br>联合类型   —————————&gt;       union</p></blockquote><h4 id="5-指针类型————空类型："><a href="#5-指针类型————空类型：" class="headerlink" title="5.指针类型————空类型："></a>5.指针类型————空类型：</h4><blockquote><p>void不能定义变量【空类型、大小为0】（32位平台下大小为0字节 ，64位平台下为1字节–&gt;但也不能定义变量）<br> 通常用于函数的返回类型、函数的参数、指针类型。<br>void <em>可以定义变量，可以接受任意类型，与其他类型指针一样占四个字节 。（在32位平台下任何类型指针大小都为4个字节）<br>void </em> 不能被截引用</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">void</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>32位平台下void 与void *的大小如图<br><img src="https://img-blog.csdnimg.cn/20181111181051852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="这里是引用"></p><h1 id="二：整形在内存中的存储"><a href="#二：整形在内存中的存储" class="headerlink" title="二：整形在内存中的存储"></a>二：整形在内存中的存储</h1><h4 id="1-一个变量的创建是要在内存中开辟空间的，空间的大小是根据不同的类型决定的。"><a href="#1-一个变量的创建是要在内存中开辟空间的，空间的大小是根据不同的类型决定的。" class="headerlink" title="1.一个变量的创建是要在内存中开辟空间的，空间的大小是根据不同的类型决定的。"></a><strong><em>1.一个变量的创建是要在内存中开辟空间的，空间的大小是根据不同的类型决定的。</em></strong></h4><blockquote><p>计算机中符号数有三种表示方法，既原码、补码、反码。三种表示方法均有符号位和数值位两部分</p></blockquote><ol><li>符号位都是用0表示“正”，用1表示“负”。</li><li>而数值位有三种表示方法</li></ol><table><thead><tr><th>原码</th><th>直接将二进制按照正负数的形式翻译成二进制</th></tr></thead><tbody><tr><td>反码</td><td>将原码的符号位不变，其他位依次按位取反</td></tr><tr><td>补码</td><td>反码+1就得到补码（负数）。 <strong>正数的原、反、补码都相同</strong></td></tr></tbody></table><h4 id="无符号数原、反、补码都相同-amp-正数的原、反、补码都相同。"><a href="#无符号数原、反、补码都相同-amp-正数的原、反、补码都相同。" class="headerlink" title="~~~~  无符号数原、反、补码都相同 &amp; 正数的原、反、补码都相同。"></a>~~~~  无符号数原、反、补码都相同 &amp; 正数的原、反、补码都相同。</h4><h4 id="对于整数来说：数据存放在内存中时，其实存放的是数据的补码。只是正数的原、反、补码都相同。"><a href="#对于整数来说：数据存放在内存中时，其实存放的是数据的补码。只是正数的原、反、补码都相同。" class="headerlink" title="~~~~ 对于整数来说：数据存放在内存中时，其实存放的是数据的补码。只是正数的原、反、补码都相同。"></a>~~~~ 对于整数来说：数据存放在内存中时，其实存放的是数据的补码。只是正数的原、反、补码都相同。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">-20</span>;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> b=<span class="number">-20</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c=<span class="number">-20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a=%d,b=%d,c=%u\n"</span>,a,b,c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://img-blog.csdnimg.cn/20181111201327776.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181111201421334.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181111201443182.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181111202558334.png" alt="在这里插入图片描述"><br>那么为什么-20会被储存成ec ff ff ff 呢？(大小端有介绍)</p></blockquote><h4 id="2-数据存储和读取的差别"><a href="#2-数据存储和读取的差别" class="headerlink" title="2.数据存储和读取的差别"></a>2.数据存储和读取的差别</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">-20</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a+b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u\n"</span>,a+b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运算过程<br><img src="https://img-blog.csdnimg.cn/20181112201821147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><blockquote><p>存储数据时存到内存中的数据<br><img src="https://img-blog.csdnimg.cn/20181112194255960.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>程序运行结果<br><img src="https://img-blog.csdnimg.cn/20181112193912253.png" alt="在这里插入图片描述"></p><h5 id="由上面的程序和内存中储存的数值来看，不管定义的变量是什么类型的其往计算机中储存数据时存入的都是数据本身的反码，只是在取出的时候改变了它们的类型。"><a href="#由上面的程序和内存中储存的数值来看，不管定义的变量是什么类型的其往计算机中储存数据时存入的都是数据本身的反码，只是在取出的时候改变了它们的类型。" class="headerlink" title="由上面的程序和内存中储存的数值来看，不管定义的变量是什么类型的其往计算机中储存数据时存入的都是数据本身的反码，只是在取出的时候改变了它们的类型。"></a>由上面的程序和内存中储存的数值来看，不管定义的变量是什么类型的其往计算机中储存数据时存入的都是数据本身的反码，只是在取出的时候改变了它们的类型。</h5></blockquote><h4 id="3-在计算机中读取整形数据时的规则"><a href="#3-在计算机中读取整形数据时的规则" class="headerlink" title="3.在计算机中读取整形数据时的规则"></a>3.在计算机中读取整形数据时的规则</h4><blockquote><p><img src="https://img-blog.csdnimg.cn/20181114121614420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h4 id="4-整形的提升"><a href="#4-整形的提升" class="headerlink" title="4.整形的提升"></a>4.整形的提升</h4><blockquote><p><img src="https://img-blog.csdnimg.cn/20181114000437198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h3 id="下面拿char-类型转成-int形的提升来看"><a href="#下面拿char-类型转成-int形的提升来看" class="headerlink" title="下面拿char 类型转成 int形的提升来看"></a>下面拿char 类型转成 int形的提升来看</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a=<span class="number">-3</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b=<span class="number">-3</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c=a;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> d=b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u\n"</span>,c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u\n"</span>,d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure><h5 id="监视结果"><a href="#监视结果" class="headerlink" title="监视结果"></a>监视结果</h5><blockquote><p><img src="https://img-blog.csdnimg.cn/20181114000845339.png" alt="在这里插入图片描述"><br>将 a 赋给 c 时，y由于涉及到提升比特位的缘故。所以将char形 -3 的反码1111 1101提升成了int 类型的1111 1111 1111 1111 1111 1111 1111 1101（十进制的4294967293）因为原数据类型为有符号数所以按符号位补充；<br><img src="https://img-blog.csdnimg.cn/20181114001811311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将 b 赋给 d 时，由于涉及到提升比特位的缘故。所以将unsigned char形 -3 的反码1111 1101提升成了int 类型的0000 0000 0000 0000 0000 0000  1111 1101（十进制的253）因为原数据类型为无符号整数所以拿“0”补充；</p></blockquote><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><blockquote><p><img src="https://img-blog.csdnimg.cn/20181114000644552.png" alt="在这里插入图片描述"></p></blockquote><ul><li><h1 id="三：大端、小端"><a href="#三：大端、小端" class="headerlink" title="三：大端、小端"></a>三：大端、小端</h1><ul><li>地址有高低地址之分</li><li>数据有高低权位之别</li></ul></li></ul><blockquote><ul><li>1.大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；<ul><li>2.小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。</li></ul></li></ul></blockquote><h4 id="那么为什么会有大端、小端的储存方式呢？"><a href="#那么为什么会有大端、小端的储存方式呢？" class="headerlink" title="那么为什么会有大端、小端的储存方式呢？"></a>那么为什么会有大端、小端的储存方式呢？</h4><blockquote><p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p><p>例如：一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。</p><h2 id="在32位平台下"><a href="#在32位平台下" class="headerlink" title="在32位平台下"></a>在32位平台下</h2></blockquote>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure><p>   如下图：</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20181111205729985.png" alt="在这里插入图片描述"></p></blockquote><p>   <strong>20按16进制储存时应该为00 00 00 14，但是电脑却储存成14 00 00 00。原因就是32位平台采用的是小端的储存方式。</strong></p><h2 id="既数值权位小的数据储存在低位置端为小端储存方式"><a href="#既数值权位小的数据储存在低位置端为小端储存方式" class="headerlink" title="既数值权位小的数据储存在低位置端为小端储存方式"></a>既数值权位小的数据储存在低位置端为小端储存方式</h2><h1 id="四：浮点数在内存中的储存"><a href="#四：浮点数在内存中的储存" class="headerlink" title="四：浮点数在内存中的储存"></a>四：浮点数在内存中的储存</h1><p>   <img src="https://img-blog.csdnimg.cn/20181111205210232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>例如：十进制的6.0，写成二进制是 110.0 ，相当于 1.10×2^2 。 那么，按照上面V的格式，可以得出s=0，M=1.10，E=2。<br>而十进制的-6.0，写成二进制是 -110.0 ，相当于 -1.10×2^2 。 那么，按照上面V的格式，可以得出s=1，M=1.10，E=2。</p></blockquote><h3 id="2-对于32位浮点数，最高的1位是符号位s-接着的8位是指数E，剩下的23位为有效数字M。"><a href="#2-对于32位浮点数，最高的1位是符号位s-接着的8位是指数E，剩下的23位为有效数字M。" class="headerlink" title="2.对于32位浮点数，最高的1位是符号位s,接着的8位是指数E，剩下的23位为有效数字M。"></a>2.对于32位浮点数，最高的1位是符号位s,接着的8位是指数E，剩下的23位为有效数字M。</h3><p>   <img src="https://img-blog.csdnimg.cn/20181111215516798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-对于64位浮点数，最高的1位是符号位s-接着的11位是指数E，剩下的52位为有效数字M"><a href="#3-对于64位浮点数，最高的1位是符号位s-接着的11位是指数E，剩下的52位为有效数字M" class="headerlink" title="3.对于64位浮点数，最高的1位是符号位s,接着的11位是指数E，剩下的52位为有效数字M."></a>3.对于64位浮点数，最高的1位是符号位s,接着的11位是指数E，剩下的52位为有效数字M.</h3><p>   <img src="https://img-blog.csdnimg.cn/20181111215919722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><strong>有效数字M和指数E，还有一些特别规定。 前面说过， 1≤M&lt;2 ，也就是说，M可以写成 1.xxxxxx的形式，其中xxxxxx表示小数部分.在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。</strong></p></blockquote><h3 id="至于指数E"><a href="#至于指数E" class="headerlink" title="至于指数E"></a>至于指数E</h3><pre><code>首先，E为一个无符号整数（unsigned int） 这意味着，如果E为8位，它的取值范围为0~255；如果E为11位， 它的取值范围为0~2047。但是，我们知道，科学计数法 中的E是可以出现负数的，存入内存 时E的真实值必须再加上一个中间数，对于8位的E， 这个中间数是127；对于11位的E，这个中间数是1023。比如：2^10的E是10，所以保存成32位浮点数时，必须 保存成10+127=137，即10001001。#### 如表例题：</code></pre><table><thead><tr><th>存-7时</th><th>存入120（-7+127=120） ，取时取出-7（120-127=-7）</th></tr></thead><tbody><tr><td>存入0时</td><td>存入127(0+127=127)，取时取出0（127-127=0）</td></tr><tr><td>总结</td><td>存时浮点数+127,取时浮点数-127</td></tr></tbody></table><pre><code>### 指数E还可以再分成三种情况：</code></pre><h3 id="1-E不全为0或不全为1"><a href="#1-E不全为0或不全为1" class="headerlink" title="1.E不全为0或不全为1"></a>1.E不全为0或不全为1</h3><blockquote><p>这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M加上第一位的1。 比如： 0.5（1/2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则1.0*2^(-1)，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到2300000000000000000000000，则其二进制表示形式为:</p><h3 id="2-E全为0（浮点数的0值，不能直接与0比较）"><a href="#2-E全为0（浮点数的0值，不能直接与0比较）" class="headerlink" title="2.E全为0（浮点数的0值，不能直接与0比较）"></a>2.E全为0（浮点数的0值，不能直接与0比较）</h3><p>这时，浮点数的指数E等于1-127（或者1-1023）即为真实值， 有效数字M不再加上第一位的1，而是还原0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p><h3 id="3-E全为1（S为0，E全为1，则为float表示的最大正数）"><a href="#3-E全为1（S为0，E全为1，则为float表示的最大正数）" class="headerlink" title="3.E全为1（S为0，E全为1，则为float表示的最大正数）"></a>3.E全为1（S为0，E全为1，则为float表示的最大正数）</h3><p>这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：数据在内存中的存储&quot;&gt;&lt;a href=&quot;#一：数据在内存中的存储&quot; class=&quot;headerlink&quot; title=&quot;一：数据在内存中的存储&quot;&gt;&lt;/a&gt;一：数据在内存中的存储&lt;/h1&gt;
    
    </summary>
    
      <category term="C" scheme="https://jack-wang128801.github.io/categories/C/"/>
    
    
      <category term="数据的存储" scheme="https://jack-wang128801.github.io/tags/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>c++ 类与对象(中)</title>
    <link href="https://jack-wang128801.github.io/2019/03/20/C%20++%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E4%B8%AD/"/>
    <id>https://jack-wang128801.github.io/2019/03/20/C ++类与对象-中/</id>
    <published>2019-03-20T13:06:58.000Z</published>
    <updated>2019-05-05T15:00:43.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><a id="more"></a><h4 id="1-类的6个默认成员函数"><a href="#1-类的6个默认成员函数" class="headerlink" title="1.类的6个默认成员函数"></a>1.类的6个默认成员函数</h4><blockquote><p>1.1 构造函数</p><p>1.2 拷贝函数构造</p><p>1.3 析构函数   </p><p>1.4 赋值操作符重载                       </p><p>1.5 取地址操作符重载                        </p><p>1.6 const修饰的取地址操作符重载                      </p></blockquote><h4 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h4><blockquote><p><img src="https://img-blog.csdnimg.cn/20190320211328591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h5 id="2-1-概念：不是创建，某种意义上来说是初始化"><a href="#2-1-概念：不是创建，某种意义上来说是初始化" class="headerlink" title="2.1 概念：不是创建，某种意义上来说是初始化"></a>2.1 概念：不是创建，某种意义上来说是初始化</h5><blockquote><ul><li>对于以下的日期类：</li></ul></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span>&#125;;</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt;_year&lt;&lt; <span class="string">"-"</span> &lt;&lt;_month &lt;&lt; <span class="string">"-"</span>&lt;&lt; _day &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Date d1,d2;</span><br><span class="line"> d1.SetDate(<span class="number">2018</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"> d1.Display();</span><br><span class="line"> </span><br><span class="line"> Date d2;</span><br><span class="line"> d2.SetDate(<span class="number">2018</span>,<span class="number">7</span>,<span class="number">1</span>);</span><br><span class="line"> d2.Display();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于Date类，可以通过SetDate公有的方法给对象设置内容，但是如果每次创建对象都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？<br>构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次</p></blockquote><h5 id="2-2-特征"><a href="#2-2-特征" class="headerlink" title="2.2. 特征"></a>2.2. 特征</h5><blockquote><p>构造函数是特殊的成员函数，需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是构造函数的主要任务并不是开空间创建对象，而是初始化对象。</p></blockquote><blockquote><ul><li>其特征如下：<ul><li style="list-style: none"><input type="checkbox"> 2.2.1. 函数名与类名相同。</li><li style="list-style: none"><input type="checkbox"> 2.2.2. 无返回值。</li><li style="list-style: none"><input type="checkbox"> 2.2.3. 对象实例化时编译器自动调用对应的构造函数。</li><li style="list-style: none"><input type="checkbox"> 2.2.4. 构造函数可以重载。</li><li style="list-style: none"><input type="checkbox"> 2.2.5. 构造函数可以在类中定义，也可以在类外定义</li></ul></li></ul></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Date()&#123; <span class="comment">//构造函数，初始化了被它定义的对象</span></span><br><span class="line">_year = <span class="number">2019</span>;</span><br><span class="line">_month = <span class="number">3</span>;</span><br><span class="line">_day = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">Date1()&#123;&#125;<span class="comment">//类里面声明，在类外面定义</span></span><br><span class="line">Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)&#123;</span><br><span class="line"><span class="comment">//函数重载,函数名相同,参数不同</span></span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _year &lt;&lt; <span class="string">"-"</span> &lt;&lt; _month &lt;&lt; <span class="string">"-"</span> &lt;&lt; _day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line">Date :: Date1()&#123;  <span class="comment">//构造函数可以在类外面定义</span></span><br><span class="line">    _year = <span class="number">2019</span>;</span><br><span class="line">_month = <span class="number">3</span>;</span><br><span class="line">_day = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d1;<span class="comment">//期望d1一出来就被初始化</span></span><br><span class="line">d1.Print();</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2019</span>,<span class="number">3</span>,<span class="number">20</span>)</span></span>;   <span class="comment">//函数的重载</span></span><br><span class="line">d2.Print();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Date();<span class="comment">//类里面声明，在类外面定义</span></span><br><span class="line">Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)&#123;</span><br><span class="line"><span class="comment">//函数重载,函数名相同,参数不同</span></span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _year &lt;&lt; <span class="string">"-"</span> &lt;&lt; _month &lt;&lt; <span class="string">"-"</span> &lt;&lt; _day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line">Date :: Date()&#123;  <span class="comment">//构造函数可以在类外面定义</span></span><br><span class="line">    _year = <span class="number">2019</span>;</span><br><span class="line">_month = <span class="number">3</span>;</span><br><span class="line">_day = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2019</span>,<span class="number">3</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">d2.Print();</span><br><span class="line"></span><br><span class="line">    Date d3; <span class="comment">//构造函数可以在类中定义，也可以在类外定义</span></span><br><span class="line">    d3.Print();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 2.2.6 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成</li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> // 如果用户显式定义了构造函数，编译器将不再生成</span></span><br><span class="line"><span class="comment"> Date (int year, int month, int day)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> _year = year;</span></span><br><span class="line"><span class="comment"> _month = month;</span></span><br><span class="line"><span class="comment"> _day = day;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器生成的默认构造函数</span></span><br><span class="line"> Date d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 2.2.7.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一</li><li style="list-style: none"><input type="checkbox"> 个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为</li><li><p>[ ] 是默认成员函数。</p><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date()&#123;</span><br><span class="line"> _year = <span class="number">1900</span> ;</span><br><span class="line"> _month = <span class="number">1</span> ;</span><br><span class="line"> _day = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Date (<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)&#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"> <span class="keyword">int</span> _year ;</span><br><span class="line"> <span class="keyword">int</span> _month ;</span><br><span class="line"> <span class="keyword">int</span> _day ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以下测试函数能通过编译吗？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Date d1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 2.2.8 关于编译器生成的默认成员函数，很多童鞋会有疑惑：在我们不实现构造函数的情况下，</li><li style="list-style: none"><input type="checkbox"> 编译器会生成</li></ul></li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Time()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> _hour = <span class="number">0</span>;</span><br><span class="line"> _minute = <span class="number">0</span>;</span><br><span class="line"> _second = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _hour;</span><br><span class="line"> <span class="keyword">int</span> _minute;</span><br><span class="line"> <span class="keyword">int</span> _second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// 基本类型(内置类型)</span></span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line"> <span class="comment">// 自定义类型</span></span><br><span class="line"> Time <span class="keyword">_t</span>;</span><br><span class="line"> <span class="comment">//默认生成的构造函数对于 1 不做处理，对于 2 默认调用无参构造初始化</span></span><br><span class="line"> <span class="comment">//1.基本类型：int 、char ....</span></span><br><span class="line"> <span class="comment">//2.自定义类型：class/struct定义的类型。。。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Date d;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>默认的构造函数。但是看起来默认构造函数又没什么用？d对象调用了编译器生成的默认构造函数，但是d对象year/month/_day，依旧是随机值。也就说在这里编译器生成的默认构造函数并没有什么卵用？</li></ul></blockquote><blockquote><ul><li>解答：C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语法已经定义好的类型：如int/char…，自定义类型就是我们使用class/struct/union自己定义的类型，看看下面的程序，就会发现编译器生成默认的构造函数会对自定类型成员_t调用的它的默认成员函数</li></ul></blockquote><h4 id="3-析构函数"><a href="#3-析构函数" class="headerlink" title="3.析构函数"></a>3.析构函数</h4><h5 id="3-1-概念："><a href="#3-1-概念：" class="headerlink" title="3.1 概念："></a>3.1 概念：</h5><blockquote><ul><li>析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器<ul><li>完成的。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作</li></ul></li></ul></blockquote><h5 id="3-2-特性"><a href="#3-2-特性" class="headerlink" title="3.2. 特性"></a>3.2. 特性</h5><ul><li style="list-style: none"><input type="checkbox"> 析构函数是特殊的成员函数。</li><li style="list-style: none"><input type="checkbox"> 其特征如下<h6 id="3-2-1-析构函数名是在类名前加上字符-。"><a href="#3-2-1-析构函数名是在类名前加上字符-。" class="headerlink" title="3.2.1. 析构函数名是在类名前加上字符  ~ 。"></a>3.2.1. 析构函数名是在类名前加上字符  ~ 。</h6><h6 id="3-2-2-无参数无返回值。"><a href="#3-2-2-无参数无返回值。" class="headerlink" title="3.2.2. 无参数无返回值。"></a>3.2.2. 无参数无返回值。</h6><h6 id="3-2-3-一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。"><a href="#3-2-3-一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。" class="headerlink" title="3.2.3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。"></a>3.2.3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。</h6><h6 id="3-2-4-对象生命周期结束时，C-编译系统系统自动调用析构函数"><a href="#3-2-4-对象生命周期结束时，C-编译系统系统自动调用析构函数" class="headerlink" title="3.2.4. 对象生命周期结束时，C++编译系统系统自动调用析构函数."></a>3.2.4. 对象生命周期结束时，C++编译系统系统自动调用析构函数.</h6><blockquote><ul><li>析构函数建造时按定义的相反顺序建造函数</li><li>对于内置类型来说没有定义析构函数的话，编译器默认去掉用析构函数</li></ul></blockquote></li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> SeqList (<span class="keyword">int</span> capacity = <span class="number">10</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _pData = (DataType*)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(DataType));</span><br><span class="line"> assert(_pData);</span><br><span class="line"> </span><br><span class="line"> _size = <span class="number">0</span>;</span><br><span class="line"> _capacity = capacity;</span><br><span class="line"> &#125;</span><br><span class="line"> ~SeqList()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (_pData)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">free</span>(_pData ); <span class="comment">// 释放堆上的空间</span></span><br><span class="line"> _pData = <span class="literal">NULL</span>; <span class="comment">// 将指针置为空</span></span><br><span class="line"> _capacity = <span class="number">0</span>;</span><br><span class="line"> _size = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"> <span class="keyword">int</span>* _pData ;</span><br><span class="line"> <span class="keyword">size_t</span> _size;</span><br><span class="line"> <span class="keyword">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a>4. 拷贝构造函数</h4><h5 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1   概念"></a>4.1   概念</h5><ul><li style="list-style: none"><input type="checkbox"> 构造函数：只是单个形参，该形参是对本类类型对象的引用(一般常用const 修饰)，在已存在的</li><li style="list-style: none"><input type="checkbox"> 类型对象创建新对象时由编译器自动调用</li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)&#123;</span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _year &lt;&lt; <span class="string">"-"</span> &lt;&lt; _month &lt;&lt; <span class="string">"-"</span> &lt;&lt; _day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Date()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Date"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以下测试函数能通过编译吗？</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d1;</span><br><span class="line">d1.print();</span><br><span class="line"></span><br><span class="line"><span class="function">Date  <span class="title">d2</span><span class="params">(d1)</span></span>;   <span class="comment">//拷贝构造</span></span><br><span class="line">d2.print();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-特征"><a href="#4-2-特征" class="headerlink" title="4.2 特征"></a>4.2 特征</h5><h6 id="4-2-1-拷贝构造函数是构造函数的一个重载形式"><a href="#4-2-1-拷贝构造函数是构造函数的一个重载形式" class="headerlink" title="4.2.1 拷贝构造函数是构造函数的一个重载形式"></a>4.2.1 拷贝构造函数是构造函数的一个重载形式</h6><h6 id="4-2-2-拷贝构造函数的参数只有一个且必须使用引用传参，使用传参方式会引发无穷递归调用"><a href="#4-2-2-拷贝构造函数的参数只有一个且必须使用引用传参，使用传参方式会引发无穷递归调用" class="headerlink" title="4.2.2 拷贝构造函数的参数只有一个且必须使用引用传参，使用传参方式会引发无穷递归调用"></a>4.2.2 拷贝构造函数的参数只有一个且必须使用引用传参，使用传参方式会引发无穷递归调用</h6><blockquote><p><img src="https://img-blog.csdnimg.cn/20190322192703218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="4-2-3-若未显示定义，系统生成默认的拷贝构造函数。-默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝"><a href="#4-2-3-若未显示定义，系统生成默认的拷贝构造函数。-默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝" class="headerlink" title="4.2.3 若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝"></a>4.2.3 若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝</h6><h6 id="4-2-4-那么编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。"><a href="#4-2-4-那么编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。" class="headerlink" title="4.2.4  那么编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。"></a>4.2.4  那么编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。</h6></blockquote><ul><li style="list-style: none"><input type="checkbox"> 代码示例<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Date(<span class="keyword">int</span> year = <span class="number">2019</span>, <span class="keyword">int</span> month = <span class="number">3</span>, <span class="keyword">int</span> day = <span class="number">10</span>)&#123;</span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _year &lt;&lt; <span class="string">"-"</span> &lt;&lt; _month &lt;&lt; <span class="string">"-"</span> &lt;&lt; _day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Date ( Date&amp; d)&#123;   <span class="comment">//拷贝构造出现问题</span></span><br><span class="line">_year = d._year;</span><br><span class="line">_month = d._month;</span><br><span class="line">_day = d._day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d1;</span><br><span class="line">d1.Print();</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">30</span>)</span></span>;<span class="comment">// 特征2</span></span><br><span class="line">d2.Print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d3</span><span class="params">(<span class="number">2019</span>)</span></span>;</span><br><span class="line">d3.Print();</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d4</span><span class="params">(d2)</span></span>;    <span class="comment">//拷贝构造--&gt;浅拷贝(按字节进行拷贝)</span></span><br><span class="line">d4.Print();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> String(<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"jack"</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(_str, str);</span><br><span class="line"> &#125;</span><br><span class="line"> ~String()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"~String()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">free</span>(_str);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">char</span>* _str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"> <span class="function">String <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序奔溃的原因是在进行浅拷贝时，将s1和s2的指针指向了同一片空间，在释放时空间</span></span><br><span class="line"><span class="comment">//已经倍s2释放了，所以s1再去释放这块空间就会出错</span></span><br></pre></td></tr></table></figure><h4 id="5-赋值运算符重载"><a href="#5-赋值运算符重载" class="headerlink" title="5.赋值运算符重载"></a>5.赋值运算符重载</h4><h5 id="5-1-运算符重载"><a href="#5-1-运算符重载" class="headerlink" title="5.1 运算符重载"></a>5.1 运算符重载</h5><blockquote><p>C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。<br>函数名字为：关键字operator后面接需要重载的运算符符号。函数原型：返回值类型 operator操作符(参数列表)</p></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的operator==</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里会发现运算符重载成全局的就需要成员变量是共有的，那么问题来了，封装性如何保证？</span></span><br><span class="line"><span class="comment">// 这里其实可以用我们后面学习的友元解决，或者干脆重载成成员函数。</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Date&amp; d1, <span class="keyword">const</span> Date&amp; d2)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> d1._year == d2._year;</span><br><span class="line"> &amp;&amp; d1._month == d2._month</span><br><span class="line"> &amp;&amp; d1._day == d2._day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">26</span>)</span></span>;</span><br><span class="line"> <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(d1 == d2)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//可读性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// bool operator==(Date* this, const Date&amp; d2) //增加可读性</span></span><br><span class="line"> <span class="comment">// 这里需要注意的是，左操作数是this指向的调用函数的对象</span></span><br><span class="line"> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Date&amp; d2)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> _year == d2._year</span><br><span class="line"> &amp;&amp; _month == d2._month</span><br><span class="line"> &amp;&amp; _day == d2._day;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">26</span>)</span></span>;</span><br><span class="line"> <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(d1 == d2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="keyword">operator</span>==(d1,d2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><h6 id="5-1-1-不能通过连接其他符号来创建新的操作符：比如operator"><a href="#5-1-1-不能通过连接其他符号来创建新的操作符：比如operator" class="headerlink" title="5.1.1 不能通过连接其他符号来创建新的操作符：比如operator@"></a>5.1.1 不能通过连接其他符号来创建新的操作符：比如operator@</h6><h6 id="5-1-2-重载操作符必须有一个类类型或者枚举类型的操作数"><a href="#5-1-2-重载操作符必须有一个类类型或者枚举类型的操作数" class="headerlink" title="5.1.2 重载操作符必须有一个类类型或者枚举类型的操作数"></a>5.1.2 重载操作符必须有一个类类型或者枚举类型的操作数</h6><h6 id="5-1-3-用于内置类型的操作符，其含义不能改变，例如：内置的整型-，不能改变其含义"><a href="#5-1-3-用于内置类型的操作符，其含义不能改变，例如：内置的整型-，不能改变其含义" class="headerlink" title="5.1.3 用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义"></a>5.1.3 用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义</h6><h6 id="5-1-4-作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参"><a href="#5-1-4-作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参" class="headerlink" title="5.1.4 作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参"></a>5.1.4 作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参</h6><h6 id="5-1-5-lt-gt-lt-gt-lt-sizeof-gt-lt-gt-lt-gt-注意以上5个运算符不能重载。这个经常在笔试选择题中出现"><a href="#5-1-5-lt-gt-lt-gt-lt-sizeof-gt-lt-gt-lt-gt-注意以上5个运算符不能重载。这个经常在笔试选择题中出现" class="headerlink" title="5.1.5 &lt; .* &gt;&lt; ::  &gt; &lt; sizeof  &gt; &lt;  ?:  &gt;&lt; . &gt;注意以上5个运算符不能重载。这个经常在笔试选择题中出现"></a>5.1.5 &lt; .* &gt;&lt; ::  &gt; &lt; sizeof  &gt; &lt;  ?:  &gt;&lt; . &gt;注意以上5个运算符不能重载。这个经常在笔试选择题中出现</h6><h5 id="5-2-赋值运算符重载"><a href="#5-2-赋值运算符重载" class="headerlink" title="5.2. 赋值运算符重载"></a>5.2. 赋值运算符重载</h5><p>赋值运算符主要有四点：</p><h6 id="5-2-1-参数类型"><a href="#5-2-1-参数类型" class="headerlink" title="5.2.1. 参数类型"></a>5.2.1. 参数类型</h6><h6 id="5-2-2-返回值"><a href="#5-2-2-返回值" class="headerlink" title="5.2.2. 返回值"></a>5.2.2. 返回值</h6><h6 id="5-2-3-检测是否自己给自己赋值"><a href="#5-2-3-检测是否自己给自己赋值" class="headerlink" title="5.2.3. 检测是否自己给自己赋值"></a>5.2.3. 检测是否自己给自己赋值</h6><h6 id="5-2-4-返回-this"><a href="#5-2-4-返回-this" class="headerlink" title="5.2.4. 返回*this"></a>5.2.4. 返回*this</h6><h6 id="5-2-5-一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝"><a href="#5-2-5-一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝" class="headerlink" title="5.2.5. 一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝"></a>5.2.5. 一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝</h6><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//d2=d1</span></span><br><span class="line"><span class="comment">//d2.operator(d1)</span></span><br><span class="line"><span class="comment">//d2.operator(&amp;d2,d1)</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Date&amp; d)&#123;  <span class="comment">//默认含有第一个参数的地址，</span></span><br><span class="line"><span class="comment">//已经被this指针所指代</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;d)&#123;   <span class="comment">//防止自己给自己传值</span></span><br><span class="line"><span class="keyword">this</span>-&gt;_year = d._year;</span><br><span class="line"><span class="keyword">this</span>-&gt;_month = d._month;</span><br><span class="line"><span class="keyword">this</span>-&gt;_day = d._day;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Date operator=(const Date&amp; d)&#123; //有返回值</span></span><br><span class="line"><span class="comment">if (this != &amp;d)&#123;</span></span><br><span class="line"><span class="comment">this-&gt;_year = d._year;</span></span><br><span class="line"><span class="comment">this-&gt;_month = d._month;</span></span><br><span class="line"><span class="comment">this-&gt;_day = d._day;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return *this;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _year &lt;&lt; <span class="string">"-"</span> &lt;&lt; _month &lt;&lt; <span class="string">"-"</span> &lt;&lt; _day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>,<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2019</span>,<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">d1.print();</span><br><span class="line"><span class="comment">// 这里d1调用的编译器生成operator=完成拷贝，d2和d1的值也是一样的。</span></span><br><span class="line"><span class="function">Date <span class="title">d3</span><span class="params">(d1)</span></span>;  <span class="comment">//拷贝构造</span></span><br><span class="line">d1 = d2;  <span class="comment">//赋值运算符的用运</span></span><br><span class="line"></span><br><span class="line">d3.print();</span><br><span class="line">d1.print();</span><br><span class="line"><span class="comment">//用运这个表达式需要调用函数Date operator=(const Date&amp; d)</span></span><br><span class="line"><span class="comment">//d3 = d2 = d1;//被转换成 d3=(d2.oprator=(&amp;d2,d1))</span></span><br><span class="line"><span class="comment">//d3.print();</span></span><br><span class="line">   <span class="comment">//Date d4 = d1; //拷贝构造，将已知的值赋给创建的变量。</span></span><br><span class="line">  <span class="comment">//运算符重载</span></span><br><span class="line">  <span class="comment">//函数重载   两者没有任何关系</span></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果<br>不加<br>d3 = d2 = d1;<img src="https://img-blog.csdnimg.cn/20190322203217720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>加上d3 = d2 = d1;<br><img src="https://img-blog.csdnimg.cn/20190322203402120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date <span class="keyword">operator</span>-(<span class="keyword">int</span> day);<span class="comment">//日期减去日期</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> Date&amp; day);  <span class="comment">//返回天数</span></span><br><span class="line"><span class="comment">//两者而言即是函数重载，又是运算符重载</span></span><br></pre></td></tr></table></figure><blockquote><p>简单整理：<br>封装：管理<br>构造、析构：初始化、清理<br>拷贝构造、operator= ： 复制</p></blockquote><blockquote><ul><li>那么编译器生成的默认赋值重载函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。那么下面的类呢？验证一下试试？</li></ul></blockquote><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> String(<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"jack"</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(_str, str);</span><br><span class="line"> &#125;</span><br><span class="line"> ~String()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"~String()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">free</span>(_str);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">char</span>* _str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"> <span class="function">String <span class="title">s2</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"> s1 = s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;类与对象&quot;&gt;&lt;a href=&quot;#类与对象&quot; class=&quot;headerlink&quot; title=&quot;类与对象&quot;&gt;&lt;/a&gt;类与对象&lt;/h3&gt;
    
    </summary>
    
      <category term="Cpp" scheme="https://jack-wang128801.github.io/categories/Cpp/"/>
    
    
      <category term="类与对象(中)" scheme="https://jack-wang128801.github.io/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--双向链表</title>
    <link href="https://jack-wang128801.github.io/2019/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://jack-wang128801.github.io/2019/03/19/数据结构-双向链表/</id>
    <published>2019-03-19T14:05:31.000Z</published>
    <updated>2019-05-05T15:02:48.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DList-h"><a href="#DList-h" class="headerlink" title="DList.h"></a>DList.h</h3><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DLDataType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链表的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DListNode</span>&#123;</span></span><br><span class="line">DLDataType value;         <span class="comment">//头节点中的value没有意义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DListNode</span> *<span class="title">prev</span>;</span>  <span class="comment">//指向该节点的前一个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DListNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向该节点的后一个结点</span></span><br><span class="line">&#125;DListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DList</span>&#123;</span></span><br><span class="line">DListNode *head;    <span class="comment">//指向双向链表的头节点</span></span><br><span class="line">&#125;DList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListInit</span><span class="params">(DList *dlist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="comment">//1.清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListClear</span><span class="params">(DList *dlist)</span></span>;</span><br><span class="line"><span class="comment">//2.彻底的清空链表，彻底销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListDestory</span><span class="params">(DList *dlist)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//申请空间的函数</span></span><br><span class="line"><span class="function">DListNode * <span class="title">DListBuyNode</span><span class="params">(DLDataType value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增</span></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DListPushFront</span><span class="params">(DList *dlist,DLDataType value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPushBack</span><span class="params">(DList *dlist, DLDataType value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPopFront</span><span class="params">(DList *dlist,DLDataType value)</span></span>;</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPopBack</span><span class="params">(DList *dlist, DLDataType value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"></span><br><span class="line"><span class="function">DListNode * <span class="title">DListFind</span><span class="params">(DList *dlist,DLDataType value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插</span></span><br><span class="line"><span class="comment">// 在pos的前面进行插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListInsert</span><span class="params">(DListNode *pos, DLDataType value)</span></span>;</span><br><span class="line"><span class="comment">// 删除pos位置的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListErase</span><span class="params">(DListNode *pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListRemove</span><span class="params">(DList * dlsit, DLDataType value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPrint</span><span class="params">(<span class="keyword">const</span> DList *dlist)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="DList-c"><a href="#DList-c" class="headerlink" title="DList.c"></a>DList.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"DList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListInit</span><span class="params">(DList *dlist)</span></span>&#123;</span><br><span class="line">dlist-&gt;head = DListBuyNode(<span class="number">0</span>);<span class="comment">//0没有实际意义，这里指头结点</span></span><br><span class="line"></span><br><span class="line">dlist-&gt;head-&gt;next = dlist-&gt;head;</span><br><span class="line">dlist-&gt;head-&gt;prev = dlist-&gt;head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="comment">//1.清空链表</span></span><br><span class="line"><span class="comment">//保留链表的头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListClear</span><span class="params">(DList *dlist)</span></span>&#123;</span><br><span class="line">DListNode *cur, *next;</span><br><span class="line">cur = dlist-&gt;head -&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != dlist-&gt;head)&#123;</span><br><span class="line">next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">dlist-&gt;head-&gt;next = dlist-&gt;head-&gt;prev = dlist-&gt;head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//彻底的清空链表，彻底销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListDestory</span><span class="params">(DList *dlist)</span></span>&#123;</span><br><span class="line">DListClear(dlist);</span><br><span class="line"><span class="built_in">free</span>(dlist-&gt;head);</span><br><span class="line">dlist-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请新结点</span></span><br><span class="line"><span class="function">DListNode * <span class="title">DListBuyNode</span><span class="params">(DLDataType value)</span></span>&#123;</span><br><span class="line">DListNode *new_node = (DListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DListNode));</span><br><span class="line">new_node-&gt;value = value;</span><br><span class="line">new_node-&gt;next = new_node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增</span></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DListPushFront</span><span class="params">(DList *dlist, DLDataType value)</span></span>&#123;</span><br><span class="line">DListNode *node = DListBuyNode(value);</span><br><span class="line">node-&gt;prev = dlist-&gt;head;</span><br><span class="line">node-&gt;next = dlist-&gt;head-&gt;next;</span><br><span class="line">dlist-&gt;head-&gt;next-&gt;prev = node;</span><br><span class="line">dlist-&gt;head-&gt;next = node;</span><br><span class="line"><span class="comment">//特殊情况，空链表是没有问题的</span></span><br><span class="line"><span class="comment">//DListInsert(dlist-&gt;head-&gt;next,value)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPushBack</span><span class="params">(DList *dlist,DLDataType value)</span></span>&#123;</span><br><span class="line">DListNode *node = DListBuyNode(value);</span><br><span class="line"></span><br><span class="line">node-&gt;prev = dlist-&gt;head-&gt;prev;</span><br><span class="line">node-&gt;next = dlist-&gt;head;</span><br><span class="line">node-&gt;prev-&gt;next = node;</span><br><span class="line">dlist-&gt;head-&gt;prev=node;</span><br><span class="line">    <span class="comment">//DListInsert(dlist-&gt;head,value)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPopFront</span><span class="params">(DList *dlist, DLDataType value)</span></span>&#123;</span><br><span class="line">assert(dlist-&gt;head-&gt;next!=dlist-&gt;head);</span><br><span class="line">DListNode *cur = dlist-&gt;head-&gt;next; <span class="comment">//指向头节点的下一结点 </span></span><br><span class="line"> dlist-&gt;head-&gt;next= cur-&gt;next; <span class="comment">//</span></span><br><span class="line"> cur-&gt;next-&gt;prev = dlist-&gt;head;</span><br><span class="line"> <span class="built_in">free</span>(cur);</span><br><span class="line"> <span class="comment">//空链表也适用</span></span><br><span class="line"> <span class="comment">//DListErase(dlist-&gt;head-&gt;next)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPopBack</span><span class="params">(DList *dlist, DLDataType value)</span></span>&#123;</span><br><span class="line">assert(dlist-&gt;head-&gt;next!=dlist-&gt;head);</span><br><span class="line">DListNode *old_node = dlist-&gt;head-&gt;prev;</span><br><span class="line">old_node-&gt;prev-&gt;next = dlist-&gt;head; <span class="comment">//dlist-&gt;head-&gt;prev-&gt;prev-&gt;next</span></span><br><span class="line">old_node-&gt;next-&gt;prev = old_node-&gt;prev;<span class="comment">//dlist-&gt;head-&gt;prev;</span></span><br><span class="line"><span class="built_in">free</span>(old_node);</span><br><span class="line"><span class="comment">//DListErase(dlist-&gt;head-&gt;prev)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function">DListNode * <span class="title">DListFind</span><span class="params">(DList *dlist, DLDataType value)</span></span>&#123;</span><br><span class="line">DListNode *cur;</span><br><span class="line"><span class="keyword">for</span> (cur = dlist-&gt;head-&gt;next; cur != dlist-&gt;head; cur = cur-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;value = value)&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插</span></span><br><span class="line"><span class="comment">// 在pos的前面进行插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListInsert</span><span class="params">(DListNode *pos, DLDataType value)</span></span>&#123;</span><br><span class="line">DListNode *node = DListBuyNode(value);</span><br><span class="line">node-&gt;next = pos;</span><br><span class="line">node-&gt;prev = pos-&gt;prev;</span><br><span class="line">node-&gt;prev-&gt;next = node;</span><br><span class="line">pos-&gt;prev = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除pos位置的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListErase</span><span class="params">(DListNode *pos)</span></span>&#123;</span><br><span class="line">pos-&gt;prev-&gt;next = pos-&gt;next;</span><br><span class="line">pos-&gt;next-&gt;prev = pos-&gt;prev;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPrint</span><span class="params">(<span class="keyword">const</span> DList *dlist)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (DListNode *cur = dlist-&gt;head-&gt;next;</span><br><span class="line">cur != dlist-&gt;head; cur = cur-&gt;next)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d --&gt;"</span>,cur-&gt;value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"DList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestDList1</span><span class="params">()</span></span>&#123;</span><br><span class="line">DList dlist;</span><br><span class="line">DListInit(&amp;dlist);</span><br><span class="line">DListPushFront(&amp;dlist,<span class="number">1</span>);</span><br><span class="line">DListPushFront(&amp;dlist, <span class="number">15</span>);</span><br><span class="line">DListPrint(&amp;dlist);</span><br><span class="line">DListPushFront(&amp;dlist, <span class="number">16</span>);</span><br><span class="line">DListPushBack(&amp;dlist, <span class="number">18</span>);</span><br><span class="line">DListPushFront(&amp;dlist, <span class="number">2</span>);</span><br><span class="line">DListPrint(&amp;dlist);</span><br><span class="line">DListPushBack(&amp;dlist,<span class="number">20</span>);</span><br><span class="line">DListPushFront(&amp;dlist, <span class="number">12</span>);</span><br><span class="line">DListPushBack(&amp;dlist,<span class="number">17</span>);</span><br><span class="line">DListPrint(&amp;dlist);</span><br><span class="line">DListDestory(&amp;dlist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">TestDList1();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DList-h&quot;&gt;&lt;a href=&quot;#DList-h&quot; class=&quot;headerlink&quot; title=&quot;DList.h&quot;&gt;&lt;/a&gt;DList.h&lt;/h3&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://jack-wang128801.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="双向链表" scheme="https://jack-wang128801.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
