<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>二叉树 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="二叉树一：二叉树的概述1.二叉树的概念
一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵别称为左子树和右子树的二叉树组成

2.二叉树的特点：
每个结点最多有两棵子树，即二叉树不存在度大于2的结点。
二叉树的子树有左右之分，其子树的次序不能颠倒。

3.二叉树的几种形态
4">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="二叉树">
  <meta property="og:site_name" content="Hexo">

  
    <meta property="og:image" content>
  

  
    <link rel="alternative" href="/jun/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link href="/jun/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/jun/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/jun/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/jun/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/jun/">Hexo</a><span class="split"></span><span class="title">二叉树</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-04-14</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="一：二叉树的概述"><a href="#一：二叉树的概述" class="headerlink" title="一：二叉树的概述"></a>一：二叉树的概述</h4><h5 id="1-二叉树的概念"><a href="#1-二叉树的概念" class="headerlink" title="1.二叉树的概念"></a>1.二叉树的概念</h5><blockquote>
<p>一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵别称为左子树和右子树<br>的二叉树组成</p>
</blockquote>
<h5 id="2-二叉树的特点："><a href="#2-二叉树的特点：" class="headerlink" title="2.二叉树的特点："></a>2.二叉树的特点：</h5><ol>
<li>每个结点最多有两棵子树，即二叉树不存在度大于2的结点。</li>
<li>二叉树的子树有左右之分，其子树的次序不能颠倒。</li>
</ol>
<h5 id="3-二叉树的几种形态"><a href="#3-二叉树的几种形态" class="headerlink" title="3.二叉树的几种形态"></a>3.二叉树的几种形态</h5><p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g21gxhf3h6j30hl07gq3i.jpg" alt></p>
<h5 id="4-两种特殊的二叉树"><a href="#4-两种特殊的二叉树" class="headerlink" title="4.两种特殊的二叉树"></a>4.两种特殊的二叉树</h5><p><strong>4.1：满二叉树</strong></p>
<blockquote>
<p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p>
</blockquote>
<p><strong>满二叉树的图例</strong></p>
<p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g21h3ea5v4j308k06qq4j.jpg" alt></p>
<p><strong>满二叉树的特点</strong></p>
<blockquote>
<p>如果二叉树的高度为 h </p>
<p>则满二叉树的节点个数为 2^h - 1;</p>
<p>而除了最后一层外。剩余的节点个数为2 ^ (h-1) -1个</p>
<p>最后一层的节点个数为 2 ^ (h-1) -1个 </p>
<p><strong>特点</strong>：满二叉树的最后一层节点个数为其他层数的结点个数之和 - 1‘</p>
</blockquote>
<p><strong>4.2完全二叉树</strong></p>
<blockquote>
<p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 </p>
</blockquote>
<p><strong>完全二叉树的特点</strong></p>
<blockquote>
<p>已知:父亲节点的下标为[parent]</p>
<p>则其左孩子的结点下标为[left] = 2* [parent] + 1</p>
<p>其右孩子的下标为[right] = 2 * [parent] + 2</p>
<p>已知：左孩子或者右孩子的下标[child]</p>
<p>其双亲结点的下标为[parent] = ( [child] - 1 ) / 2(结果取整)</p>
</blockquote>
<p><strong>要注意的是满二叉树是一种特殊的完全二叉树</strong></p>
<p><strong>满二叉树与完全二叉树的联系与区别</strong></p>
<blockquote>
<p><strong>满二叉树一定是完全二叉树，但是完全二叉树并不一定是满二叉树 </strong></p>
</blockquote>
<p><strong>二叉树的重要特征</strong></p>
<blockquote>
<p>1.二叉树上第i层上至多有2^(i-1)个结点（i&gt;=1）</p>
<p>2.深度为h的二叉树至多有2^h - 1个结点</p>
<p>3.对于任意一颗二叉树，如果其叶子结点数为n，度为2 的结点数为n1,则n=n1+1;</p>
<p>4.具有n个结点的完全二叉树的深度为[log2 (n+1)]或者为[log2 n]+1(备注:此处的[]为取整，不是中括号)</p>
<p>5.</p>
</blockquote>
<h4 id="二叉树存储"><a href="#二叉树存储" class="headerlink" title="二叉树存储"></a>二叉树存储</h4><p> <strong>1.顺序存储</strong></p>
<blockquote>
<p>顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</p>
</blockquote>
<p><strong>2. 链式存储</strong></p>
<blockquote>
<p><strong>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 </strong></p>
</blockquote>
<h4 id="三：二叉树链式存储结构及实现"><a href="#三：二叉树链式存储结构及实现" class="headerlink" title="三：二叉树链式存储结构及实现"></a>三：二叉树链式存储结构及实现</h4><h5 id="1-二叉树的遍历"><a href="#1-二叉树的遍历" class="headerlink" title="1.二叉树的遍历"></a>1.二叉树的遍历</h5><p><strong>A:前序遍历</strong></p>
<blockquote>
<p>前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前</p>
</blockquote>
<p><strong>B:中序遍历</strong></p>
<blockquote>
<p>中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。</p>
</blockquote>
<p><strong>C:后序遍历</strong></p>
<blockquote>
<p>后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。</p>
</blockquote>
<p><strong>三种遍历的使用</strong></p>
<p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g21yczmt1sj30mw09swhy.jpg" alt></p>
<p><strong>二叉树的层序遍历</strong></p>
<blockquote>
<p><strong>在遍历二叉树时按照层的方式遍历</strong></p>
</blockquote>
<h4 id="二叉树的代码实现模块"><a href="#二叉树的代码实现模块" class="headerlink" title="二叉树的代码实现模块"></a>二叉树的代码实现模块</h4><h5 id="1-二叉树结构体的定义"><a href="#1-二叉树结构体的定义" class="headerlink" title="1.二叉树结构体的定义"></a>1.二叉树结构体的定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTDdataType int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTDataType _data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* _<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* _<span class="title">right</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"><span class="comment">//以左孩子右孩子的方式定义</span></span><br></pre></td></tr></table></figure>
<h5 id="2-二叉树的前序遍历"><a href="#2-二叉树的前序遍历" class="headerlink" title="2.二叉树的前序遍历"></a>2.二叉树的前序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTreePrevOrder</span><span class="params">(BTNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;val);</span><br><span class="line">    BinaryTreePrevOrder(root-&gt;left);</span><br><span class="line">    BinaryTreePrevOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照递归的形式遍历二叉树的每一个结点</span></span><br></pre></td></tr></table></figure>
<h5 id="3-二叉树的中序遍历"><a href="#3-二叉树的中序遍历" class="headerlink" title="3.二叉树的中序遍历"></a>3.二叉树的中序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTreeInOrder</span><span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BinaryTreeInOrder(root-&gt;left);		<span class="comment">// 左子树</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;val);	<span class="comment">// 根</span></span><br><span class="line">	BinaryTreeInOrder(root-&gt;right);		<span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-二叉树的后序遍历"><a href="#4-二叉树的后序遍历" class="headerlink" title="4.二叉树的后序遍历"></a>4.二叉树的后序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTreePostOrder</span><span class="params">(BTNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    BinaryTreePostOrder(root-&gt;left);</span><br><span class="line">    BinaryTreePostOrder(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-二叉树的层序遍历"><a href="#5-二叉树的层序遍历" class="headerlink" title="5.二叉树的层序遍历"></a>5.二叉树的层序遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode *&gt;	qu;</span><br><span class="line"></span><br><span class="line">	qu.push(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!qu.empty()) &#123;</span><br><span class="line">		TreeNode *front = qu.front();</span><br><span class="line">		qu.pop();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c "</span>, front-&gt;val);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (front-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			qu.push(front-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (front-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			qu.push(front-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此算法是用c++语言实现的。</span></span><br><span class="line"><span class="comment">//队列存放结点的地址</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总体思想：首先需要另外创建一个空的队列，在判断二叉树不为空树的情况下,先将二叉树的根节点入队，然后在根节点出队的时候将它的左右孩子放到队列中，下一次它的左右孩子又是它左右子树的根节点，依次放到队列中，然后出栈，直到队列为空。</p>
</blockquote>
<p><strong>总结</strong></p>
<p><strong>前序|中序|后序      深度优先    栈</strong></p>
<p><strong>层序     广度优先     队列</strong></p>
<h4 id="四-二叉树面试题"><a href="#四-二叉树面试题" class="headerlink" title="四:二叉树面试题"></a>四:二叉树面试题</h4><p><strong>1.判断两个二叉树是否相等</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line">bool isSameTree(struct TreeNode* p,struct TreeNode *q)；</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<blockquote>
<p>首先考虑到如果两棵树都为空，则两棵树是相等的；如果两者中的一个为空，另外一个不为空，则两棵树肯定不相等。若两者都不为空，则需要将两颗二叉树分别分成三部分：1.根结点，2.左子树，3.右子树。然后按照递归的思想一直递推下去。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用递归的思想，先判断根的情况，再判断左右子树的情况</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(struct TreeNode* p,struct TreeNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;_data==q-&gt;_data</span><br><span class="line">        &amp;&amp;isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp;isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.判断对称树</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line">bool isMirror(struct TreeNode *p, struct TreeNode *q)；</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<blockquote>
<p>还是利用递推的思想,将所传的两个结点先进行检查。而后在确保两个结点的值相等的情况下，判断一个根节点的左孩子与另一个根结点的右孩子的情况继而判断这个根节点的右孩子和另外一个根节点的左孩子的情况。</p>
</blockquote>
<p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g24tvyq65rj30cd066dfr.jpg" alt></p>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(struct TreeNode *p, struct TreeNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;val==q-&gt;val</span><br><span class="line">        &amp;&amp;isMirror(p-&gt;left,q-&gt;right)</span><br><span class="line">        &amp;&amp;isMirrorq-&gt;left,p-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.判断一棵树是否为另外一棵树的子树</strong></p>
<p><strong>接口</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(struct TreeNode* root)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<blockquote>
<p>判断是否是子树<br>1）前序遍历(查找父树上节点的值和子树上结点的值相等的第一个节点，当所要查找的父树上结点的值和子树上根结点的值相等时再判断各自子树的情况)<br>2）判断两棵树是否相同<br>3）对于返回值的处理是难点</p>
</blockquote>
<p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g24ttrnpw0j30d30cg3yo.jpg" alt></p>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当子树的根结点的值和父树上对应的值相等时，判断两者对应的子树是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(struct TreeNode* p, struct TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递推</span></span><br><span class="line">	<span class="keyword">return</span> p-&gt;val == q-&gt;val</span><br><span class="line">		&amp;&amp; isSameTree(p-&gt;left, q-&gt;left)</span><br><span class="line">		&amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历，在父树上找与子树根节点值相等的结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">preorderTraversal</span><span class="params">(struct TreeNode *root, struct TreeNode *t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根</span></span><br><span class="line">	<span class="keyword">if</span> (root-&gt;val == t-&gt;val &amp;&amp; isSameTree(root, t)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 左子树</span></span><br><span class="line">	<span class="keyword">bool</span> left = preorderTraversal(root-&gt;left, t);</span><br><span class="line">	<span class="keyword">if</span> (left == <span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右子树</span></span><br><span class="line">	<span class="keyword">bool</span> right = preorderTraversal(root-&gt;right, t);</span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该问题所对应的接口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(struct TreeNode* s, struct TreeNode* t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> preorderTraversal(s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.求一棵二叉树的最大深度</strong></p>
<p><strong>接口</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)；</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<blockquote>
<p>拿到一颗二叉树</p>
</blockquote>
<p><img src="C:\Users\王世贤\AppData\Local\Temp\1555424148907.png" alt></p>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">int</span> left= MaxDepth(root-&gt;left);</span><br><span class="line">   <span class="keyword">int</span> right=MaxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (left&gt;right?left:right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.判断平衡二叉树</strong></p>
<blockquote>
<p>判断依据：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。 </p>
</blockquote>
<p><strong>接口</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(struct TreeNode* root)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<blockquote>
<p>首先要判断所传的树是否为空树，是空树就为真，不是空树就对根节点的左右子树进行必要的判断。如果都满足则求出左右子树的高度，然后判断根结点对应的左右子树的高度差，并判断高度差满足的条件</p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c语言版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(struct TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> left = getHeight(root-&gt;left);</span><br><span class="line">	<span class="keyword">int</span> right = getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (left&gt;right?left:right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//处理左子树</span></span><br><span class="line">	<span class="keyword">bool</span> is_left_balance = isBalanced(root-&gt;left);</span><br><span class="line">	<span class="keyword">if</span> (is_left_balance == <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">//处理右子树</span></span><br><span class="line">	<span class="keyword">bool</span> is_right_balance = isBalanced(root-&gt;right);</span><br><span class="line">	<span class="keyword">if</span> (is_right_balance == <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//求左子树的高度</span></span><br><span class="line">	<span class="keyword">int</span> left_height = getHeight(root-&gt;left);</span><br><span class="line">    <span class="comment">//求右子树的高度 </span></span><br><span class="line">	<span class="keyword">int</span> right_height = getHeight(root-&gt;right);</span><br><span class="line">	<span class="keyword">int</span> diff = left_height - right_height;</span><br><span class="line">	<span class="keyword">if</span> (diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//处理左子树</span></span><br><span class="line">	<span class="keyword">bool</span> is_left_balance = isBalanced(root-&gt;left);</span><br><span class="line">	<span class="keyword">if</span> (is_left_balance == <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">//处理右子树</span></span><br><span class="line">	<span class="keyword">bool</span> is_right_balance = isBalanced(root-&gt;right);</span><br><span class="line">	<span class="keyword">if</span> (is_right_balance == <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//求左子树的高度</span></span><br><span class="line">	<span class="keyword">int</span> left_height = getHeight(root-&gt;left);</span><br><span class="line">    <span class="comment">//求右子树的高度 </span></span><br><span class="line">	<span class="keyword">int</span> right_height = getHeight(root-&gt;right);</span><br><span class="line">	<span class="keyword">int</span> diff = left_height - right_height;</span><br><span class="line">	<span class="keyword">if</span> (diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(struct TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> left = getHeight(root-&gt;left);</span><br><span class="line">	<span class="keyword">int</span> right = getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (left&gt;right?left:right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>6.完全二叉树的判断</strong></p>
<p><strong>判定依据</strong></p>
<blockquote>
<p>在层序遍历二叉树的过程中如果没有遍历完所有结点之前就遇到了空结点的话，就说明该树不是完全二叉树</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<p>解题思路大致与层序遍历的相同，不同之处在于。判断二叉树的结点情况的时候两次判断了队列是否为空的情况，第一次遇到空结点就跳出循环，第二次判断队列是否为空</p>
</blockquote>
<p><strong>接口</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinaryTreeComplete</span><span class="params">(TreeNode* root)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinaryTreeComplete</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode *&gt;  qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        TreeNode *front=qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        <span class="keyword">if</span>(front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            qu.push(root-&gt;left);</span><br><span class="line">            qu.push(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查队列中是否还有其他元素</span></span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        TreeNode *node=qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="五：二叉树的前序-中序-后序的非递归实现，自己用栈来实现"><a href="#五：二叉树的前序-中序-后序的非递归实现，自己用栈来实现" class="headerlink" title="五：二叉树的前序|中序|后序的非递归实现，自己用栈来实现"></a>五：二叉树的前序|中序|后序的非递归实现，自己用栈来实现</h4><blockquote>
<p>栈(用来存放结点地址)</p>
</blockquote>
<p><strong>前序的非递归实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversalNor</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreeNode *cur = root;	<span class="comment">// 遍历结点的指针</span></span><br><span class="line">	TreeNode *top;	<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line">	TreeNode *last = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;	st;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 第一次访问结点：cur</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c "</span>, cur-&gt;val);</span><br><span class="line">			st.push(cur);</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		top = st.top();	<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line">		st.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (top-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 既是第二次访问，也是第三次访问</span></span><br><span class="line">			cur = top-&gt;right;</span><br><span class="line">			st.pop();</span><br><span class="line">			last = top;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (top-&gt;right != last) &#123;</span><br><span class="line">				<span class="comment">// 第二次访问</span></span><br><span class="line">				cur = top-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 第三次访问</span></span><br><span class="line">				st.pop();</span><br><span class="line">				last = top;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversalNor2</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreeNode *cur = root;	<span class="comment">// 遍历结点的指针</span></span><br><span class="line">	TreeNode *top;	<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// std:: 命名空间</span></span><br><span class="line">	<span class="comment">// &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode *</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;	st;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 第一次访问结点：cur</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c "</span>, cur-&gt;val);</span><br><span class="line">			st.push(cur);</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		top = st.top();	<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line">		st.pop();</span><br><span class="line">		cur = top-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>中序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversalNor</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreeNode *cur = root;	<span class="comment">// 遍历结点的指针</span></span><br><span class="line">	TreeNode *top;	<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line">	TreeNode *last = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// std:: 命名空间</span></span><br><span class="line">	<span class="comment">// &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode *</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;	st;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 第一次访问结点：cur</span></span><br><span class="line">			st.push(cur);</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		top = st.top();	<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line">		<span class="keyword">if</span> (top-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 既是第二次访问，也是第三次访问</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">			cur = top-&gt;right;</span><br><span class="line">			st.pop();</span><br><span class="line">			last = top;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (top-&gt;right != last) &#123;</span><br><span class="line">				<span class="comment">// 第二次访问</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">				cur = top-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 第三次访问</span></span><br><span class="line">				st.pop();</span><br><span class="line">				last = top;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversalNor2</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreeNode *cur = root;	<span class="comment">// 遍历结点的指针</span></span><br><span class="line">	TreeNode *top;	<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// std:: 命名空间</span></span><br><span class="line">	<span class="comment">// &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode *</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;	st;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 第一次访问结点：cur</span></span><br><span class="line">			st.push(cur);</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		top = st.top();	<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line">		<span class="comment">// 既是第二次访问，也是第三次访问</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">		cur = top-&gt;right;</span><br><span class="line">		st.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTraversalNor</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreeNode *cur = root;	<span class="comment">// 遍历结点的指针</span></span><br><span class="line">	TreeNode *top;	<span class="comment">// 返回栈顶数据的指针</span></span><br><span class="line">	TreeNode *last = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// std:: 命名空间</span></span><br><span class="line">	<span class="comment">// &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode *</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode *&gt;	st;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.empty() || cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 第一次访问结点：cur</span></span><br><span class="line">			st.push(cur);</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		top = st.top();	<span class="comment">// 从栈里取出栈顶元素</span></span><br><span class="line">		<span class="keyword">if</span> (top-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 既是第二次访问，也是第三次访问</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">			cur = top-&gt;right;</span><br><span class="line">			st.pop();</span><br><span class="line">			last = top;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (top-&gt;right != last) &#123;</span><br><span class="line">				<span class="comment">// 第二次访问</span></span><br><span class="line">				cur = top-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 第三次访问</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>, top-&gt;val);</span><br><span class="line">				st.pop();</span><br><span class="line">				last = top;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">递归的写法</span><br><span class="line">       根    左子树  右子树</span><br><span class="line">       左子树 根 右子树</span><br><span class="line">       左子树  右子树  根</span><br><span class="line">       </span><br><span class="line">非递归写法  ： 便利的同时，找到第一次，第二次，第三次 访问点</span><br></pre></td></tr></table></figure>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
			
		
	
		
			
		
	
		
	
		
	
		
			
		
	
	
	
		<li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/jun/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/jun/2019/03/19/数据结构-双向链表/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2019 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/jun/js/jquery.imagesloaded.min.js"></script>
<script src="/jun/js/gallery.js"></script>
<script src="/jun/js/bootstrap.min.js"></script>
<script src="/jun/js/jquery.tableofcontents.min.js"></script>
<script src="/jun/js/tocgenerator.min.js"></script>
<script src="/jun/js/main.js"></script>
<script src="/jun/js/search.js"></script> 




<link rel="stylesheet" href="/jun/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/jun/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




</body>
</html>
