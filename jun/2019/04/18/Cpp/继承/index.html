<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>继承 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="继承[TOC]">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="继承">
  <meta property="og:site_name" content="Hexo">

  
    <meta property="og:image" content>
  

  
    <link rel="alternative" href="/jun/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link href="/jun/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/jun/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/jun/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/jun/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/jun/">Hexo</a><span class="split"></span><span class="title">继承</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-04-18</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>[TOC]</p>
<a id="more"></a>
<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><h4 id="1-对继承的理解"><a href="#1-对继承的理解" class="headerlink" title="1. 对继承的理解"></a>1. 对继承的理解</h4><p><strong>a.继承的理解：</strong> class(类)级别的代码复用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"name:"</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> _name = <span class="string">"peter"</span>; <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">int</span> _age = <span class="number">18</span>; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person  <span class="comment">//继承了Person 的内容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _stuid= <span class="number">4170903</span>; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _jobid=<span class="number">147632</span>; <span class="comment">// 工号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Student s;</span><br><span class="line">	Teacher t;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>监视结果</strong></p>
<p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g27uin55epj30eg0adwf5.jpg" alt></p>
<ul>
<li>由上图可以看到==Student和Teacher类中出现了自己内部并没有定义过的Person类中的内容。==他们从Person类中  <strong>继承</strong> 了Person类中的内容。</li>
</ul>
<p><strong>继承的图例说明</strong></p>
<p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g27ww13nf1j30fo0a4q2x.jpg" alt></p>
<p>==注意：Student类中此时只有<strong>name,</strong>age__stuid三个变量，并没有Person这个内部类，Teacher类中也没有Person这个类==</p>
<p><strong>运行结果</strong></p>
<p><img src="https://wx3.sinaimg.cn/mw690/0071OE7sly1g27urs6g2gj30dw06sq31.jpg" alt></p>
<p><strong>继承的格式</strong></p>
<p><img src="https://wx1.sinaimg.cn/mw690/0071OE7sly1g27ux3jq6hj30iq0a2q4n.jpg" alt></p>
<p><strong>b.继承关系和访问权限</strong></p>
<table>
<thead>
<tr>
<th>类成员/继承方式</th>
<th>public继承</th>
<th>protected继承</th>
<th>private继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>基类的public成员</td>
<td>派生类的public成员</td>
<td>派生类的protected成员</td>
<td>派生类的private成员</td>
</tr>
<tr>
<td>基类中的protected成员</td>
<td>派生类中的protected成员</td>
<td>派生类的protected成员</td>
<td>派生类的private成员</td>
</tr>
<tr>
<td>基类的private成员</td>
<td>在派生类中不可见</td>
<td>在派生类中不可见</td>
<td>在派生类中不可见</td>
</tr>
</tbody>
</table>
<ul>
<li><p>1.继承方式和基类中的访问方式结合起来就有9种子类的访问方式，==在子类中的访问方式取两者中权限最小的==。</p>
</li>
<li><p>2.==不管在子类中是如何继承的基类中的私有成员在子类中都是不可见的==,但是它确实存在与子类中。</p>
</li>
<li><p>3.==基类的私有成员在子类都是不可见==。基类的其他成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。</p>
</li>
<li><p>4.==基类中的保护类型在子类中可以被访问==，但是在==子类之外定义的变量不可以访问==。</p>
</li>
<li><p>5.使用关键字class时==默认的继承方式是private==，使用struct==时默认的继承方式是public==，不过最好显示的写出继承方式</p>
</li>
<li><p>6.==基类private成员在派生类中无论以什么方式继承都是不可见的==。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它</p>
</li>
</ul>
<p>【总结】</p>
<ul>
<li><p>protected:在类外无法访问，但是在子类内部可以访问</p>
</li>
<li><p>private：在类外和子类中都无法访问</p>
</li>
<li><p>public继承：不改变基类成员在子类中的访问权限</p>
</li>
<li><p>protected继承：基类成员在子类中的最低访问权限为protected的</p>
</li>
<li><p>private继承：基类成员在子类中的最低访问权限为private的</p>
</li>
</ul>
<p>【注意】</p>
<p>==若基类在继承时未注明继承方式，默认为公有继承==</p>
<h4 id="2-基类和派生类对象赋值转换"><a href="#2-基类和派生类对象赋值转换" class="headerlink" title="2.基类和派生类对象赋值转换"></a>2.基类和派生类对象赋值转换</h4><h5 id="切片-子类对象可以赋给父类对象。但是父类对象不可赋给子类对象"><a href="#切片-子类对象可以赋给父类对象。但是父类对象不可赋给子类对象" class="headerlink" title="切片:子类对象可以赋给父类对象。但是父类对象不可赋给子类对象"></a>切片:子类对象可以赋给父类对象。但是父类对象不可赋给子类对象</h5><p><strong>切片操作图示</strong></p>
<p><img src="https://wx2.sinaimg.cn/mw690/0071OE7sly1g27wiawhu9j30kx08igmo.jpg" alt></p>
<p><strong>切片理解</strong></p>
<ul>
<li><p>==1.派生类对象可以赋值给基类的对象 / 基类的指针 / 基类的引用。==这里有个形象的说法叫切片或者切割。寓意把派生类的内容中将父类中的那部分切下来赋值给父类。</p>
</li>
<li><p>==2.父类对象不能赋值给子类对象==</p>
</li>
<li><p>父类指针只能看到和自己类型大小的空间,所以不能赋给子类指针</p>
</li>
<li><p>指针的类型决定指针可以看到多大的空间</p>
<blockquote>
<ul>
<li>char* :一个字节</li>
<li>int * : 四个字节</li>
<li>子类对象的地址可以赋给父类的指针(父类指针可以在子类对象所占空间大小中只访问自己能访问到的大小)指针类型决定访问的空间大小</li>
</ul>
</blockquote>
</li>
<li><p>==父类引用可以赋值给子类指针：==引用的底层就是指针</p>
</li>
<li><p>==父类的指针不能赋给子类指针==：可能会存在访问越界的风险(若子类中没有定义新的成员，则基类于与子类的大小相同就不存在访问越界的情况)</p>
</li>
<li><p>需要做强制类型转换：Student <em>ptr =(Studennt </em>) &p;</p>
<blockquote>
<ul>
<li>强转存在风险:若子类中定义了新的变量，强转父类指针类型就存在访问越界的风险。</li>
</ul>
</blockquote>
<figure class="highlight c"><figcaption><span>+</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">10</span>;</span><br><span class="line">p=(<span class="keyword">int</span>*) c;</span><br></pre></td></tr></table></figure>
<p><strong>隐式类型转换</strong></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span>  b=<span class="number">1.5</span>;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>隐式类型转换：==类型相似的变量可以进行相互赋值==，通过隐式类型转换。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="3-继承中的作用域"><a href="#3-继承中的作用域" class="headerlink" title="3.继承中的作用域"></a>3.继承中的作用域</h4><ul>
<li><p>1.在继承体系中基类和派生类都有独立的作用域。</p>
</li>
<li><p>2.子类和父类中有同名成员，==子类成员将屏蔽父类对同名成员的直接访问==，这种情况叫隐藏，也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显示访问）</p>
</li>
<li><p>3.需要注意的是==如果是成员函数的隐藏，只需要函数名相同就构成隐藏。==</p>
</li>
<li><p>4.注意在实际中在继承体系里面最好不要定义同名的成员</p>
</li>
</ul>
<p>【拓展】</p>
<ul>
<li>重载: 函数在同一个作用域中，函数名相同但参数不同</li>
<li>重定义/隐藏: 子类函数和父类函数名字相同</li>
</ul>
<h5 id="类的成员变量的隐藏"><a href="#类的成员变量的隐藏" class="headerlink" title="类的成员变量的隐藏"></a>类的成员变量的隐藏</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> _name = <span class="string">"小李子"</span>; <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">int</span> _num = <span class="number">111</span>; <span class="comment">// 身份证号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" 姓名:"</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" 身份证号:"</span> &lt;&lt; Person::_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" 学号:"</span> &lt;&lt; _num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> _num = <span class="number">999</span>; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student s1;</span><br><span class="line">	s1.Print();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Student s;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s._num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.Person::_num &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">//可以通过这种方法访问父类中的对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p._num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.Student::_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当子类和父类的成员变量/成员函数同名时，</span></span><br><span class="line"><span class="comment">//子类会将父类中的同名变量/函数隐藏掉</span></span><br><span class="line"><span class="comment">//若需访问需要加上作用域限定符</span></span><br></pre></td></tr></table></figure>
<h5 id="类中函数的同名隐藏"><a href="#类中函数的同名隐藏" class="headerlink" title="类中函数的同名隐藏"></a>类中函数的同名隐藏</h5><p><strong>条件：子类中的函数与父类中的==函数名字相同==</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数的隐藏</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		A::fun();<span class="comment">//指明调用</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"func(int i)-&gt;"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.fun(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//b.fun();//调不到fun()函数，因为已经被b中的fun(int)函数隐藏了</span></span><br><span class="line">    <span class="comment">//需要加上作用域限定符,如下语句</span></span><br><span class="line">    b.A::fun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载：函数在同以作用域，函数名相同，参数不同</span></span><br><span class="line"><span class="comment">//重定义：重定义/隐藏：子类函数和父类函数名相同就会构成隐藏</span></span><br><span class="line"><span class="comment">//子类会把父类同名的函数隐藏掉</span></span><br></pre></td></tr></table></figure>
<h4 id="4-派生类的默认成员函数"><a href="#4-派生类的默认成员函数" class="headerlink" title="4.派生类的默认成员函数"></a>4.派生类的默认成员函数</h4><ul>
<li><p>6个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类中，这几个成员函数是如何生成的呢？</p>
</li>
<li><p>a.==派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。==如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</p>
</li>
<li><p>b.==派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化==</p>
</li>
<li><p>c.==派生类的operator=必须要调用基类的operator=完成基类的复制==。</p>
</li>
<li><p>d.==派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员==。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</p>
</li>
<li><p>e.==派生类对象初始化先调用基类构造再调派生类构造。==</p>
</li>
<li><p>f.==派生类对象析构清理先调用派生类析构再调基类的析构==</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/07/20/5d32803dc33f447016.png" alt></p>
<h6 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"peter"</span>)</span><br><span class="line">		: _name(name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">		: _name(p._name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person(const Person&amp; p)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person operator=(const Person&amp; p)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;p)</span><br><span class="line">			_name = p._name;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> _name; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//完成父类对象的初始化，子类的构造函数先调用基类的构造函数，</span></span><br><span class="line">	<span class="comment">//再执行子类的构造函数</span></span><br><span class="line">	<span class="comment">//必须先调用父类的构造函数和拷贝构造进行初始化</span></span><br><span class="line">	Student(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> num)</span><br><span class="line">		: Person(name)</span><br><span class="line">		, _num(num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果子类不显示的调用父类的拷贝构造，则调用父类的默认构造函数</span></span><br><span class="line">	<span class="comment">//如果子类显示的调用父类类的拷贝构造，就不会再去调用父类的默认构造</span></span><br><span class="line">	Student(<span class="keyword">const</span> Student&amp; s) </span><br><span class="line">		<span class="comment">//(Student *this,const Student &amp;s)还发生了指针的欺骗。</span></span><br><span class="line">		: Person(s)<span class="comment">//此处是一个切片的操作，调用父类的拷贝构造</span></span><br><span class="line">		, _num(s._num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student(const Student&amp; s)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//父类的成员变量可以直接在子类的赋值运算符重载函数长中直接赋值</span></span><br><span class="line">	<span class="comment">//如果是编译器默认生成的子类赋值运算符重载函数，会调用父类的</span></span><br><span class="line">	<span class="comment">//赋值运算符重载函数进行赋值</span></span><br><span class="line">	Student&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Student&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student&amp; operator= (const Student&amp; s)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//operator =(s);不可以这样写</span></span><br><span class="line">			Person::<span class="keyword">operator</span> =(s);<span class="comment">//此处调用的this指针为子类对象的this指针</span></span><br><span class="line">			_num = s._num;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//若if中没有显示的写出父类的赋值运算符重载的话，</span></span><br><span class="line">		<span class="comment">//子类中不会调用父类的赋值运算符重载</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数:不允许显示调用父类的析构函数</span></span><br><span class="line">	~Student()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//~Person();坑:同名隐藏，编译器底层对析构函数的名字做了修改为了使用多条调不动</span></span><br><span class="line">		<span class="comment">//编辑器将~Student()与~Person()都修改成了~destructor</span></span><br><span class="line">		<span class="comment">//Person::~Person(); //可以调动</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _num; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"jack"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">	<span class="function">Student <span class="title">s3</span><span class="params">(<span class="string">"rose"</span>, <span class="number">17</span>)</span></span>;</span><br><span class="line">	s1 = s3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造顺序：先是基类构造————》派生类构造 </span></span><br><span class="line"><span class="comment">//析构顺序：派生类析构--》基类析构</span></span><br><span class="line"><span class="comment">//原因为函数栈帧的排列顺序</span></span><br></pre></td></tr></table></figure>
<h6 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h6><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A( <span class="keyword">char</span>* name=<span class="string">"james"</span>)</span><br><span class="line">		:_name(name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A&amp; operator=(const A&amp;a)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;a)&#123;</span><br><span class="line">			_name = a._name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~A()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A(const A&amp;a)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class B:public A&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类类不显示的写出调用基类的构造与析构函数时</span></span><br><span class="line"><span class="comment">//派生类会自动调用基类的构造和析构函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//基类的成员不能直接在派生类的构造和拷贝构造中直接初始化，必须调用父类</span></span><br><span class="line">	<span class="comment">//的构造和拷贝构造进行初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//派生类构造函数先调用基类构造函数，再执行派生类构造函数</span></span><br><span class="line">	<span class="comment">/*B(const char* name="jack")</span></span><br><span class="line"><span class="comment">		:_name(name)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">	<span class="comment">//错误的定义方式</span></span><br><span class="line">	B( <span class="keyword">char</span> *name = <span class="string">"jack"</span>)</span><br><span class="line">		:_name(name)</span><br><span class="line">		,A(name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~B()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	B(<span class="keyword">const</span> B&amp;b)</span><br><span class="line">		<span class="comment">//:A(b)//显示的写出来会先调用基类的拷贝构造</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B(const B&amp;b)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果子类不显示调用父类的拷贝构造，则调用父类的默认拷贝构造</span></span><br><span class="line">	<span class="comment">//如果子类显示的调用父类的拷贝构造，就不会再去调用父类的默认拷贝构造</span></span><br><span class="line"></span><br><span class="line">	B&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> B&amp;b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B&amp;operator= (const B&amp;b)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;b)&#123;</span><br><span class="line">			<span class="comment">//_name = b._name;</span></span><br><span class="line">			A::<span class="keyword">operator</span>=(b);</span><br><span class="line">			<span class="comment">//调用了基类的赋值运算符重载函数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//基类的成员变量可以直接在子类的 赋值运算符重载函数中直接赋值</span></span><br><span class="line">	<span class="comment">//如果是编译器默认生成的派生类赋值运算符重载函数,</span></span><br><span class="line">	<span class="comment">//会调用基类的赋值运算符重载函数进行赋值</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="function">B <span class="title">c</span><span class="params">(b)</span></span>;</span><br><span class="line">	B d = c; <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="comment">//派生类中没有写拷贝构造的时候调用了基类的拷贝构造</span></span><br><span class="line">	<span class="comment">//派生类中显示的写出拷贝构造的时候调用的是派生类的拷贝构造</span></span><br><span class="line">	d = c; <span class="comment">//调用赋值运算符重载</span></span><br><span class="line">	<span class="comment">//派生类中没有写赋值运算符重载的时候调用了基类的赋值运算符重载</span></span><br><span class="line">	<span class="comment">//派生类中显示的写出赋值运算符重载的时候调用的是派生类的赋值运算符重载</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常见面试题：实现一个不能被继承的类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> NonInherit <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> NonInherit();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> NonInherit()</span><br><span class="line"> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// C++11给出了新的关键字final禁止继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span> <span class="title">final</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h4><blockquote>
<p><strong>继承：</strong>   类级别的代码复用</p>
<p> <strong>继承方式：</strong> public,protectd,private</p>
<p>基类成员在子类中的访问权限：min(在基类中的限定符，继承方式)</p>
<p>​                                                              基类的私有成员在子类中不可见</p>
</blockquote>
<blockquote>
<p><strong>protected</strong>    ：在基类和子类中可见，在类外不可见<br> <strong>private</strong>    :只在基类中可见，其他地方不可见<br>  <strong>类域：</strong>   基类和子类的作用域独立<br><strong>成员隐藏</strong><br>       1.成员变量隐藏：子类相同名称的成员隐藏基类同名的成员，通过基类作用域访问基类成员变量<br>        2.成员函数隐藏：函数名相同既构成隐藏.同名函数会隐藏基类函数，和参数无关</p>
</blockquote>
<blockquote>
<p><strong>函数重载：</strong>    在同一个作用域，函数名相同，参数不同。</p>
<p><strong>函数隐藏：</strong>    函数一个在子类，一个在父类，函数名相同。</p>
</blockquote>
<blockquote>
<p><strong>子类的6大成员函数</strong><br><strong>构造：</strong>     1.默认生成的，首先会自动调用父类的默认构造函数，再调用自己的构造函数<br>                 2.显示定义：如果父类有默认构造，可以不显示调用，如果父类无默认构造函数，需要在初始化列表显示调用。</p>
</blockquote>
<blockquote>
<p><strong>拷贝构造：</strong>     1.默认构成的，编译器会自动调用父类的拷贝构造</p>
<p>​                         2.显示定义：如果不显式调用父类拷贝构造，编译器会调用父类的默认构造</p>
</blockquote>
<blockquote>
<ul>
<li><strong>赋值运算符：</strong>    1.默认生成的，编译器会自动调用父类的赋值运算符重载函数</li>
<li>​                            2.显示定义：如果不显示的调用父类的赋值运算符重载函数，编译器不会调用父类的任何成员函数</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>析构：</strong> 1.默认生成：先执行自己的析构函数，编译器再调用父类的析构</li>
<li>​             2.显示定义：不需要显示调用父类的析构，编译器会自动调用，注意父类析构和子类析构构成函数隐藏。</li>
<li><strong>取地址：</strong>使用编译器默认生成的即可</li>
</ul>
</blockquote>
<blockquote>
<p><strong>父类子类对象之间的赋值：</strong>  切片操作</p>
<p>​     1.子类对象可以赋值给父类对象，指针，引用</p>
<p>​     2.父类对象不能赋值给子类对象，可能会造成访问异常</p>
<p>​     3.父类指针在特定条件下可以赋值给子了指针，如果父类指针本身指向的为子类对象的空间，赋值时是安全的，否则不安全 ，会导致访问异常。</p>
</blockquote>
<p><strong>友元关系不能继承</strong></p>
<blockquote>
<p>继承体系 中的静态</p>
</blockquote>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
			
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
			
			
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
	
	
	
		<li class="prev"><a href="/jun/2019/05/12/Cpp/C++进阶多态/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/jun/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/jun/2019/04/05/Cpp/特殊的一些用法/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2019 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/jun/js/jquery.imagesloaded.min.js"></script>
<script src="/jun/js/gallery.js"></script>
<script src="/jun/js/bootstrap.min.js"></script>
<script src="/jun/js/jquery.tableofcontents.min.js"></script>
<script src="/jun/js/tocgenerator.min.js"></script>
<script src="/jun/js/main.js"></script>
<script src="/jun/js/search.js"></script> 




<link rel="stylesheet" href="/jun/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/jun/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




</body>
</html>
