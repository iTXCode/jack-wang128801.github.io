<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Linux进程控制 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="一：Linux进程控制[TOC]">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Linux进程控制">
  <meta property="og:site_name" content="Hexo">

  
    <meta property="og:image" content>
  

  
    <link rel="alternative" href="/jun/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link href="/jun/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/jun/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/jun/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/jun/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/jun/">Hexo</a><span class="split"></span><span class="title">Linux进程控制</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-05-11</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h3 id="一：Linux进程控制"><a href="#一：Linux进程控制" class="headerlink" title="一：Linux进程控制"></a>一：Linux进程控制</h3><p>[TOC]</p>
<a id="more"></a>
<h4 id="一：进程的创建"><a href="#一：进程的创建" class="headerlink" title="一：进程的创建"></a>一：进程的创建</h4><h5 id="1-【fork的运行规则-】以父进程为模板-创建子进程"><a href="#1-【fork的运行规则-】以父进程为模板-创建子进程" class="headerlink" title="1:【fork的运行规则:】以父进程为模板,创建子进程"></a>1:【fork的运行规则:】以父进程为模板,创建子进程</h5><ul>
<li>1.子进程会把父进程的PCB拷贝一份，稍加修饰,做为子进程的PCB</li>
<li>2.子进程会把进程的虚拟地址空间拷贝一份,做为子进程的地址空间</li>
</ul>
<h5 id="2-【进程调用fork】-当控制转移到内核中的fork代码后，内核做"><a href="#2-【进程调用fork】-当控制转移到内核中的fork代码后，内核做" class="headerlink" title="2:【进程调用fork】:当控制转移到内核中的fork代码后，内核做"></a>2:【进程调用fork】:当控制转移到内核中的fork代码后，内核做</h5><ul>
<li>分配新的内存块和内核数据结构给子进程</li>
<li>将父进程部分数据结构内容拷贝至子进程</li>
<li>添加子进程到系统进程列表当中fork返回，开始调度器调度</li>
</ul>
<p>【写时拷贝】按浅拷贝拷贝内容,为了提高效率.===&gt;父子进程公用一份代码,各自有一份数据</p>
<ul>
<li>3.fork返回是在父进程总分别 返回</li>
</ul>
<p>父进程返回子进程的pid</p>
<ul>
<li>4.父子进程执行顺序f</li>
</ul>
<h5 id="代码执行完的情况"><a href="#代码执行完的情况" class="headerlink" title="代码执行完的情况"></a>代码执行完的情况</h5><p>1.main函数返回,返回值叫做进程的推出码,通过这个退出码表示运行结果是否正确</p>
<p>退出码为0表示结果正确</p>
<p>退出码非0表示结果不正确</p>
<p>$?这是bash中一个特殊变量,可以查看上个命令对应进程的退出码</p>
<p>2.exit进程退出(库函数),本质上是调用 __exit</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;                                      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"hehe"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不会打印出任何结果,在打印语句之前程序就已经结束了</li>
</ul>
<p>使用<code>echo $?</code></p>
<ul>
<li>查看到退出码为 1 ;</li>
</ul>
<p>1.exit关闭流并刷新缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 c 语言执行过程，这个过程会写一个文件(临时文件)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"goodbye!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    atexit(Func);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3._ exit进程退出(系统调用)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"haha"</span>);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//系统调用,并没有刷新缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_ eixt还调用了结束函数</p>
<h4 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h4><ul>
<li>父进程对子进程进行进程等待,是为了读取子进程的运行结果</li>
</ul>
<h5 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h5><p>1.参数为输出型参数(表示退出码+ 正常/异常退出)</p>
<p>2.返回值是子进程</p>
<p>【注意事项】</p>
<ul>
<li>1.wait的次数必须和子进程 的个数一致</li>
<li>wait的调用次数比较少,导致僵尸进程</li>
<li>wait的调用次数比较多,多出来的 wait 就会调用出错</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两次调用fork函数只有一个wait,死循环 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> ret=fork();</span><br><span class="line">   <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">     perror(<span class="string">"fork"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ret=fork();</span><br><span class="line">   <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//父进程如果不关注子进程具体的退出状态              </span></span><br><span class="line">   wait(<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.如果有多个子进程,任何一个子进程结束都会触发wait的 返回</li>
</ul>
<p>kill -l</p>
<p>显示所有信号,其中32.33两个不存在</p>
<h5 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h5><p>【功能简介】</p>
<ul>
<li>1.waitpid能够等待某个指定的子进程的退出.行为和wait非常相似(返回值规则,status参数)</li>
<li>waitpid（-1,NULL,0)和wait(NULL)是等价的</li>
<li>WNOHANG加上之后，waitpid就变成了非阻塞(一般搭配循环使用)</li>
</ul>
<p>【非阻塞轮询式的wait】</p>
<p>好处:能够更加灵活的控制代码,充分利用等待时间去做其他事情</p>
<p>坏处:代码写起来更复杂</p>
<h4 id="四-进程程序替换"><a href="#四-进程程序替换" class="headerlink" title="四: 进程程序替换"></a>四: 进程程序替换</h4><h5 id="替换原理"><a href="#替换原理" class="headerlink" title="替换原理"></a>替换原理</h5><ul>
<li>fork创建出的子进程和父进程是共用同一套代码,而事实上我们更需要的是创建处的子进程能够执行一份单独的代码</li>
<li>1.程序替换不会创建新进程,也不会销毁进程</li>
<li>2.替换代码和数据(从一个可执行文件中来)</li>
<li><p>3.原有的栈和堆中的数据就全都不要了,根据新的代码的执行过程重新构建堆和栈的内容</p>
</li>
<li><p>[ ] 类似于 双击 exe  执行一个程序的过程(操作系统的加载器模块)</p>
</li>
<li style="list-style: none"><input type="checkbox"> exec函数族,参数有差异,底层原理完全相同</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before execl\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=execl(<span class="string">"/usr/bin/ls"</span>,<span class="string">"/usr/bin/ls"</span>,<span class="string">"/"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after execk%d \n"</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】</p>
<ul>
<li>程序替换经常搭配fork使用</li>
<li>一旦替换之后,就会把原来进程的代码和数据都干掉.无法继续执行原来的代码</li>
</ul>
<p>execlp：p表示PATH,自动从PATH的目录中查找可执行程序</p>
<p>execle:用户进行程序替换的时候手动执行环境变量(参数中的数组必须也要用NULL结尾)</p>
<h4 id="借助进程控制实现shell程序"><a href="#借助进程控制实现shell程序" class="headerlink" title="借助进程控制实现shell程序"></a>借助进程控制实现shell程序</h4><p><strong>开发<em>mini版的 shell</em></strong></p>
<ul>
<li>1.打印一个提示符,并且让用户输入一个指令</li>
<li>2.解析输入的命令,找到对应的可执行程序</li>
<li>3.创建子进程,子进程程序替换,来加载可执行程序</li>
<li>4.父进程进行程序等待,等待子进程结束</li>
<li>5.子进程结束,父进程从wait中返回,循环执行1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数名相同,但是函数签名不同</span></span><br><span class="line"><span class="comment">//函数签名:参数列表+cv限定符(const,colatile)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">c++ 标准库的做法</span></span><br><span class="line"><span class="comment">#include&lt;sstream&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">基于 boost 的方案是比较科学的方案</span></span><br><span class="line"><span class="comment">boost algotithm/string.hpp</span></span><br><span class="line"><span class="comment">boost::split</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//input 表示待切分命令</span></span><br><span class="line"><span class="comment">//output 表示切分结果(字符串数组)</span></span><br><span class="line"><span class="comment">//返回值表示 output 中包含了几个有效元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Split</span><span class="params">(<span class="keyword">char</span>  input[], <span class="keyword">char</span> *output[])</span></span>&#123;</span><br><span class="line">	<span class="comment">//借助 strtok 来实现</span></span><br><span class="line">	<span class="keyword">char</span> *p = strtok(input, <span class="string">" "</span>);</span><br><span class="line">	<span class="comment">//返回值指向第一个 l 的指针</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="comment">//printf("%s\n",p);</span></span><br><span class="line">		output[i] = p;</span><br><span class="line">		++i;</span><br><span class="line">		p = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">		<span class="comment">//第二次返回值指向 - 的指针</span></span><br><span class="line">		<span class="comment">//第三次返回值指向/的指针</span></span><br><span class="line">		<span class="comment">//第四次返回值为NULL</span></span><br><span class="line">	&#125;</span><br><span class="line">    output[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//这个操作是很容易被遗忘的</span></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateProcess</span><span class="params">(<span class="keyword">char</span> *argv[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) n;</span><br><span class="line">    <span class="comment">//1.创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> ret=fork();</span><br><span class="line">    <span class="comment">//2.父进程进行进程等待,子进程进行程序替换</span></span><br><span class="line">    <span class="keyword">if</span>(ret&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//father</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//child</span></span><br><span class="line">        ret=execvp(argv[<span class="number">0</span>],argv);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">"exec"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处的if条件可以省略,如果exec成功了,</span></span><br><span class="line">        <span class="comment">//程序肯定执行不到这里</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//1.打印提示符</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[myshell@localhot ~]$"</span>);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">		<span class="comment">//2.让用户输入指令</span></span><br><span class="line">		<span class="keyword">char</span> command[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="comment">//scanf("%s",command);</span></span><br><span class="line">		<span class="comment">//scanf中遇到空格打印一行命令的时候就会出错</span></span><br><span class="line">		<span class="comment">//用gets，一个参数，一次读入一行数据</span></span><br><span class="line">		gets(command);</span><br><span class="line">		<span class="comment">//TODO测试下 scanf 能否读入一行数据</span></span><br><span class="line">		<span class="comment">//printf("%s\n", command);</span></span><br><span class="line">		<span class="comment">//3.解析指令,把我们要执行那个程序识别出来,</span></span><br><span class="line">		<span class="comment">//那些是命令行参数识别出来(字符串切分)</span></span><br><span class="line">		<span class="comment">//切分结果应该是一个字符串数组</span></span><br><span class="line">		<span class="keyword">char</span> *argv[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">int</span> n = Split(command,argv);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4.创建子进程并且进行程序替换</span></span><br><span class="line">		CreateProcess(argv,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="【strtok-执行过程】"><a href="#【strtok-执行过程】" class="headerlink" title="【strtok 执行过程】"></a>【strtok 执行过程】</h5><ul>
<li>破坏原始的字符串</li>
<li>内部保存上次的切分结果</li>
<li>strtok必须循环调用,并且第一次的参数和后续的参数不一样</li>
</ul>
<h5 id="【myshell】的改进"><a href="#【myshell】的改进" class="headerlink" title="【myshell】的改进"></a>【myshell】的改进</h5><ul>
<li>1.自动获取到用户名,主机名,当前路径</li>
<li>2.需要支持 cd命令(cd 修改的是子进程的路径,对父进程没有影响)</li>
<li>需要让父进程直接支持cd(而不是创建子进程/程序替换),内建命令(父进程直接完成动作)</li>
<li>3.支持定义别名(需要在程序中维护一个键值对数据结构) std::map</li>
<li>4.支持管道</li>
<li>5.支持重定向</li>
</ul>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
			
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
			
			
			
		
			
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/jun/2019/05/20/Linux/Linux-基础IO/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/jun/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/jun/2019/05/04/Linux/Linux-系统下cat指令与more指令的异同/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2019 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/jun/js/jquery.imagesloaded.min.js"></script>
<script src="/jun/js/gallery.js"></script>
<script src="/jun/js/bootstrap.min.js"></script>
<script src="/jun/js/jquery.tableofcontents.min.js"></script>
<script src="/jun/js/tocgenerator.min.js"></script>
<script src="/jun/js/main.js"></script>
<script src="/jun/js/search.js"></script> 




<link rel="stylesheet" href="/jun/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/jun/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




</body>
</html>
