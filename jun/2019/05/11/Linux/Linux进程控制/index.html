<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Linux进程控制 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="Linux进程控制[TOC]">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Linux进程控制">
  <meta property="og:site_name" content="Hexo">

  
    <meta property="og:image" content>
  

  
    <link rel="alternative" href="/jun/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link href="/jun/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/jun/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/jun/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/jun/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/jun/">Hexo</a><span class="split"></span><span class="title">Linux进程控制</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-05-11</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h3 id="Linux进程控制"><a href="#Linux进程控制" class="headerlink" title="Linux进程控制"></a>Linux进程控制</h3><p>[TOC]</p>
<a id="more"></a>
<h4 id="一：进程的创建"><a href="#一：进程的创建" class="headerlink" title="一：进程的创建"></a>一：进程的创建</h4><h5 id="1-【fork的运行规则-】以父进程为模板-创建子进程"><a href="#1-【fork的运行规则-】以父进程为模板-创建子进程" class="headerlink" title="1:【fork的运行规则:】以父进程为模板,创建子进程"></a>1:【fork的运行规则:】以父进程为模板,创建子进程</h5><ul>
<li>1.子进程会把父进程的PCB拷贝一份,稍加修饰,做为子进程的PCB</li>
<li>2.子进程会把进程的虚拟地址空间拷贝一份,做为子进程的地址空间</li>
</ul>
<h5 id="2-【进程调用fork】"><a href="#2-【进程调用fork】" class="headerlink" title="2:【进程调用fork】:"></a>2:【进程调用fork】:</h5><ul>
<li style="list-style: none"><input type="checkbox"> 当控制转移到内核中的fork代码后,内核做以下工作<ul>
<li>分配新的内存块和内核数据结构给子进程</li>
<li>将父进程部分数据结构内容拷贝至子进程</li>
<li>添加子进程到系统进程列表当中fork返回,开始调度器调度<h5 id="3-【父子进程的执行逻辑】"><a href="#3-【父子进程的执行逻辑】" class="headerlink" title="3:【父子进程的执行逻辑】"></a>3:【父子进程的执行逻辑】</h5></li>
</ul>
</li>
</ul>
<p>【代码测试】<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"before:pid=%d，ppid=%d\n"</span>,getpid(),getppid());</span><br><span class="line">   <span class="keyword">pid_t</span> pid=fork();</span><br><span class="line">   <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"father after:pid=%d,ppid=%d,父进程的返回值:%d\n"</span></span><br><span class="line">    ,getpid(),getppid(),pid);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//父进程等待子进程结束,为了在子进程结束后回收子进程的资源.</span></span><br><span class="line">    <span class="comment">//避免父进程先结束使得子进程变成孤儿进程</span></span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"child after:pid=%d,ppid=%d,子进程的返回值:%d\n"</span></span><br><span class="line">     ,getpid(),getppid());</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     perror(<span class="string">"fork"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>【运行结果】<br><img src="https://img-blog.csdnimg.cn/20190818124622491.png" alt="在这里插入图片描述"><br>【过程分析】</p>
<ul>
<li>父进程的返回值为子进程的pid,子进程返回0；</li>
<li>在fork前后父进程的pid和ppid都没有改变</li>
<li>可以看出子进程在fork() 之后并没有再去执行第一句printf语句则说明:==fork之前父进程独立执行,fork之后.父子两个执行流分别执行==<br><img src="https://img-blog.csdnimg.cn/20190818123658385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h5 id="3-【父子进程与写时拷贝】"><a href="#3-【父子进程与写时拷贝】" class="headerlink" title="3:【父子进程与写时拷贝】"></a>3:【父子进程与写时拷贝】</h5><ul>
<li style="list-style: none"><input type="checkbox"> 通常,父子代码共享.父子在不写入时,数据也是共享的.当任意一方试图写入,便以写时拷贝的方式各自一份副本</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019081813125981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>【fork常规用法】</p>
<ul>
<li>一个父进程希望复制自己,使父子进程同时执行不同的代码段.</li>
<li>一个进程要执行一个不同的程序。</li>
</ul>
<p>【fork调用失败的原因】</p>
<ul>
<li>系统中存在太多的进程<ul>
<li>实际用户的进程数超过了限制</li>
</ul>
</li>
</ul>
<h4 id="二-进程终止"><a href="#二-进程终止" class="headerlink" title="二: 进程终止"></a>二: 进程终止</h4><h5 id="1-进程退出场景"><a href="#1-进程退出场景" class="headerlink" title="1.进程退出场景"></a>1.进程退出场景</h5><ul>
<li>1.代码运行完毕,结果正确</li>
<li>2.代码运行完毕,结果不正确</li>
<li>3.代码没执行完,进程异常终止<h5 id="2-进程常见退出方法"><a href="#2-进程常见退出方法" class="headerlink" title="2.进程常见退出方法"></a>2.进程常见退出方法</h5>| 正常退出方式     | 异常退出方式     |<br>| —————- | —————- |<br>| 从main()函数返回 | Ctrl+ c,异常终止 |<br>| 调用exit         | 。。。。         |<br>| _exit            | 。。。。         |<br>【注意】</li>
<li>main函数返回值叫做进程的推出码,通过这个退出码表示运行结果是否正确</li>
</ul>
<table>
<thead>
<tr>
<th>退出码为==0==</th>
<th>退出码==非0==</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程正常终止</td>
<td>进程异常终止</td>
</tr>
</tbody>
</table>
<h5 id="3-exit-函数"><a href="#3-exit-函数" class="headerlink" title="3._exit()函数"></a>3._exit()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：status 定义了进程的终止状态,父进程通过wait来获取该值</li>
</ul>
<p>【实用实例】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"haha"</span>);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//系统调用,并没有刷新缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-exit-函数"><a href="#4-exit-函数" class="headerlink" title="4.exit()函数"></a>4.exit()函数</h5><ul>
<li>1.exit进程退出(库函数),本质上还是调用 __exit</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;                                      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"hehe"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不会打印出任何结果,在打印语句之前程序就已经结束了</li>
</ul>
<h5 id="5-【-exit与exit的对比】"><a href="#5-【-exit与exit的对比】" class="headerlink" title="5.【_exit与exit的对比】"></a>5.【_exit与exit的对比】</h5><ul>
<li style="list-style: none"><input type="checkbox"> exit最后也会调用_exit, 但在调用_exit之前,还做了其他工作：<ul>
<li>1.执行用户通过<strong>atexit</strong>或<strong>on_exit</strong>定义的清理函数。</li>
<li>2.关闭所有打开的流,所有的缓存数据均被写入</li>
<li>3.调用_exit<br><img src="https://img-blog.csdnimg.cn/20190818151121387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li style="list-style: none"><input type="checkbox"> _exit 进程退出(系统调用)</li>
<li style="list-style: none"><input type="checkbox"> _ eixt还调用了结束函数</li>
<li style="list-style: none"><input type="checkbox"> exit也能退出程序,进程退出(系统调用)底层掉用 <strong>_ exit</strong>函数–&gt; 关闭文件流并且刷新缓冲区</li>
<li style="list-style: none"><input type="checkbox"> 使用exit(n)退出后 ==使用echo $?看到的结果即为n==</li>
</ul>
</li>
</ul>
<p>【补充】</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 显示器:行缓冲,遇到换行就刷新<br>atexit(函数名) —-&gt;&lt;stdlib.h&gt;</li>
<li>注册一个回调函数</li>
<li>回调函数:掉用时机由系统决定</li>
</ul>
<p>【使用实例】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//假设 c 语言执行过程，这个过程会写一个文件(临时文件)</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"goodbye!\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     atexit(Func);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-return"><a href="#6-return" class="headerlink" title="6.return"></a>6.return</h5><ul>
<li>return是一种更常见的退出进程方法。</li>
<li><p>执行return n等同于执行exit(n),因为调用main的运行时函数会将main的返<br>回值当做 exit 的参数</p>
<h4 id="三：进程等待"><a href="#三：进程等待" class="headerlink" title="三：进程等待"></a>三：进程等待</h4></li>
<li><p>==父进程对子进程进行进程等待,是为了读取子进程的运行结果==</p>
</li>
</ul>
<h5 id="1：wait方法"><a href="#1：wait方法" class="headerlink" title="1：wait方法"></a>1：wait方法</h5><ul>
<li>1.参数为输出型参数(表示退出码 + 正常/异常退出)</li>
<li>2.返回值是子进程的 pid</li>
</ul>
<p>【注意事项】</p>
<ul>
<li>wait的使用次数必须和子进程的个数一致</li>
<li>wait的调用次数比子进程个数少,导致僵尸进程</li>
<li>wait的调用次数比子进程个数多,多出来的 wait 就会调用出错</li>
</ul>
<p>【使用实例】</p>
<ul>
<li><p>如果有多个子进程,任何一个子进程结束都会触发wait的返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两次调用fork函数只有一个wait,导致僵尸进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> ret=fork();</span><br><span class="line">   <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">     perror(<span class="string">"fork"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ret=fork();</span><br><span class="line">   <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;       </span><br><span class="line">   wait(<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>wait的调用次数比进程个数少,导致僵尸进程的产生</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190818161246138.png" alt="在这里插入图片描述"></p>
<ul>
<li>进程的创建个数必须和wait的个数匹配</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> ret=fork();</span><br><span class="line">   <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">     perror(<span class="string">"fork"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child1:ppid=%d,pid=%d\n"</span>,getppid(),getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ret=fork();</span><br><span class="line">   <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">"child2:ppid=%d,pid=%d\n"</span>,getppid(),getpid());                                                                    </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"father : %d\n"</span>,getpid()) ;</span><br><span class="line">  ret=wait(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"wait1: %d\n"</span>,ret);</span><br><span class="line">  ret=wait(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"wait2: %d\n"</span>,ret);</span><br><span class="line">  ret=wait(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"wait3: %d\n"</span>,ret);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【运行结果】<br><img src="https://img-blog.csdnimg.cn/20190818160645974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>wait的目标顺序与子进程的创建顺序一致</li>
<li>可以看到每个wait的返回值都是自己所等待的子进程的 pid</li>
</ul>
<p><code>kill -l</code></p>
<p>==显示所有信号,其中32,33两个不存在==</p>
<h5 id="2：waitpid"><a href="#2：waitpid" class="headerlink" title="2：waitpid"></a>2：waitpid</h5><h6 id="【功能简介】"><a href="#【功能简介】" class="headerlink" title="【功能简介】"></a>【功能简介】</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pid_ t <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<p>【返回值】：</p>
<ul>
<li>当==正常返回==的时候 <strong>waitpid</strong>==返回收集到的子进程的进程ID==；</li>
<li>如果设置了选项WNOH ANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；</li>
<li>如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在</li>
</ul>
<p>【参数】：</p>
<ul>
<li style="list-style: none"><input type="checkbox"> pid：</li>
<li>Pid=-1,等待任一个子进程。与wait等效。</li>
<li>Pid&gt;0.等待其进程ID与pid相等的子进程。</li>
<li style="list-style: none"><input type="checkbox"> status:</li>
<li>WIFEXITED(status): 若为正常终止子进程返回的状态,则为真.(查看进程是否是正常退出)</li>
<li>WEXITSTATUS(status): 若WIFEXITED非零,提取子进程退出码.(查看进程的退出码)</li>
<li style="list-style: none"><input type="checkbox"> options:</li>
<li>WNOHANG: 若pid指定的子进程没有结束,则waitpid()函数返回0.不予以等待</li>
<li>若正常结束,则返回该子进程的ID</li>
</ul>
<p>【使用实例】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                                          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> ret1=fork();</span><br><span class="line">  <span class="keyword">if</span>(ret1==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child1: %d\n"</span>,getpid());</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">pid_t</span> ret2=fork();</span><br><span class="line">  <span class="keyword">if</span>(ret2==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child2:%d\n"</span>,getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"father : %d\n"</span>,getpid()) ;</span><br><span class="line"> <span class="keyword">int</span> ret=waitpid(ret1,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"waitpid1: %d\n"</span>,ret);</span><br><span class="line"> ret=waitpid(ret2,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"waitpid2: %d\n"</span>,ret);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【运行结果】<br><img src="https://img-blog.csdnimg.cn/20190818163418238.png" alt="在这里插入图片描述"></p>
<ul>
<li>waitpid 用法与 wait 用法类似</li>
</ul>
<p>【非阻塞waitpid的使用】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                                        </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> ret1=fork();</span><br><span class="line">  <span class="keyword">if</span>(ret1==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child1: %d\n"</span>,getpid());</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">pid_t</span> ret2=fork();</span><br><span class="line">  <span class="keyword">if</span>(ret2==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child2:%d\n"</span>,getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"father : %d\n"</span>,getpid()) ;</span><br><span class="line"> <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> ret=waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line"> <span class="comment">//WNOHANG加上之后，waitpid就变成了非阻塞</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"waitpid1: %d\n"</span>,ret);</span><br><span class="line"> <span class="keyword">if</span>(ret&gt;<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125; </span><br><span class="line"> ++count;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"count=%d\n"</span>,count);</span><br><span class="line"> ret=waitpid(ret2,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"waitpid2: %d\n"</span>,ret);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【运行结果】<br><img src="https://img-blog.csdnimg.cn/2019081816425972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="【非阻塞轮询式的wait】"><a href="#【非阻塞轮询式的wait】" class="headerlink" title="【非阻塞轮询式的wait】"></a>【非阻塞轮询式的wait】</h6><p>【好处】:</p>
<ul>
<li>能够更加灵活的控制代码,充分利用等待时间去做其他事情</li>
</ul>
<p>【坏处】:</p>
<ul>
<li>代码写起来更复杂</li>
</ul>
<h4 id="四-进程程序替换"><a href="#四-进程程序替换" class="headerlink" title="四: 进程程序替换"></a>四: 进程程序替换</h4><h5 id="替换原理"><a href="#替换原理" class="headerlink" title="替换原理"></a>替换原理</h5><ul>
<li>fork创建出的子进程和父进程是共用同一套代码,而事实上我们更需要的是创建处的子进程能够执行一份单独的代码</li>
<li>1.程序替换不会创建新进程,也不会销毁进程</li>
<li>2.替换代码和数据(从一个可执行文件中来)</li>
<li><p>3.原有的栈和堆中的数据就全都不要了,根据新的代码的执行过程重新构建堆和栈的内容</p>
</li>
<li><p>[ ] 类似于 双击 exe  执行一个程序的过程(操作系统的加载器模块)</p>
</li>
<li style="list-style: none"><input type="checkbox"> exec函数族,参数有差异,底层原理完全相同</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before execl\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=execl(<span class="string">"/usr/bin/ls"</span>,<span class="string">"/usr/bin/ls"</span>,<span class="string">"/"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after execk%d \n"</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】</p>
<ul>
<li>程序替换经常搭配fork使用</li>
<li>一旦替换之后,就会把原来进程的代码和数据都干掉.无法继续执行原来的代码</li>
</ul>
<p>execlp：p表示PATH,自动从PATH的目录中查找可执行程序</p>
<p>execle:用户进行程序替换的时候手动执行环境变量(参数中的数组必须也要用NULL结尾)</p>
<h4 id="借助进程控制实现shell程序"><a href="#借助进程控制实现shell程序" class="headerlink" title="借助进程控制实现shell程序"></a>借助进程控制实现shell程序</h4><p><strong>开发<em>mini版的 shell</em></strong></p>
<ul>
<li>1.打印一个提示符,并且让用户输入一个指令</li>
<li>2.解析输入的命令,找到对应的可执行程序</li>
<li>3.创建子进程,子进程程序替换,来加载可执行程序</li>
<li>4.父进程进行程序等待,等待子进程结束</li>
<li>5.子进程结束,父进程从wait中返回,循环执行1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数名相同,但是函数签名不同</span></span><br><span class="line"><span class="comment">//函数签名:参数列表+cv限定符(const,colatile)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">c++ 标准库的做法</span></span><br><span class="line"><span class="comment">#include&lt;sstream&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">基于 boost 的方案是比较科学的方案</span></span><br><span class="line"><span class="comment">boost algotithm/string.hpp</span></span><br><span class="line"><span class="comment">boost::split</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//input 表示待切分命令</span></span><br><span class="line"><span class="comment">//output 表示切分结果(字符串数组)</span></span><br><span class="line"><span class="comment">//返回值表示 output 中包含了几个有效元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Split</span><span class="params">(<span class="keyword">char</span>  input[], <span class="keyword">char</span> *output[])</span></span>&#123;</span><br><span class="line">	<span class="comment">//借助 strtok 来实现</span></span><br><span class="line">	<span class="keyword">char</span> *p = strtok(input, <span class="string">" "</span>);</span><br><span class="line">	<span class="comment">//返回值指向第一个 l 的指针</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="comment">//printf("%s\n",p);</span></span><br><span class="line">		output[i] = p;</span><br><span class="line">		++i;</span><br><span class="line">		p = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">		<span class="comment">//第二次返回值指向 - 的指针</span></span><br><span class="line">		<span class="comment">//第三次返回值指向/的指针</span></span><br><span class="line">		<span class="comment">//第四次返回值为NULL</span></span><br><span class="line">	&#125;</span><br><span class="line">    output[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//这个操作是很容易被遗忘的</span></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateProcess</span><span class="params">(<span class="keyword">char</span> *argv[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) n;</span><br><span class="line">    <span class="comment">//1.创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> ret=fork();</span><br><span class="line">    <span class="comment">//2.父进程进行进程等待,子进程进行程序替换</span></span><br><span class="line">    <span class="keyword">if</span>(ret&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//father</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//child</span></span><br><span class="line">        ret=execvp(argv[<span class="number">0</span>],argv);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">"exec"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处的if条件可以省略,如果exec成功了,</span></span><br><span class="line">        <span class="comment">//程序肯定执行不到这里</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//1.打印提示符</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[myshell@localhot ~]$"</span>);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">		<span class="comment">//2.让用户输入指令</span></span><br><span class="line">		<span class="keyword">char</span> command[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="comment">//scanf("%s",command);</span></span><br><span class="line">		<span class="comment">//scanf中遇到空格打印一行命令的时候就会出错</span></span><br><span class="line">		<span class="comment">//用gets，一个参数，一次读入一行数据</span></span><br><span class="line">		gets(command);</span><br><span class="line">		<span class="comment">//TODO测试下 scanf 能否读入一行数据</span></span><br><span class="line">		<span class="comment">//printf("%s\n", command);</span></span><br><span class="line">		<span class="comment">//3.解析指令,把我们要执行那个程序识别出来,</span></span><br><span class="line">		<span class="comment">//那些是命令行参数识别出来(字符串切分)</span></span><br><span class="line">		<span class="comment">//切分结果应该是一个字符串数组</span></span><br><span class="line">		<span class="keyword">char</span> *argv[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">int</span> n = Split(command,argv);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4.创建子进程并且进行程序替换</span></span><br><span class="line">		CreateProcess(argv,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="【strtok-执行过程】"><a href="#【strtok-执行过程】" class="headerlink" title="【strtok 执行过程】"></a>【strtok 执行过程】</h5><ul>
<li>破坏原始的字符串</li>
<li>内部保存上次的切分结果</li>
<li>strtok必须循环调用,并且第一次的参数和后续的参数不一样</li>
</ul>
<h5 id="【myshell】的改进"><a href="#【myshell】的改进" class="headerlink" title="【myshell】的改进"></a>【myshell】的改进</h5><ul>
<li>1.自动获取到用户名,主机名,当前路径</li>
<li>2.需要支持 cd命令(cd 修改的是子进程的路径,对父进程没有影响)</li>
<li>需要让父进程直接支持cd(而不是创建子进程/程序替换),内建命令(父进程直接完成动作)</li>
<li>3.支持定义别名(需要在程序中维护一个键值对数据结构) std::map</li>
<li>4.支持管道</li>
<li>5.支持重定向</li>
</ul>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
			
			
			
		
			
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/jun/2019/05/20/Linux/Linux-基础IO/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/jun/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/jun/2019/05/04/Linux/Linux-系统下cat指令与more指令的异同/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2019 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/jun/js/jquery.imagesloaded.min.js"></script>
<script src="/jun/js/gallery.js"></script>
<script src="/jun/js/bootstrap.min.js"></script>
<script src="/jun/js/jquery.tableofcontents.min.js"></script>
<script src="/jun/js/tocgenerator.min.js"></script>
<script src="/jun/js/main.js"></script>
<script src="/jun/js/search.js"></script> 




<link rel="stylesheet" href="/jun/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/jun/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




</body>
</html>
