<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>C++进阶多态 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="c++进阶多态[TOC]">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="C++进阶多态">
  <meta property="og:site_name" content="Hexo">

  
    <meta property="og:image" content>
  

  
    <link rel="alternative" href="/jun/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link href="/jun/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/jun/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/jun/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/jun/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/jun/">Hexo</a><span class="split"></span><span class="title">C++进阶多态</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-05-12</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h3 id="c-进阶多态"><a href="#c-进阶多态" class="headerlink" title="c++进阶多态"></a>c++进阶多态</h3><p>[TOC]</p>
<a id="more"></a>
<h4 id="一-多态的简介"><a href="#一-多态的简介" class="headerlink" title="一.多态的简介"></a>一.多态的简介</h4><p><kbd>虚表在编译得时候生成，虚表指针在创建函数时就已经生成。(布鲁品)</kbd></p>
<h5 id="1-多态的概念"><a href="#1-多态的概念" class="headerlink" title="1.多态的概念"></a>1.多态的概念</h5><p><kbd>完成某个行为时，不同的对象去完成时会产生出不同的状态</kbd></p>
<h5 id="2-多态的构成条件"><a href="#2-多态的构成条件" class="headerlink" title="2.多态的构成条件"></a>2.多态的构成条件</h5><ul>
<li>1.调用函数的对象必须是指针或者引用(传引用和传对象的目的是避免传值时调用构造函数重新创造对象)</li>
<li>2.被调用的函数必须是虚函数,且完成了虚函数的==重写==</li>
</ul>
<h5 id="3-虚函数"><a href="#3-虚函数" class="headerlink" title="3.虚函数"></a>3.虚函数</h5><p><kbd>虚函数:就是在类的成员函数的前面加==virtual==关键字</kbd></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"买票-全价"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4-重写"><a href="#4-重写" class="headerlink" title="4.重写"></a>4.重写</h5><ul>
<li>虚函数的重写：派生类中有一个跟基类的完全相同虚函数，我们就称子类的虚函数重写了基类的虚函数，</li>
<li>完全相同是指：==函数名、参数、返回值类型都相同==。另外虚函数的重写也叫作虚函数的覆盖</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"买票-全价"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"买票-半价"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(Person&amp; p)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Student类调用时发生欺骗操作</span></span></span><br><span class="line"><span class="function"><span class="comment">//此处类型为基类的原因是:基类对象不能赋值给子类对象,存在访问越界的风险</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.BuyTicket();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person ps;</span><br><span class="line">	Student st;</span><br><span class="line">	Func(ps);</span><br><span class="line">	Func(st);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由上例可以看出基类和派生类中有虚函数的重写</li>
<li>派生类在调用Func时(参数为Person类型的引用)发生了==欺骗操作==,Student类型的对象调用参数为Person类型的函数调用成功。</li>
<li>可以看出不同类型的对象分别调用的是属于自己类型的代码段</li>
</ul>
<h6 id="虚函数重写的例外-协变"><a href="#虚函数重写的例外-协变" class="headerlink" title="虚函数重写的例外:协变"></a>虚函数重写的例外:协变</h6><ul>
<li>重写的虚函数的返回值可以不同，但是返回值类型必须分别是基类指针和派生类指针或者基类引用和派生类引用</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> A* <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> A;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> B* <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> B;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】：<strong>不规范的重写行为</strong></p>
<ul>
<li>在派生类中重写的成员函数可以不加virtual关键字，也是构成重写.因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性，我们只是重写了它。==但是这是非常不规范的，我们平时不要这样使用==</li>
</ul>
<h5 id="5-析构函数的重写问题"><a href="#5-析构函数的重写问题" class="headerlink" title="5.析构函数的重写问题"></a>5.析构函数的重写问题</h5><ul>
<li>基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。</li>
<li>这里他们的函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor，</li>
<li>这也说明基类的析构函数最好写成虚函数。</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~Person() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成多态，才能保证p1和p2指向的对象正确的调用析构函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person* p1 = <span class="keyword">new</span> Person;</span><br><span class="line">	Person* p2 = <span class="keyword">new</span> Student;</span><br><span class="line">	<span class="keyword">delete</span> p1;</span><br><span class="line">	<span class="keyword">delete</span> p2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>监视结果</li>
</ul>
<p><img src="https://i.loli.net/2019/07/24/5d381729dc06e56204.png" alt></p>
<ul>
<li>运行结果</li>
</ul>
<p><img src="https://i.loli.net/2019/07/24/5d38179f9c78d97783.png" alt></p>
<ul>
<li>可以从该程序的运行结果中看出~Person()被调用了两次，</li>
<li>第一次调用：是在new Persond的时候调用默认构造函数Person()的时候,从而引发的~Person函数的调用 </li>
<li>第二次调用：是在new Student的时候调用默认构造函数Student()的时候掉用了Person()，从而引发的~Person函数的调用</li>
</ul>
<h5 id="6-重载、覆盖-重写-、隐藏-重定义-的对比"><a href="#6-重载、覆盖-重写-、隐藏-重定义-的对比" class="headerlink" title="6.重载、覆盖(重写)、隐藏(重定义)的对比"></a>6.重载、覆盖(重写)、隐藏(重定义)的对比</h5><p><img src="https://i.loli.net/2019/07/22/5d3583fb652e714706.png" alt></p>
<ul>
<li>上图中将三者的特点做了一定的对比,可以帮助大家更清楚的认识他们各自的特点</li>
</ul>
<h4 id="二-抽象类"><a href="#二-抽象类" class="headerlink" title="二:抽象类"></a>二:抽象类</h4><h5 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h5><ul>
<li>在虚函数的后面写上 =0 ，则这个函数为==纯虚函数==。包含纯虚函数的类叫做==抽象类==(也叫接口类),</li>
<li>==抽象类不能实例化出对象==。派生类==继承后也不能实例化出对象==，只有重写纯虚函数，派生类才能实例化出对象。</li>
<li>纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。</li>
</ul>
<p>【简单总结】</p>
<ul>
<li>包含重虚函数的抽象类不能实例化对象,其派生类只有重写纯虚函数才能实例化对象</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> :</span><span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Benz-舒适"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> :</span><span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"BMW-操控"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Car c;//提示不允许使用抽象类类型Car的对象</span></span><br><span class="line">	Car* pBenz = <span class="keyword">new</span> Benz;</span><br><span class="line">	pBenz-&gt;Drive();</span><br><span class="line">	Car* pBMW = <span class="keyword">new</span> BMW;</span><br><span class="line">	pBMW-&gt;Drive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>override: <kbd>强制重写</kbd></li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2.override 修饰派生类虚函数强制完成重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> :</span><span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span> override </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Benz-舒适"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-补充-c-11-override-和-final"><a href="#2-补充-c-11-override-和-final" class="headerlink" title="2.补充(c++ 11 override 和 final)"></a>2.补充(c++ 11 override 和 final)</h5><ul>
<li>实际中==建议多使用纯虚函数+ overrid的方式来强制重写虚函数==，因为虚函数的意义就是实现多态，如果==没有重写，虚函数就没有意义==。</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span> final </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> :</span><span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Benz-舒适"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="comment">//提示错误无法重写"final函数" "Car::Drive"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>【==注意==】final 修饰基类的虚函数时,纯虚函数不能被派生类重写</li>
</ul>
<h4 id="三-多态的实现的原理"><a href="#三-多态的实现的原理" class="headerlink" title="三:多态的实现的原理"></a>三:多态的实现的原理</h4><h5 id="3-1虚函数表"><a href="#3-1虚函数表" class="headerlink" title="3.1虚函数表"></a>3.1虚函数表</h5><p>【知识点补充】</p>
<ul>
<li>虚表指针：存在于对象中，位于对象的前4/8个字节(与平台有关)</li>
<li>虚表：存放函数指针，本质为指针数组，虚表本身存在(vs)代码段</li>
<li>子类继承父类的虚表，对于子类重写的函数，覆盖掉父类对应的虚函数</li>
<li>虚表中存放虚函数的地址，不存放普通函数的地址单继承虚表结构</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里常考一道笔试题：sizeof(Base)是多少？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Func1()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Base b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过调试我们发现 sizeof(Base) 大小为8，那么除了一个int类型的变量之外的四个字节来自哪里呢？</li>
<li>原来还多一个__vfptr放在对象的前面(==注意有些平台可能会放到对象的最后面，这个跟平台有关==)，对象中的这个指针我们叫做==虚函数表指针==(v代表virtual，f代表function)。</li>
<li>一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，虚函数表也简称虚表</li>
</ul>
<p><kbd>监视结果如下图所示</kbd></p>
<p><img src="https://i.loli.net/2019/07/24/5d37bd6bd513952036.png" alt></p>
<ul>
<li>对上面程序的改进</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::Func1()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::Func2()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::Func3()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::Func1()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base b;</span><br><span class="line">	Derive d;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>监视结果</li>
</ul>
<p><img src="https://i.loli.net/2019/07/23/5d37132b6e5f664206.png" alt></p>
<p>【==总结==】</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 1.派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针中存在内容的另一部分是自己的成员。</li>
<li style="list-style: none"><input type="checkbox" checked> 2.基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。==重写是语法的叫法，覆盖是原理层的叫法==</li>
<li style="list-style: none"><input type="checkbox" checked> 3.另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但其不是虚函数，所以不会放进虚表。</li>
<li style="list-style: none"><input type="checkbox" checked> 4.==虚函数表本质是一个存虚函数指针的指针数组==，这个数组最后面放了一个nullptr。</li>
<li><p>[x] 5.总结一下派生类的虚表生成：</p>
<ul>
<li>a.先将基类中的虚表内容拷贝一份到派生类虚表中 </li>
<li>b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 </li>
<li>c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</li>
</ul>
</li>
<li><p>[x] 6.这里还有一个童鞋们很容易混淆的问题：==虚函数存在哪的？==，==虚表存在哪的==？</p>
<p> 答：虚函数存在虚表，虚表存在对象中。注意上面的回答的错的。但是很多童鞋都是这样深以为然。</p>
<p>==注意虚表存的是虚函数指针,不是虚函数,虚函数和普通函数一样,都是存在代码段的，只是他的指针又存到了虚表中==。==另外对象中存的不是虚表，存的是虚表指针==。</p>
</li>
</ul>
<p><kbd>那么虚表存在哪的呢？</kbd></p>
<ul>
<li>实际我们去验证一下会发现vs下是存在代码段的</li>
</ul>
<h5 id="3-2多态的原理"><a href="#3-2多态的原理" class="headerlink" title="3.2多态的原理"></a>3.2多态的原理</h5><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"买票-全价"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"买票-半价"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(Person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.BuyTicket();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VFPTR)</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVTable</span><span class="params">(VFPTR vTable[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 依次取虚表中的虚函数指针打印并调用。调用就可以看出存的是哪个函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" 虚表地址&gt;"</span> &lt;&lt; vTable &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vTable[i] != <span class="literal">nullptr</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" 第%d个虚函数地址 :0X%x,-&gt;"</span>, i, vTable[i]);</span><br><span class="line">		VFPTR f = vTable[i];</span><br><span class="line">		f();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person Mike;</span><br><span class="line">	Student Johnson;</span><br><span class="line">	VFPTR* vTableb = (VFPTR*)(*(<span class="keyword">int</span>*)&amp;Mike);</span><br><span class="line">	PrintVTable(vTableb);</span><br><span class="line">	VFPTR* vTabled = (VFPTR*)(*(<span class="keyword">int</span>*)&amp;Johnson);</span><br><span class="line">	PrintVTable(vTabled);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用关系</li>
</ul>
<p><img src="https://i.loli.net/2019/07/23/5d3726c6738f630942.png" alt></p>
<p><img src="https://i.loli.net/2019/07/23/5d37271889ac061948.png" alt></p>
<p><code>我们可以看到两个不同类型的对象通过调用相同的函数Func调用了不同的BuyTicke函数，没有因为Func函数的参数类型而影响最终结果。原因为他们在各自的虚基表中存储的是不同的虚表地址从而调用了不同的函数</code></p>
<ul>
<li>监视结果</li>
</ul>
<p><img src="https://i.loli.net/2019/07/23/5d371e3c553d261335.png" alt></p>
<ul>
<li>运行结果</li>
</ul>
<p><img src="https://i.loli.net/2019/07/24/5d3824529438126935.png" alt></p>
<ul>
<li>当p是指向mike对象时,p-&gt;BuyTicket在mile的虚表中找到虚函数是Person::BuyTicket</li>
<li>当p是指向johnson对象时,p-&gt;BuyTicket在johnson的虚表中找到虚函数是Student::BuyTicket</li>
<li>这样的话就可以实现不同的对象去完成同一行为时,展现出不同的形态</li>
</ul>
<h5 id="3-3-动态绑定与静态绑定"><a href="#3-3-动态绑定与静态绑定" class="headerlink" title="3.3 动态绑定与静态绑定"></a>3.3 动态绑定与静态绑定</h5><ul>
<li><p>静态绑定又称为前期绑定(早绑定)，在程序编译期间确定了程序的行为，也称为静态多态，比如：函数重载</p>
</li>
<li><p>动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态。</p>
</li>
</ul>
<p>####四.单继承和多继承关系的虚函数表</p>
<h5 id="4-1单继承中的虚函数表"><a href="#4-1单继承中的虚函数表" class="headerlink" title="4.1单继承中的虚函数表"></a>4.1单继承中的虚函数表</h5><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::func1"</span> &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::func2"</span> &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Derive::func1"</span> &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Derive::func3"</span> &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Derive::func4"</span> &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>观察下图中的监视窗口中我们发现看不见func3和func4。这里是编译器的监视窗口==故意隐藏==了这两个函数.</p>
</blockquote>
<ul>
<li>监视结果如图所示</li>
</ul>
<p><img src="https://i.loli.net/2019/07/24/5d37cb84aeb2672477.png" alt></p>
<p><kbd>那么我们如何查看d的虚表呢？</kbd></p>
<ul>
<li><p>解决办法</p>
</li>
<li><p>[x]  思路：取出b、d对象的头4bytes，就是虚表的指针，前面我们说了虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr</p>
</li>
<li><p>1.先取b的地址，强转成一个int<em>的指针</em></p>
</li>
<li>2.再解引用取值，就取到了b对象头4bytes的值，这个值就是指向虚表的指针</li>
<li>3.再强转成VFPTR*，因为虚表就是一个存VFPTR类型(虚函数指针类型)的数组。</li>
<li>4.虚表指针传递给PrintVTable进行打印虚表</li>
<li>5.需要说明的是这个打印虚表的代码经常会崩溃，因为编译器有时对虚表的处理不干净，虚表最后面没有放nullptr，导致越界，这是编译器的问题。我们只需要点目录栏的-生成-清理解决方案，再编译就好了。</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::func1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::func2"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::func1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::func3"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::func4"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VFPTR)</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVTable</span><span class="params">(VFPTR vTable[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 依次取虚表中的虚函数指针打印并调用。调用就可以看出存的是哪个函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" 虚表地址&gt;"</span> &lt;&lt; vTable &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vTable[i] != <span class="literal">nullptr</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" 第%d个虚函数地址 :0X%x,-&gt;"</span>, i, vTable[i]);</span><br><span class="line">		VFPTR f = vTable[i];</span><br><span class="line">		f();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base b;</span><br><span class="line">	Derive d;</span><br><span class="line">	VFPTR* vTableb = (VFPTR*)(*(<span class="keyword">int</span>*)&amp;b);</span><br><span class="line">	PrintVTable(vTableb);</span><br><span class="line">	VFPTR* vTabled = (VFPTR*)(*(<span class="keyword">int</span>*)&amp;d);</span><br><span class="line">	PrintVTable(vTabled);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果 </li>
</ul>
<p><img src="https://i.loli.net/2019/07/24/5d3803b41e43357021.png" alt></p>
<ul>
<li>在派生类中重写了虚函数fun1从而发生了覆盖现象</li>
</ul>
<h4 id="4-2-多继承中的虚函数表"><a href="#4-2-多继承中的虚函数表" class="headerlink" title="4.2:多继承中的虚函数表"></a>4.2:多继承中的虚函数表</h4><ul>
<li>验证程序</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::func1"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::func2"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> b1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::func1"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::func2"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::func1"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::func3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> d1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VFPTR)</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVTable</span><span class="params">(VFPTR vTable[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" 虚表地址&gt;"</span> &lt;&lt; vTable &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vTable[i] != <span class="literal">nullptr</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" 第%d个虚函数地址 :0X%x,-&gt;"</span>, i, vTable[i]);</span><br><span class="line">		VFPTR f = vTable[i];</span><br><span class="line">	f();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derive d;</span><br><span class="line">	VFPTR* vTableb1 = (VFPTR*)(*(<span class="keyword">int</span>*)&amp;d);</span><br><span class="line">	PrintVTable(vTableb1);</span><br><span class="line">	VFPTR* vTableb2 = (VFPTR*)(*(<span class="keyword">int</span>*)((<span class="keyword">char</span>*)&amp;d+<span class="keyword">sizeof</span>(Base1)));</span><br><span class="line">	PrintVTable(vTableb2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<p><img src="https://i.loli.net/2019/07/24/5d380c67ad5aa14461.png" alt></p>
<ul>
<li>调用情况图示</li>
</ul>
<p><img src="https://i.loli.net/2019/07/24/5d380c33d26ae52434.png" alt></p>
<ul>
<li>由该图可以看出:==多继承派生类的未重写的虚函数放在第一个继承基类部分的虚函数表中==</li>
</ul>
<p>【推荐链接】:包含C++ 虚表函数解析</p>
<p><strong><a href="https://coolshell.cn/articles/12165.html" target="_blank" rel="noopener">https://coolshell.cn/articles/12165.html</a></strong></p>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
			
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
			
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
	
	
	
		<li class="prev"><a href="/jun/2019/05/12/Cpp/Cpp进阶异常/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/jun/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/jun/2019/04/18/Cpp/继承/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2019 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/jun/js/jquery.imagesloaded.min.js"></script>
<script src="/jun/js/gallery.js"></script>
<script src="/jun/js/bootstrap.min.js"></script>
<script src="/jun/js/jquery.tableofcontents.min.js"></script>
<script src="/jun/js/tocgenerator.min.js"></script>
<script src="/jun/js/main.js"></script>
<script src="/jun/js/search.js"></script> 




<link rel="stylesheet" href="/jun/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/jun/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




</body>
</html>
