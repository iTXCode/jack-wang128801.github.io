<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>网络基础2 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="网络基础2自定制协议
[ ] 1.客户端给服务器发送的请求是啥样的?

a.包含哪些信息(要参与运算的数字有哪些)

b.这些信息咋组织(如何用一个字符串把要传输的信息表示出来)     



​    序列化:把一些信息组织成字符串
​    反序列:把字符串解析成一些信息


[ ] 2.服务">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="网络基础2">
  <meta property="og:site_name" content="Hexo">

  
    <meta property="og:image" content>
  

  
    <link rel="alternative" href="/jun/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link href="/jun/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/jun/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/jun/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/jun/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/jun/">Hexo</a><span class="split"></span><span class="title">网络基础2</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-06-14</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h3 id="网络基础2"><a href="#网络基础2" class="headerlink" title="网络基础2"></a>网络基础2</h3><h4 id="自定制协议"><a href="#自定制协议" class="headerlink" title="自定制协议"></a>自定制协议</h4><ul>
<li><p>[ ] 1.客户端给服务器发送的请求是啥样的?</p>
</li>
<li><p>a.包含哪些信息(要参与运算的数字有哪些)</p>
</li>
<li><p>b.这些信息咋组织(如何用一个字符串把要传输的信息表示出来)     </p>
</li>
</ul>
<blockquote>
<p>​    序列化:把一些信息组织成字符串</p>
<p>​    反序列:把字符串解析成一些信息</p>
</blockquote>
<ul>
<li><p>[ ] 2.服务器给客户端的响应是啥样的?</p>
</li>
<li><p>a.包含那些信息(运算结果)</p>
</li>
<li><p>b.这些信息咋组织(也是一个字符串)</p>
</li>
</ul>
<blockquote>
<p>JSON-&gt;JavaScript—&gt;(升级)TypeScript(MS)    JS的超集</p>
<p>​                                  Flutter(谷歌)移动端开发框架</p>
</blockquote>
<p>==Json== </p>
<ul>
<li>序列化优点：直观,方便调试</li>
<li>缺点：效率低(相比于protobuf)</li>
</ul>
<p>==google protobuf==(二进制的方式序列化)</p>
<ul>
<li>优点：</li>
<li>缺点：</li>
</ul>
<p><strong>键值对</strong></p>
<p>利用key查找对应的valve.(拿到学号找对应的学生)</p>
<p><strong>使用Json的方式进行序列化和反序列化</strong></p>
<blockquote>
<p>yum list | grep jsoncpp</p>
<p>root: yum install  jsoncpp-devel.x86_64  </p>
</blockquote>
<blockquote>
<p>如何使用json格式？ 涉及到编译原理中的一些概念</p>
<p>借助第三方库，直接完成解析操作 </p>
<p>jsoncpp</p>
<p>Json::Vlaue 用来表示一个Json数据</p>
<p>Json::Reader 把字符串转换成 Json::Value</p>
<p>Json::Writer 把 Json::Value 转换成字符串</p>
</blockquote>
<hr>
<blockquote>
<p>根据反序列化的结果，进形计算</p>
<p>需要把结果再序列化会一个字符串</p>
</blockquote>
<p><strong>客户端</strong></p>
<blockquote>
<p>1.创建一个tcp客户端</p>
<p>2.循环从标准输入读取数据</p>
<p>3.根据用户输入的内容，构建一个 Json 对象</p>
<p>4.把 Json 对象序列化成一个字符串</p>
<p>5.把字符串发送到服务器端</p>
<p>6.从服务器读取返回的结果</p>
<p>7.把服务器返回的结果再进行Json解析</p>
</blockquote>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="认识URL-我们俗称的”网址“"><a href="#认识URL-我们俗称的”网址“" class="headerlink" title="认识URL(我们俗称的”网址“)"></a>认识URL(我们俗称的”网址“)</h5><ul>
<li>表示资源唯一的限定标记</li>
</ul>
<p><strong>域名</strong></p>
<blockquote>
<p>IP和域名是等价的</p>
<p>工具：UrlEncode 编码</p>
<p><strong>fiddler(代理)抓包工具</strong>:浏览器和服务器之间的中介(收费站)</p>
</blockquote>
<p>主机与服务器之间负责数据交换的工具</p>
<p><strong>HTTP协议格式</strong></p>
<p><strong>请求</strong></p>
<blockquote>
<p><strong>1.首行(使用空格区分)</strong></p>
<p>a:方法(GET/POST/PUT/DELETE/HEAD)</p>
<p>b:url</p>
<p>c: http 版本号.HTTP/1.1(当前最常见的版本)</p>
<p><strong>2.头部信息(header)</strong></p>
<p>包含了若干行</p>
<p>每行是一个键值对，键和值之间用 ：分割</p>
<p><strong>3：空行</strong></p>
<p>表示header的结束</p>
<p><strong>4:请求体(body)</strong></p>
<p>空格后面的内容都是body</p>
<p>body 是可选的，可以有也可以没有</p>
<p>一般来说 GET 请求不带body  ,POST/PUT 请求带body </p>
<hr>
</blockquote>
<p><strong>响应</strong></p>
<blockquote>
<p><strong>1.首行</strong></p>
<p>a:版本号</p>
<p>b:状态码(200)：表示http请求的成功失败</p>
<p>c:状态码的描述信息(OK)</p>
<p><strong>2.header</strong></p>
<p>a:有若干行，每行有一个header(键值对)</p>
<p>b:键和值之间用 “:”分隔</p>
<p><strong>3:空行</strong></p>
<p>表示的是header的结束</p>
<p><strong>4.请求体</strong></p>
<p>空行之后的body </p>
<hr>
</blockquote>
<p><strong>出现概率极高的 面试题</strong></p>
<blockquote>
<p>1.说说HTTP协议中常见的方法是那些？</p>
<p>2.GET和POST的区别？</p>
<p>GET往往把参数放到query_string中</p>
<p>POST往往把参数放到body中</p>
<p>3.说说常见的HTTP状态码有哪些，分别是啥含义?</p>
<p>200 表示 OK</p>
<p>302 Found 表示重定向 /303 See Other 重定向/Location 字段表示重定向</p>
<p>403 表示用户没有权限访问</p>
<p>404 Not Found 没有找到指定的资源</p>
<p>502 Bad Gateway   服务器挂了</p>
<p>504 Gateway Timeout 服务器访问超时</p>
<p><strong>一般情况</strong></p>
<p>2* 请求成功</p>
<p>3*重定向</p>
<p>4*客户端出现错误</p>
<p>5* 服务器出现错误</p>
<p>418: 彩蛋</p>
<hr>
</blockquote>
<h4 id="HTTP常见的-Header"><a href="#HTTP常见的-Header" class="headerlink" title="HTTP常见的 Header"></a>HTTP常见的 Header</h4><p><strong>Content-Type:</strong></p>
<blockquote>
<p>描述了body的部分数据格式的类型 txt/html</p>
</blockquote>
<p><strong>Content-Length:</strong></p>
<blockquote>
<p> 描述body 部分的长度(字节) </p>
</blockquote>
<p><strong>Host: </strong></p>
<blockquote>
<p> 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上; </p>
</blockquote>
<p><strong>User-Agent:</strong> </p>
<blockquote>
<p> 描述操作系统和浏览器版本信息; </p>
</blockquote>
<p><strong>referer:</strong> </p>
<blockquote>
<p>当前页面是从哪个页面跳转过来的; </p>
</blockquote>
<p><strong>location:</strong> </p>
<blockquote>
<p> 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问; </p>
</blockquote>
<p><strong>Cookie:</strong></p>
<blockquote>
<p> 是一个保存在浏览器端的字符串，字符串的含义是由程序员内部约定的,外部的用户一般看不懂含义</p>
<p>Cookie中最常见的内容是用户的身份信息</p>
<p>当我们登录账号是的时候，服务器就会返回一个身份信息字符串，</p>
<p>浏览器保存在cookie中</p>
</blockquote>
<blockquote>
<p>用于存储用户登陆网站的信息 (身份，密码，时间等)</p>
</blockquote>
<p><strong>localStorage:也可以起到与Cookie相同的作用但是功能更强大</strong></p>
<p>如果使用虚拟机来搭建服务器要先关闭防火墙</p>
<p>进入root 用户</p>
<p>server firewalld stop #centos 7 的关闭方式</p>
<p>爬虫jish</p>
<p><strong>一个进程能否绑定多个端口：可以</strong></p>
<p>​               </p>
<table>
<thead>
<tr>
<th>字节数</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP协议段格式</td>
<td>源端口</td>
<td>目的端口</td>
<td>UDP长度</td>
<td>校验和</td>
</tr>
</tbody>
</table>
<p>UDP中使用的是比较简单的CRC校验</p>
<p>unit16_t check——sum;</p>
<p>遍历数据报的每个字节，就往往check_sum 上+</p>
<p>发送端会根据数据内容计算一个校验和</p>
<p>数据到达接收端之后，也会计算一个校验和</p>
<p>接收端拿着自己计算好 的校验和和发送端发过来的校验和对比。如果不相等，说明数据已经出错了</p>
<blockquote>
<p>md5:字符串哈希算法</p>
<p>1.不管源字符串多长，得到的 hash结果都是固定的长度(64/128位)</p>
<p>2.原串如果想同，得到的hash一定相同;原串结果不同(哪怕差别很小 )，得到的hash值也会差别很大</p>
<p>3.根据原串得到的md5很简单，但是根据md5推算原串理论上不可能，md5sum命令特别长用。把md5当作校验和来使用了。</p>
</blockquote>
<p>有没有很可能出现不同的原串，md5值碰巧相同？理论上存在，但是在工程上，不考虑这件事情。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h5 id="TCP的协议报头和TCP的数据部分-完整的应用层数据报"><a href="#TCP的协议报头和TCP的数据部分-完整的应用层数据报" class="headerlink" title="TCP的协议报头和TCP的数据部分(完整的应用层数据报)"></a>TCP的协议报头和TCP的数据部分(完整的应用层数据报)</h5><h4 id="TCP协议报头内容"><a href="#TCP协议报头内容" class="headerlink" title="TCP协议报头内容"></a>TCP协议报头内容</h4><h5 id="TCP的作用"><a href="#TCP的作用" class="headerlink" title="TCP的作用"></a>TCP的作用</h5><blockquote>
<p>保证有效传输</p>
<p>:能够及时的发现自己发送的数据是成功还是失败</p>
</blockquote>
<blockquote>
<p>尽可能的提高传输效率</p>
</blockquote>
<h3 id="TCP的可靠性"><a href="#TCP的可靠性" class="headerlink" title="TCP的可靠性"></a>TCP的可靠性</h3><h5 id="1-确认应答"><a href="#1-确认应答" class="headerlink" title="1.确认应答"></a>1.确认应答</h5><p><strong>需要对数据进行编号</strong></p>
<p><strong>确认应答数据中要指明的是哪个序号</strong></p>
<p><strong>确认序号的含义是当前序号之前的数据已经收到，希望收到下一条数据就是从确认序列号开始的</strong></p>
<h5 id="2-超时重传机制"><a href="#2-超时重传机制" class="headerlink" title="2.超时重传机制"></a>2.超时重传机制</h5><p><strong>1.超时时间会依次变长(悲观的态度去面对丢包的)</strong></p>
<p><strong>2.自动去重:(通过序号进行去重)</strong></p>
<p><strong>发送上一条消息后未收到回复，进行重发确保消息被收到</strong></p>
<blockquote>
<ul>
<li><strong>情况一：发送的数据丢失了 </strong></li>
<li><strong>情况二：发送端没有收到相应端的确认应答</strong></li>
</ul>
</blockquote>
<h5 id="3-连接管理"><a href="#3-连接管理" class="headerlink" title="3.连接管理"></a>3.连接管理</h5><h6 id="1-建立连接-建立三次握手"><a href="#1-建立连接-建立三次握手" class="headerlink" title="1.建立连接(建立三次握手)"></a>1.建立连接(建立三次握手)</h6><p><strong>a.先去检查网络的联通状态</strong></p>
<p><strong>b.协商一些关键的数据</strong></p>
<ul>
<li>三次握手的基本流程</li>
</ul>
<table>
<thead>
<tr>
<th>客户端</th>
<th>关系</th>
<th>服务器端</th>
</tr>
</thead>
<tbody>
<tr>
<td>客户端</td>
<td>—&gt;    1.SYN同步报文段</td>
<td>服务器端</td>
</tr>
<tr>
<td>客户端</td>
<td>2.SYN+ACK确认报文段  &lt;—</td>
<td>服务器端</td>
</tr>
<tr>
<td>客户端</td>
<td>—-&gt;     3.ACK</td>
<td>服务器端</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>【备注 】 :—-&gt;表示传送方向</li>
<li>【注意】:SYN和ACK都是内核控制发送的</li>
</ul>
</blockquote>
<p><strong>2.断开连接(四次挥手)</strong></p>
<p><strong>a.双方各自给对方发送FIN，各自给对方发送ACK</strong></p>
<p><strong>b.第一个的ACK和第二个的FIN不能合并到一起</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">客户端</th>
<th style="text-align:center">关系</th>
<th style="text-align:center">服务器端</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">客户端</td>
<td style="text-align:center">—&gt;     FIN结束报文段</td>
<td style="text-align:center">服务器端</td>
</tr>
<tr>
<td style="text-align:center">客户端</td>
<td style="text-align:center">ACK               &lt;—</td>
<td style="text-align:center">服务器端</td>
</tr>
<tr>
<td style="text-align:center">客户端</td>
<td style="text-align:center">FIN结束报文段&lt;—</td>
<td style="text-align:center">服务器端</td>
</tr>
<tr>
<td style="text-align:center">客户端</td>
<td style="text-align:center">—&gt;      ACK</td>
<td style="text-align:center">服务器端</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>【触发条件】:调用close函数触发断开连接close发送FIN</li>
<li>【注意】：内核回复ACK,进入CLOSE_WAIT状态</li>
</ul>
</blockquote>
<h4 id="重要的TCP状态"><a href="#重要的TCP状态" class="headerlink" title="重要的TCP状态"></a>重要的TCP状态</h4><h6 id="1-LISTEN服务器启动完成-手机开机，信号良好"><a href="#1-LISTEN服务器启动完成-手机开机，信号良好" class="headerlink" title="1.LISTEN服务器启动完成(手机开机，信号良好)"></a>1.LISTEN服务器启动完成(手机开机，信号良好)</h6><h6 id="2-ESTABLISHED-建立连接成功-可以进行通信了"><a href="#2-ESTABLISHED-建立连接成功-可以进行通信了" class="headerlink" title="2.ESTABLISHED 建立连接成功,可以进行通信了"></a>2.ESTABLISHED 建立连接成功,可以进行通信了</h6><h6 id="3-CLOSE-WAIT等待调用close函数，对端已经执行过close"><a href="#3-CLOSE-WAIT等待调用close函数，对端已经执行过close" class="headerlink" title="3.CLOSE_WAIT等待调用close函数，对端已经执行过close"></a>3.CLOSE_WAIT等待调用close函数，对端已经执行过close</h6><blockquote>
<ul>
<li><strong>如果服务器端出现大量的CLOSE_WAIT状态</strong> ,是什么原因?</li>
<li>代码中忘记调试,代码有bug</li>
<li><strong>谁主动调用close谁调TIME_WAIT</strong></li>
</ul>
</blockquote>
<h6 id="4-TIME-WAIT保证-最后一个ACK如果丢包还有机会重传即使客户端的进程已经退出了，TIME-WAIT状态仍然可能存在。如果此时最后一个ACK丢了，对端重传的FIN可以有机会去进行处理-收到对方的FIN开始进入该状态"><a href="#4-TIME-WAIT保证-最后一个ACK如果丢包还有机会重传即使客户端的进程已经退出了，TIME-WAIT状态仍然可能存在。如果此时最后一个ACK丢了，对端重传的FIN可以有机会去进行处理-收到对方的FIN开始进入该状态" class="headerlink" title="4.TIME_WAIT保证 最后一个ACK如果丢包还有机会重传即使客户端的进程已经退出了，TIME_WAIT状态仍然可能存在。如果此时最后一个ACK丢了，对端重传的FIN可以有机会去进行处理(收到对方的FIN开始进入该状态)"></a>4.TIME_WAIT保证 最后一个ACK如果丢包还有机会重传即使客户端的进程已经退出了，TIME_WAIT状态仍然可能存在。如果此时最后一个ACK丢了，对端重传的FIN可以有机会去进行处理(收到对方的FIN开始进入该状态)</h6><blockquote>
<ul>
<li><strong>TIME_WAIT  会保持2MSL这样的时间</strong></li>
<li><strong>MSL表示网络中的两个节点之间，传输一个数据所经历的最大时间</strong></li>
<li><strong>centos7 MSL默认为 60s</strong></li>
</ul>
</blockquote>
<h6 id="TODO-添加待办事项"><a href="#TODO-添加待办事项" class="headerlink" title="TODO(添加待办事项)"></a>TODO(添加待办事项)</h6><h5 id="4-滑动窗口-提高传输效率"><a href="#4-滑动窗口-提高传输效率" class="headerlink" title="4.滑动窗口(提高传输效率)"></a>4.滑动窗口(提高传输效率)</h5><ul>
<li><strong>批量发送数据</strong>“”</li>
<li><strong>批量发送的数据量称为窗口大小,</strong></li>
<li><strong>窗口越大，网络吞吐率就越高</strong></li>
<li><strong>窗口也不能无限大(要保证可靠性)</strong></li>
</ul>
<blockquote>
<p><strong>1.发送方如果发的太快，接收方可能处理不过来。</strong></p>
<ul>
<li>发送方限制窗口大小的方法</li>
</ul>
<p><strong>解决办法：流量控制</strong></p>
</blockquote>
<blockquote>
<p>发送方发送的数据先到达接收方的网卡，然后放到内核中的接收缓冲区中</p>
<p>接收方的用户代码从接收缓冲区中取数据(recv/read)</p>
<p><strong>2.如果当前网络比较拥堵，发送方如果发送的很快。仍然会丢包；</strong></p>
<p><strong>解决办法:拥塞控制(真实的发送方的窗口大小是流量控制和拥塞控制两者的窗口大小的较小值)</strong></p>
</blockquote>
<ul>
<li><strong>需要有一个发送缓冲区来保存那些数据需要等待ACK，没有收到ACK的数据随时可能触发超市重传</strong></li>
<li><strong>快速重传 和超时重传本质是一样的,</strong></li>
</ul>
<p><strong>ACK丢了没事，只要不是全丢那就没事</strong></p>
<p><strong>数据包丢了，必须进行重传</strong></p>
<h5 id="5-流量控制-解决窗口的问题"><a href="#5-流量控制-解决窗口的问题" class="headerlink" title="5.流量控制(解决窗口的问题)"></a>5.流量控制(解决窗口的问题)</h5><blockquote>
<p><strong>接收缓冲区的空余空间大小，用这个指标来衡量接收端的处理能力</strong></p>
<p><strong>TCP协议报头中有一个窗口大小字段，这个字段是和接收缓冲区的空间大小相关联的</strong></p>
<p><strong>假设接收缓冲区空余空间是1K,此时这个窗口大小字段也就是1K建议发送方按照1K这样的窗口大小来发送数据</strong></p>
</blockquote>
<h5 id="6-拥塞控制-网络方面的拥堵情况"><a href="#6-拥塞控制-网络方面的拥堵情况" class="headerlink" title="6.拥塞控制(网络方面的拥堵情况)"></a>6.拥塞控制(网络方面的拥堵情况)</h5><blockquote>
<p><strong>根据丢包情况作为判定依据</strong></p>
<p><strong>如果出现丢包,认为网络比较拥堵。如果没丢包，认为网络比较畅通</strong></p>
<p><strong>慢开始：刚开始的时候按照一个比较小的窗口来发送数据，如果没丢包，就按照指数的形式提升窗口大小。如果窗口大小达到指定的阀值之后，变成线性增长</strong></p>
<p><strong>当窗口达到一定的大小之后，就会发生丢包，一旦丢包，认为网络拥堵了，就把窗口大小一下就设回一个非常小的值，重复慢开始的过程</strong></p>
</blockquote>
<h5 id="7-延时应答-提高传输效率"><a href="#7-延时应答-提高传输效率" class="headerlink" title="7.延时应答(提高传输效率)"></a>7.延时应答(提高传输效率)</h5><blockquote>
<p><strong>和滑动窗口密切相关。想办法在可靠性的前提下尽量让窗口大</strong></p>
</blockquote>
<blockquote>
<ul>
<li>数据限制：每隔N个包就应答一次；</li>
<li>时间限制：超过最大延迟时间就应答一次；</li>
</ul>
</blockquote>
<h5 id="8-捎带应答-提高传输效率"><a href="#8-捎带应答-提高传输效率" class="headerlink" title="8.捎带应答(提高传输效率)"></a>8.捎带应答(提高传输效率)</h5><blockquote>
<p><strong>延时应答的基础上，引入的一个机制</strong></p>
<p><strong>TCP挥手有没有可能是三次呢？</strong></p>
<p><strong>有可能，捎带应答在支持这件事情</strong></p>
</blockquote>
<h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><blockquote>
<p><strong>创建一个TCP的socket，同时在内核中创建一个发送缓冲区和一个接收缓冲区</strong></p>
<p><strong>收到的数据先到达接收缓冲区，用户代码从接收缓冲区中读走数据之后才会把数据清掉(recv/read)，接收缓冲区也能帮助我们进行数据的去重</strong></p>
</blockquote>
<ul>
<li>发送缓冲区的功能</li>
</ul>
<blockquote>
<ul>
<li>调用send本质上是把用户的数据拷贝到内盒的发送缓冲区中,再由内核按照滑动窗口的方式把数据批量发送到对端,如果丢包就会重传对应的数据</li>
</ul>
</blockquote>
<ul>
<li>接收缓冲区功能</li>
</ul>
<blockquote>
<ul>
<li>收到的数据先到达接收缓冲区，用户代码冲接收缓冲区中读走之后才能把数据清掉(recv/read),接受缓冲区也有可能帮助我们进行数据去重</li>
</ul>
</blockquote>
<h5 id="9-粘包问题"><a href="#9-粘包问题" class="headerlink" title="9.粘包问题"></a>9.粘包问题</h5><ul>
<li><strong>面向字节流相关，应用程序如何能依次取出一个完整的应用层数据报</strong></li>
<li>TCP无法解决这个问题</li>
<li><strong>只有从应用层的角度来解决这个问题，只要能够确定数据报和数据报之间的边界就可以了</strong></li>
</ul>
<h4 id="确定边界的方法"><a href="#确定边界的方法" class="headerlink" title="确定边界的方法"></a>确定边界的方法</h4><ul>
<li><ol>
<li><strong>分隔符</strong></li>
</ol>
</li>
<li><ol start="2">
<li><strong>指定长度</strong></li>
</ol>
</li>
</ul>
<h3 id="抓包工具：wrieshark，tcpdump-命令行版本的抓包工具"><a href="#抓包工具：wrieshark，tcpdump-命令行版本的抓包工具" class="headerlink" title="抓包工具：wrieshark，tcpdump(命令行版本的抓包工具)"></a>抓包工具：wrieshark，tcpdump(命令行版本的抓包工具)</h3><h5 id="10-TCP的异常情况"><a href="#10-TCP的异常情况" class="headerlink" title="10.TCP的异常情况"></a>10.TCP的异常情况</h5><blockquote>
<p>1.进程终止</p>
<p>2.机器重启</p>
<p>3.机器掉线/网线断开:</p>
</blockquote>
<blockquote>
<p>先超时重传。</p>
<p>达到一定情况下，尝试进行复位</p>
</blockquote>
<h5 id="TCP小结"><a href="#TCP小结" class="headerlink" title="TCP小结"></a>TCP小结</h5><table>
<thead>
<tr>
<th>可靠性</th>
<th>传输效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>确认应答/超时重传</td>
<td>滑动窗口(流量控制/拥堵控制)</td>
</tr>
<tr>
<td>连接管理</td>
<td>延时应答（捎带应答）</td>
</tr>
</tbody>
</table>
<h3 id="TCP-IP协议（三卷）"><a href="#TCP-IP协议（三卷）" class="headerlink" title="TCP/IP协议（三卷）"></a>TCP/IP协议（三卷）</h3><p>卷一主要讲原理</p>
<p>卷二卷三讲原码实现</p>
<h3 id="Linux内核源代码"><a href="#Linux内核源代码" class="headerlink" title="Linux内核源代码"></a>Linux内核源代码</h3><h3 id="TCP-UDP对比"><a href="#TCP-UDP对比" class="headerlink" title="TCP/UDP对比"></a>TCP/UDP对比</h3><blockquote>
<p>1.如果需要可靠性(比如外网复杂的网络环境 )优先考虑TCP</p>
<p>2.如果网络结构本身比较简单，可靠性比较高(机房内网)，对传输效率要求更高，优先考虑UDP</p>
<p>3.如果你要传输的数据报比较大，TCP(UDP的包有最大长度64K)</p>
<p>4.如果需要广播的话，只能用UDP，TCP不能广播</p>
</blockquote>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
			
			
			
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/jun/2019/07/09/Linux/网络基础3/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/jun/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/jun/2019/06/07/Linux/网络编程套接字/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2019 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/jun/js/jquery.imagesloaded.min.js"></script>
<script src="/jun/js/gallery.js"></script>
<script src="/jun/js/bootstrap.min.js"></script>
<script src="/jun/js/jquery.tableofcontents.min.js"></script>
<script src="/jun/js/tocgenerator.min.js"></script>
<script src="/jun/js/main.js"></script>
<script src="/jun/js/search.js"></script> 




<link rel="stylesheet" href="/jun/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/jun/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




</body>
</html>
