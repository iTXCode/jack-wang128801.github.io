<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Cpp进阶☞继承 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="[TOC]">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Cpp进阶☞继承">
  <meta property="og:site_name" content="Hexo">

  
    <meta property="og:image" content>
  

  
    <link rel="alternative" href="/jun/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link href="/jun/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/jun/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/jun/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/jun/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/jun/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/jun/">Hexo</a><span class="split"></span><span class="title">Cpp进阶☞继承</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-08-04</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <p>[TOC]</p>
<a id="more"></a>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="1-对继承的理解"><a href="#1-对继承的理解" class="headerlink" title="1. 对继承的理解"></a>1. 对继承的理解</h4><p><strong>a.继承的理解：</strong> class(类)级别的代码复用</p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"name:"</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; _age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> _name = <span class="string">"peter"</span>; <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">int</span> _age = <span class="number">18</span>; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person  <span class="comment">//继承了Person 的内容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _stuid= <span class="number">4170903</span>; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _jobid=<span class="number">147632</span>; <span class="comment">// 工号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Student s;</span><br><span class="line">	Teacher t;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>监视结果</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93eDMuc2luYWltZy5jbi9tdzY5MC8wMDcxT0U3c2x5MWcyN3VpbjU1ZXBqMzBlZzBhZHdmNS5qcGc" alt></p>
<ul>
<li>由上图可以看到==Student和Teacher类中出现了自己内部并没有定义的Person类==他们从Person类哪里 <strong>继承</strong> 了Person类中的内容。</li>
</ul>
<p><strong>继承的图例说明</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93eDMuc2luYWltZy5jbi9tdzY5MC8wMDcxT0U3c2x5MWcyN3d3MTNuZjFqMzBmbzBhNHEyeC5qcGc" alt></p>
<p>==注意：Student类中此时只有 _name, _age ， _stuid三个变量，并没有Person这个内部类，Teacher类中也没有Person这个类==</p>
<p><strong>运行结果</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93eDMuc2luYWltZy5jbi9tdzY5MC8wMDcxT0U3c2x5MWcyN3VyczZnMmdqMzBkdzA2c3EzMS5qcGc" alt></p>
<ul>
<li>继承的格式<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93eDEuc2luYWltZy5jbi9tdzY5MC8wMDcxT0U3c2x5MWcyN3V4M2pxNmhqMzBpcTBhMnE0bi5qcGc" alt="Alt"></li>
<li>继承的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[继承方式] --&gt; B(public 继承)</span><br><span class="line">A --&gt; C(protected 继承)</span><br><span class="line">A--&gt;D(private 继承)</span><br></pre></td></tr></table></figure>
<ul>
<li>访问方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[访问限定符] --&gt; B(public 访问)</span><br><span class="line">A --&gt; C(protected访问)</span><br><span class="line">A--&gt;D(private 访问)</span><br></pre></td></tr></table></figure>
<ul>
<li>b.继承关系和访问权限</li>
</ul>
<table>
<thead>
<tr>
<th>类成员/继承方式</th>
<th>public继承</th>
<th>protected继承</th>
<th>private继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>基类的public成员</td>
<td>派生类的public成员</td>
<td>派生类的protected成员</td>
<td>派生类的private成员</td>
</tr>
<tr>
<td>基类中的protected成员</td>
<td>派生类中的protected成员</td>
<td>派生类的protected成员</td>
<td>派生类的private成员</td>
</tr>
<tr>
<td>基类的private成员</td>
<td>在派生类中不可见</td>
<td>在派生类中不可见</td>
<td>在派生类中不可见</td>
</tr>
</tbody>
</table>
<p><kbd>1.继承方式和基类中的访问方式结合起来就有9种<br>子类的访问方式，==在派生类中的访问方式<br>取两者中权限最小者==</kbd></p>
<p><kbd>2.==不管在子类中是如何继承的,基类中的私有成员在子<br>类中都是不可见的==,但是它确实存在与子类中.(基类<br>中的私有成员时基类中独有的)</kbd></p>
<p><kbd>3.==基类的私有成员在子类都是不可见==。基类的其他成员<br>在子类的访问方式 == Min(成员在基类的访问限定符，<br>继承方式)，public &gt; protected &gt; private。</kbd></p>
<p><kbd>4.==基类中的保护类型在子类中可以被访问==，但是在==子<br>类之外定义的变量不可以访问基类中被保护的内容==。</kbd></p>
<p><kbd>5.使用关键字class时==默认的继承方式是private==，<br>使用struct 时==默认的继承方式是public==，不过最好显<br>示的写出继承方式</kbd></p>
<p><kbd> 6.==基类private成员在派生类中无论以什么方式继承<br>都是不可见的==。这里的不可见是指基类的私有成员还是<br>被继承到了派生类对象中，但是语法上限制派生类对象不管<br>在类里面还是类外面都不能去访问它</kbd></p>
<p>【总结】</p>
<ul>
<li>protected:在类外无法访问，但是在子类内部可以访问</li>
<li>private：在类外和子类中都无法访问</li>
<li>public继承：不改变基类成员在子类中的访问权限</li>
<li>protected继承：基类成员在子类中的最低访问权限为protected的</li>
<li>private继承：基类成员在子类中的最低访问权限为private的</li>
</ul>
<h4 id="2-基类和派生类对象赋值转换"><a href="#2-基类和派生类对象赋值转换" class="headerlink" title="2.基类和派生类对象赋值转换"></a>2.基类和派生类对象赋值转换</h4><ul>
<li>切片:把派生类中基类的内容<strong>切下来</strong> 赋给基类的操作</li>
</ul>
<blockquote>
<p>简单理解就是:派生类在 “报答” 基类的给予之恩的时候想多向基类提供些资源，但是基类只拿走了属于自己的那部分,将不属于自己的那部分切除了。</p>
</blockquote>
<p><strong>切片操作图示</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93eDIuc2luYWltZy5jbi9tdzY5MC8wMDcxT0U3c2x5MWcyN3dpYXdodTlqMzBreDA4aWdtby5qcGc" alt></p>
<p><strong>切片理解</strong></p>
<ul>
<li><p>==1.派生类对象可以赋值给基类的对象 / 基类的指针 / 基类的引用==这里有个形象的说法叫切片或者切割。寓意把派生类的内容中将父类中的那部分切下来赋值给父类。</p>
</li>
<li><p>==2.父类对象不能赋值给子类对象==</p>
</li>
<li><p>父类指针只能看到和自己类型大小的空间,而派生类的空间有可能大于父类的空间，所以基类的指针不能赋给派生类指针</p>
</li>
<li><p>指针的类型决定指针可以看到多大的空间</p>
<blockquote>
<ul>
<li>char* :可以看到一个字节的内容</li>
<li>int * : 可以看到四个字节的内容</li>
<li>子类对象的地址可以赋给父类的指针(父类指针可以在子类对象所占空间大小中只访问自己能访问到的空间大小)，指针类型决定访问的空间大小</li>
</ul>
</blockquote>
</li>
<li><p>==父类引用可以赋值给子类指针==：引用的底层就是指针</p>
</li>
<li><p>==父类的指针不能赋给子类指针==：可能会==存在访问越界的风险==(若子类中没有定义新的成员，则基类于与子类的大小相同就不存在访问越界的情况)</p>
</li>
<li><p>需要做强制类型转换：Student <em>ptr =(Studennt </em>) &p;</p>
<blockquote>
<ul>
<li>强转存在风险:若子类中定义了新的变量，强转父类指针类型就存在访问越界的风险。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>强行转换</strong></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">10</span>;</span><br><span class="line">p=(<span class="keyword">int</span>*) c;</span><br></pre></td></tr></table></figure>
<p>  <strong>隐式类型转换</strong></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span>  b=<span class="number">1.5</span>;</span><br><span class="line">a=b; <span class="comment">//隐式的将b变量转换成了int形</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>隐式类型转换：==类型相似的变量可以进行相互赋值==，通过隐式类型转换。</li>
</ul>
</blockquote>
<h4 id="3-继承中的作用域"><a href="#3-继承中的作用域" class="headerlink" title="3.继承中的作用域"></a>3.继承中的作用域</h4><ul>
<li>1.在继承体系中基类和派生类都有独立的作用域。</li>
<li>2.子类和父类中有同名成员，子类成员将==屏蔽==父类对同名成员的直接访问，这种情况叫==隐藏==，也叫==重定义==。（在子类成员函数中，可以使用 <strong>基类::基类成员</strong> 显示访问）</li>
<li>3.需要注意的是</li>
</ul>
<blockquote>
<ul>
<li>成员变量隐藏：==子类相同名称的成员隐藏基类同名的成员==，通过基类作用域访问基类成员变量</li>
<li>如果是成员函数的隐藏，只需要==函数名相同就构成隐藏==。</li>
</ul>
</blockquote>
<ul>
<li>4.注意在实际使用的过程中在继承体系里面最好不要定义同名的成员</li>
</ul>
<p>【拓展】</p>
<ul>
<li>重载: 函数在同一个作用域中，函数名相同但参数不同</li>
<li>重定义/隐藏: 子类函数和父类函数名字相同</li>
</ul>
<h5 id="类的成员变量的隐藏实例"><a href="#类的成员变量的隐藏实例" class="headerlink" title="类的成员变量的隐藏实例"></a>类的成员变量的隐藏实例</h5><ul>
<li>No1：</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> _num = <span class="number">111</span>; <span class="comment">// 身份证号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> _num = <span class="number">999</span>; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Student s;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"s._num="</span>&lt;&lt; s._num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s.Person::num="</span> &lt;&lt; s.Person::_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//可以通过这种方法访问父类中的对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"s.Student::_num="</span>&lt;&lt; s.Student::_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当子类和父类的成员变量/成员函数同名时，</span></span><br><span class="line"><span class="comment">//子类会将父类中的同名变量/函数隐藏掉</span></span><br><span class="line"><span class="comment">//若需访问需要加上作用域限定符</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190725092225478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>由程序的运行结果可以看到在你不指明作用域的时候对象调用基类和派生类中同名的成员的时候会调用派生类的。将基类的成员屏蔽掉。如果你需要调用基类的成员的时候需要显示的指出其作用域。</li>
<li>==“隐藏”是指派生类的函数屏蔽了与其同名的基类函数==，简单理解：在学生组织中，当新的学生会主席诞生后就会 <strong>继承</strong> 上一任主席的权利。本来两个主席有一部分权力是相同的，但是新的主席行使权力时新的部员就会忽略掉上一任主席的权利。因此上一任主席要行使权力时必须声明自己是上一任学生会主席。</li>
<li>No2：</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数的隐藏</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		A::fun();<span class="comment">//指明调用</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"func(int i)-&gt;"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.fun(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//b.fun();//调不到fun()函数，因为已经被b中的fun(int)函数隐藏了</span></span><br><span class="line">    <span class="comment">//需要加上作用域限定符,如下语句</span></span><br><span class="line">    b.A::fun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载：函数在同以作用域，函数名相同，参数不同</span></span><br><span class="line"><span class="comment">//重定义：重定义/隐藏：子类函数和父类函数名相同就会构成隐藏</span></span><br><span class="line"><span class="comment">//子类会把父类同名的函数隐藏掉</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果<br><img src="https://img-blog.csdnimg.cn/20190725095857172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>由运行结果可以看出,在不指明作用域的时候对象默认调用的是派生类的成员函数。将基类的同名函数给隐藏了。</li>
</ul>
<h4 id="4-派生类的默认成员函数"><a href="#4-派生类的默认成员函数" class="headerlink" title="4.派生类的默认成员函数"></a>4.派生类的默认成员函数</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDcvMjAvNWQzMjgwM2RjMzNmNDQ3MDE2LnBuZw" alt></p>
<h6 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h6><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"peter"</span>)</span><br><span class="line">		: _name(name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">		: _name(p._name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person(const Person&amp; p)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person operator=(const Person&amp; p)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;p)</span><br><span class="line">			_name = p._name;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> _name; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//完成父类对象的初始化，子类的构造函数先调用基类的构造函数，</span></span><br><span class="line">	<span class="comment">//再执行子类的构造函数</span></span><br><span class="line">	<span class="comment">//必须先调用父类的构造函数和拷贝构造进行初始化</span></span><br><span class="line">	Student(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> num)</span><br><span class="line">		: Person(name)</span><br><span class="line">		, _num(num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果子类不显示的调用父类的拷贝构造，则调用父类的默认构造函数</span></span><br><span class="line">	<span class="comment">//如果子类显示的调用父类类的拷贝构造，就不会再去调用父类的默认构造</span></span><br><span class="line">	Student(<span class="keyword">const</span> Student&amp; s) </span><br><span class="line">		<span class="comment">//(Student *this,const Student &amp;s)还发生了指针的欺骗。</span></span><br><span class="line">		: Person(s)<span class="comment">//此处是一个切片的操作，调用父类的拷贝构造</span></span><br><span class="line">		, _num(s._num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student(const Student&amp; s)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//父类的成员变量可以直接在子类的赋值运算符重载函数长中直接赋值</span></span><br><span class="line">	<span class="comment">//如果是编译器默认生成的子类赋值运算符重载函数，会调用父类的</span></span><br><span class="line">	<span class="comment">//赋值运算符重载函数进行赋值</span></span><br><span class="line">	Student&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Student&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student&amp; operator= (const Student&amp; s)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//operator =(s);不可以这样写</span></span><br><span class="line">			Person::<span class="keyword">operator</span> =(s);<span class="comment">//此处调用的this指针为子类对象的this指针</span></span><br><span class="line">			_num = s._num;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//若if中没有显示的写出父类的赋值运算符重载的话，</span></span><br><span class="line">		<span class="comment">//子类中不会调用父类的赋值运算符重载</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数:不允许显示调用父类的析构函数</span></span><br><span class="line">	~Student()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//~Person();坑:同名隐藏，编译器底层对析构函数的名字做了修改为了使用多条调不动</span></span><br><span class="line">		<span class="comment">//编辑器将~Student()与~Person()都修改成了~destructor</span></span><br><span class="line">		<span class="comment">//Person::~Person(); //可以调动</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _num; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"jack"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">	<span class="function">Student <span class="title">s3</span><span class="params">(<span class="string">"rose"</span>, <span class="number">17</span>)</span></span>;</span><br><span class="line">	s1 = s3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造顺序：先是基类构造————》派生类构造 </span></span><br><span class="line"><span class="comment">//析构顺序：派生类析构--》基类析构</span></span><br><span class="line"><span class="comment">//原因为函数栈帧的排列顺序</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果<br><img src="https://img-blog.csdnimg.cn/20190725101647168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>该图中的调用关系可以验证继承中的6大默认成员函数的调用顺序与联系<br>【==调用关系总结==】</li>
<li>6个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成。</li>
<li>a.==派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员==。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段==显示调用==。</li>
<li>b.==派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化==</li>
<li>c.==派生类的operator=必须要调用基类的operator=完成基类的复制==。</li>
<li>d.==派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员==。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</li>
<li>e.==派生类对象初始化先调用基类构造再调派生类构造。==</li>
<li>f.==派生类对象析构清理先调用派生类析构再调基类的析构==</li>
</ul>
<p><strong>常见面试题：实现一个不能被继承的类</strong></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> NonInherit <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> NonInherit();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> NonInherit()</span><br><span class="line"> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// C++11给出了新的关键字final禁止继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span> <span class="title">final</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重点：将构造函数私有化，致使派生类无法继承基类的内容</li>
</ul>
<h4 id="5-继承与友元"><a href="#5-继承与友元" class="headerlink" title="5.继承与友元"></a>5.继承与友元</h4><ul>
<li>友元关系不能继承，也就是说==基类友元不能访问子类私有和保护成员==</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">基类 -&gt;&gt; 派生类: 嗨,你继承我的友元关系了吗？</span><br><span class="line"></span><br><span class="line">派生类--&gt;&gt;基类: 没有啊,我继承不了!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">派生类--&gt;&gt;基类: 打量着基类...</span><br><span class="line"></span><br><span class="line"> 基类-&gt;&gt;派生类: (心里想着)那我访问不了你的私有和保护的成员了</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="comment">//此处声明类型B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">disPlay</span><span class="params">(<span class="keyword">const</span> A&amp; a,<span class="keyword">const</span> B&amp; b)</span></span>;</span><br><span class="line">	A()</span><br><span class="line">		:_id(<span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~A()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A(const A)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B()</span><br><span class="line">		:_name(<span class="string">"jcak"</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~B()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	B(<span class="keyword">const</span> B&amp; b)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B(const B&amp; b)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">char</span>* _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disPlay</span><span class="params">(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a._id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; b._name &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//此处访问会报错，既友元关系不能继承,基类友元不能访问子类私有和保护成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line">	disPlay(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-继承与静态成员"><a href="#6-继承与静态成员" class="headerlink" title="6.继承与静态成员"></a>6.继承与静态成员</h4><ul>
<li>基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一个static成员实例 。</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">	Person () &#123;++ _count ;&#125;</span><br><span class="line">	<span class="keyword">protected</span> :</span><br><span class="line">	<span class="built_in">string</span> _name ; <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> _count; <span class="comment">// 统计人的个数。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person :: _count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">protected</span> :</span><br><span class="line">	<span class="keyword">int</span> _stuNum ; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> :</span> <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">protected</span> :</span><br><span class="line">	<span class="built_in">string</span> _seminarCourse ; <span class="comment">// 研究科目</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student s1 ;</span><br><span class="line">	Student s2 ;</span><br><span class="line">	Student s3 ;</span><br><span class="line">	Graduate s4 ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">" 人数 :"</span>&lt;&lt; Person ::_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Student ::_count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">" 人数 :"</span>&lt;&lt; Person ::_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出的结果如下图<br><img src="https://img-blog.csdnimg.cn/20190721233238180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfd2FuZzEyODgwMQ==,size_16,color_FFFFFF,t_70" alt="运行结果"></li>
</ul>
<p><kbd>由程序的运行结果可以看到,该程序基类中定义的<br>static 成员在其所派生出的子类中都只有一个<br>static 成员实例</kbd></p>
<h4 id="7-【复习总结】"><a href="#7-【复习总结】" class="headerlink" title="7.【复习总结】"></a>7.【复习总结】</h4><p>友元关系不能继承</p>
<p>继承体系中的静态成员为所有子类父类对象公有</p>
<p>多继承：有多个直接父类</p>
<p>​        菱形继承：数据冗余和二义性</p>
<p>​                            虚拟继承：通过虚基表解决数据冗余和二义性</p>
<p>​                            当前部分相对于公共部分的偏移量</p>
<p>公共部分在对象模型的最下面</p>
<p>直接父类部分通过各自的虚基表中的偏移量访问公共部分</p>
<p>继承 组合：代码复用</p>
<p>继承  ：白箱复用，耦合度高，突破封装。public继承 ：is a </p>
<p>组合： 黑箱继承，耦合度低 has  a</p>
<p>优先使用组合</p>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
			
		
	
		
	
		
	
		
			
			
			
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
	
	
	
		<li class="prev"><a href="/jun/2019/08/05/Cpp/进阶/智能指针/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/jun/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/jun/2019/07/22/Cpp/进阶/虚拟继承/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2019 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/jun/js/jquery.imagesloaded.min.js"></script>
<script src="/jun/js/gallery.js"></script>
<script src="/jun/js/bootstrap.min.js"></script>
<script src="/jun/js/jquery.tableofcontents.min.js"></script>
<script src="/jun/js/tocgenerator.min.js"></script>
<script src="/jun/js/main.js"></script>
<script src="/jun/js/search.js"></script> 




<link rel="stylesheet" href="/jun/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/jun/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




</body>
</html>
