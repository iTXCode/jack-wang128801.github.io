<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[系统编程]]></title>
    <url>%2F2019%2F04%2F29%2F%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[c++类与对象(下)]]></title>
    <url>%2F2019%2F03%2F24%2FCPP%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[1. 再谈构造函数1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class Date&#123;public: Date(int year)&#123; //构造函数用来初始变量 _year = year; &#125;private: int _year;&#125;;int main()&#123; Date d1(2019); //自动调用Date(int year ) 函数 Date d2 = 2018; //也可以自动调用Date(int year ) 函数 return 0;&#125; 1.2 初始化列表 存在于函数名与函数体之间 初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个”成员变量”后面跟一个放在括号中的初始值或表达式。 默认构造函数:无参或者全缺省 如下例1234567891011121314class Date&#123;public: Date(int year, int month, int day) : _year(year) , _month(month) , _day(day) &#123;&#125; private: int _year; int _month; int _day;&#125;; 1.3关键字explicit 构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用 12345678910111213141516171819202122232425262728class Date&#123;public: Date(int year) :_year(year) &#123;&#125; /*explicit Date(int year) :_year(year) &#123;&#125;*/private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1(2018); // 用一个整形变量给日期类型对象赋值 // 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值 d1 = 2019;//使用explicit时这种赋值也可以使用,阻止单三形式的隐式转换&#125;int main()&#123; TestDate(); system("pause"); return 0;&#125; 上述代码可读性不是很好，用explicit修饰构造函数，将会禁止单参构造函数的隐式转换。 ​ 2.关键字 static 2.1 概念 声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量； 用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化 12345678910111213class Date&#123; public: Date()&#123; &#125;Date (const Date&amp;d1)&#125;;int main()&#123; Date d; cout&lt;&lt;Date::count&lt;&lt;endl; cout&lt;&lt;d.count&lt;&lt;endl; //公有成员的访问方式 return 0;&#125; //#include //#include&lt;Windows.h&gt; // ////此情况为static定义的函数为公有的 //using namespace std; //class Date{ //public: // Date(int year){ // _count++; // _year = year; // // cout &lt;&lt; “Date(int)” &lt;&lt; endl; // } // Date(const Date&amp; d1){ // _count++; // _year = d1._year; // cout &lt;&lt; “Dtae(const Date&amp; d1)” &lt;&lt; endl; // } ////private: // int _year; // static int _count; // //static定义的变量在类外面进行初始化 //}; // //int Date::_count = 0; // ////static定义的变量在类外初始化 //Date fun1(Date d1){ // return d1; //} // //int main(){ // Date d1(2019); // Date d2(2015); // Date d3(2015); // fun1(d1); // cout &lt;&lt; d1._count&lt;&lt; endl; // cout &lt;&lt; &amp;d1._count &lt;&lt; endl; // cout &lt;&lt; &amp;d2._count &lt;&lt; endl; // cout &lt;&lt; &amp;d3._count &lt;&lt; endl; // system(“pause”); // return 0; //} // //#include //#include&lt;Windows.h&gt; // ////此情况为static定义的函数为私有的 //using namespace std; //class Date{ //public: // Date(int year){ // _count++; // _year = year; // // cout &lt;&lt; “Date(int)” &lt;&lt; endl; // } // Date(const Date&amp; d1){ // _count++; // _year = d1._year; // cout &lt;&lt; “Dtae(const Date&amp; d1)” &lt;&lt; endl; // } // int getCount(){ // //作用是将_count 的值传到需要调用_count的地方 // return _count; // } //改为静态函数后 static int getCount(){ // //出现错误，静态函数不能调用非静态函数 // return _count; // } //private: // int _year; // static int _count; // //static定义的变量在类外面进行初始化 //}; // //int Date::_count = 0; // ////static定义的变量在类外初始化 //Date fun1(Date d1){ //fun(Date *this) // //非静态函数可以调用非静态函数 // return d1; //} // //int main(){ // Date d1(2019); // Date d2(2015); // Date d3(2015); // fun1(d1); // cout &lt;&lt; d1.getCount() &lt;&lt; endl; // system(“pause”); // return 0; //} // // ​ 2.2 特性 \1. 静态成员为所有类对象所共享，不属于某个具体的实例 \2. 静态成员变量必须在类外定义，定义时不添加static关键字 \3. 类静态成员即可用类名::静态成员或者对象.静态成员来访问 \4. 静态成员函数没有隐藏的this指针，不能访问任何非静态成员 \5. 静态成员和类的普通成员一样，也有public、protected、private3种访问级别， 也可以具有返回值，const修饰符等参数 \4. 友元 4.1 友元分为：友元函数和友元类 友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多 用。 4.2 友元类 友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。 友元关系是单向的，不具有交换性。 比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time 类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。 友元关系不能传递 如果B是A的友元，C是B的友元，则不能说明C时A的友元 class Date{ ​ friend class Time //Time 可以访问 Date 对象的所有成员 }; class Time{ ​ friend class Date //Date 可以访问 Time 对象的所以成员 }; 友元关系不能传递 ​ \5. 内部类 class A{ ​ //B是A的内部类,相当于B是A的内部类 ​ class B{ ​ public: ​ void display(A&amp; a){ ​ cout&lt;&lt;a._a&lt;&lt;endl; ​ //外部类的普通的私有成员只能通过 对象. 的方式访问 ​ cout&lt;&lt;_s&lt;&lt;endl; //直接访问 ​ cout&lt;&lt;a._s&lt;&lt;endl; //对象. 的方式访问 ​ //外部类的静态的私有成员可以通过 对象. 的方式访问 也可以直接访问 ​ private: ​ int _b; ​ } ​ void Display(B&amp; b){ ​ //外部类对于内部类没有任何优越的访问权限，不能访问内部的私有成员(_b) ​ cout&lt;&lt; b._b&lt;&lt;endl; ​ } ​ }; ​ private: ​ int _a; ​ static int _s; }; 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class A&#123; //B是A的内部类，相当于B是A的友元类 public: //若不写作用限定符则会出现访问不了B的现象 class B&#123; public : void Print(A&amp; a)&#123; cout &lt;&lt; a._a &lt;&lt; endl; //外部类的普通成员必须通过“对象 . ”的方式去访问 cout &lt;&lt; _s &lt;&lt; endl; //外部类的静态成员可以通过“对象 .”的方式去访问 // 也可以直接去访问 cout &lt;&lt; a._s &lt;&lt; endl; &#125; private: int b; &#125;; void Print(B&amp; b)&#123; //外部类对于内部类没有任何优越的访问权限，不能访问 //内部类的私有成员 //cout &lt;&lt; b._b &lt;&lt; endl; &#125;private: int _a=0; static int _s;&#125;;int A::_s = 1;int main()&#123; A::B a; a.Print(A()); system("pause"); return 0;&#125; ​ 题目 2.求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及 条件判断语句（A?B:C). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class A&#123;public: class Sum&#123; public: Sum()&#123; _sum += _i; ++_i; &#125; &#125;; int Sum_solution(int n)&#123; _sum=0; //重新初始化，防止多次调用造成多加的情况 _i=1; Sum arr[5]; return _sum; &#125;private: static int _sum; static int _i;&#125;;int A::_sum = 0;int A::_i = 1;int main()&#123; A a; cout &lt;&lt; a.Sum_solution(0) &lt;&lt; endl; system("pause"); return 0;&#125; ​ 输入年月日,判断改天是今年的多少天 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; int days[13] = &#123; 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 &#125;; int year, month, day; cin &gt;&gt; year&gt;&gt; month&gt;&gt; day; int total = days[month - 1] + day; if (month&gt;2)&#123; if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || (year % 400 == 0))&#123; total += 1; &#125; &#125; cout &lt;&lt; total &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言内存管理]]></title>
    <url>%2F2019%2F03%2F22%2Fc%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一：数据在内存中的存储数据类型介绍1.基本的内存类型：类型的意义1.使用这个类型开辟内存空间的大小（大小决定了使用范围）。2.如何看待内存空间的视角。 char //字符数据类型占1个字节shot //短整形占2个字节int //整形占4个字节long // 长整形占4个字节long long //更长的整形占8个字节float //单精度浮点数占4个字节double // 双精度浮点数占8个字节 验证这些类型长度12345678910111213#include&lt;stdio.h&gt;int main()&#123; printf("%d\n",sizeof(char)); printf("%d\n",sizeof(short)); printf("%d\n",sizeof(int )); printf("%d\n",sizeof(long)); printf("%d\n",sizeof(long long)); printf("%d\n",sizeof(float)); printf("%d\n",sizeof(double)); return 0;&#125; 2.整形家族： 1.char————————&gt; unsigned char //无符号字符形———————— &gt; signed char //有符号字符形2.short———————— &gt; unsigned short[int ] //无符号短整形———————— &gt; signed short [int] //有符号短整形3.int———————— &gt; unsigned int //无符号整形————————&gt; signed int //有符号整形4.long————————&gt; unsigned long [int] //无符号长整形 ————————&gt; signed long [int] //有符号长整形 3.浮点数家族 ： floatdouble 4.构造类型： 数组类型结构体类型 ————————&gt; struct枚举类型—————————–&gt; enum联合类型 —————————&gt; union 5.指针类型————空类型： void不能定义变量【空类型、大小为0】（32位平台下大小为0字节 ，64位平台下为1字节–&gt;但也不能定义变量） 通常用于函数的返回类型、函数的参数、指针类型。void 可以定义变量，可以接受任意类型，与其他类型指针一样占四个字节 。（在32位平台下任何类型指针大小都为4个字节）void 不能被截引用 1234567#include &lt;stdio.h&gt;int main()&#123; printf("%d\n",sizeof(void)); printf("%d\n",sizeof(void*)); return 0;&#125; 32位平台下void 与void *的大小如图 二：整形在内存中的存储1.一个变量的创建是要在内存中开辟空间的，空间的大小是根据不同的类型决定的。 计算机中符号数有三种表示方法，既原码、补码、反码。三种表示方法均有符号位和数值位两部分 符号位都是用0表示“正”，用1表示“负”。 而数值位有三种表示方法 原码 直接将二进制按照正负数的形式翻译成二进制 反码 将原码的符号位不变，其他位依次按位取反 补码 反码+1就得到补码（负数）。 正数的原、反、补码都相同 ~~~~ 无符号数原、反、补码都相同 &amp; 正数的原、反、补码都相同。~~~~ 对于整数来说：数据存放在内存中时，其实存放的是数据的补码。只是正数的原、反、补码都相同。12345678910#include&lt;stdio.h&gt;int main()&#123; int a=-20; signed int b=-20; unsigned int c=-20; printf("a=%d,b=%d,c=%u\n",a,b,c); return 0;&#125; 那么为什么-20会被储存成ec ff ff ff 呢？(大小端有介绍) 2.数据存储和读取的差别123456789#include&lt;stdio.h&gt; int main()&#123; int a=-20; unsigned int b=10; printf("%d\n",a+b); printf("%u\n",a+b); return 0;&#125; 运算过程 存储数据时存到内存中的数据 程序运行结果 由上面的程序和内存中储存的数值来看，不管定义的变量是什么类型的其往计算机中储存数据时存入的都是数据本身的反码，只是在取出的时候改变了它们的类型。 3.在计算机中读取整形数据时的规则 4.整形的提升 下面拿char 类型转成 int形的提升来看1234567891011121314#include&lt;stdio.h&gt;int main()&#123; char a=-3; unsigned char b=-3; unsigned int c=a; unsigned int d=b; printf("%d\n",c); printf("%u\n",c); printf("%u\n",d); printf("%d\n",d); return 0;&#125;c 监视结果 将 a 赋给 c 时，y由于涉及到提升比特位的缘故。所以将char形 -3 的反码1111 1101提升成了int 类型的1111 1111 1111 1111 1111 1111 1111 1101（十进制的4294967293）因为原数据类型为有符号数所以按符号位补充；将 b 赋给 d 时，由于涉及到提升比特位的缘故。所以将unsigned char形 -3 的反码1111 1101提升成了int 类型的0000 0000 0000 0000 0000 0000 1111 1101（十进制的253）因为原数据类型为无符号整数所以拿“0”补充； 运行结果 三：大端、小端 地址有高低地址之分 数据有高低权位之别 1.大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中； 2.小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。 那么为什么会有大端、小端的储存方式呢？ 这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。 例如：一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。 在32位平台下 1234567#include&lt;stdio.h&gt;int main()&#123; int a=20; printf("a=%d\n",a); return 0;&#125;` 如下图： 20按16进制储存时应该为00 00 00 14，但是电脑却储存成14 00 00 00。原因就是32位平台采用的是小端的储存方式。 既数值权位小的数据储存在低位置端为小端储存方式四：浮点数在内存中的储存 例如：十进制的6.0，写成二进制是 110.0 ，相当于 1.10×2^2 。 那么，按照上面V的格式，可以得出s=0，M=1.10，E=2。而十进制的-6.0，写成二进制是 -110.0 ，相当于 -1.10×2^2 。 那么，按照上面V的格式，可以得出s=1，M=1.10，E=2。 2.对于32位浮点数，最高的1位是符号位s,接着的8位是指数E，剩下的23位为有效数字M。 3.对于64位浮点数，最高的1位是符号位s,接着的11位是指数E，剩下的52位为有效数字M. 有效数字M和指数E，还有一些特别规定。 前面说过， 1≤M&lt;2 ，也就是说，M可以写成 1.xxxxxx的形式，其中xxxxxx表示小数部分.在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。 至于指数E首先，E为一个无符号整数（unsigned int） 这意味着，如果E为8位，它的取值范围为0~255；如果E为11位， 它的取值范围为0~2047。但是，我们知道，科学计数法 中的E是可以出现负数的，存入内存 时E的真实值必须再加上一个中间数，对于8位的E， 这个中间数是127；对于11位的E，这个中间数是1023。比如：2^10的E是10，所以保存成32位浮点数时，必须 保存成10+127=137，即10001001。 #### 如表例题： 存-7时 存入120（-7+127=120） ，取时取出-7（120-127=-7） 存入0时 存入127(0+127=127)，取时取出0（127-127=0） 总结 存时浮点数+127,取时浮点数-127 ### 指数E还可以再分成三种情况： 1.E不全为0或不全为1 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M加上第一位的1。 比如： 0.5（1/2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则1.0*2^(-1)，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到2300000000000000000000000，则其二进制表示形式为: 2.E全为0（浮点数的0值，不能直接与0比较）这时，浮点数的指数E等于1-127（或者1-1023）即为真实值， 有效数字M不再加上第一位的1，而是还原0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 3.E全为1（S为0，E全为1，则为float表示的最大正数）这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>数据的存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 类与对象(中)]]></title>
    <url>%2F2019%2F03%2F20%2FC%20%2B%2B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[类与对象1.类的6个默认成员函数 1.1 构造函数 1.2 拷贝函数构造 1.3 析构函数 1.4 赋值操作符重载 1.5 取地址操作符重载 1.6 const修饰的取地址操作符重载 2. 构造函数 2.1 概念：不是创建，某种意义上来说是初始化 对于以下的日期类： ++123456789101112131415161718192021222324252627282930class Date &#123;&#125;;&#123; public: void SetDate(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; void Display() &#123; cout &lt;&lt;_year&lt;&lt; "-" &lt;&lt;_month &lt;&lt; "-"&lt;&lt; _day &lt;&lt;endl; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1,d2; d1.SetDate(2018,5,1); d1.Display(); Date d2; d2.SetDate(2018,7,1); d2.Display(); return 0;&#125; 对于Date类，可以通过SetDate公有的方法给对象设置内容，但是如果每次创建对象都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次 2.2. 特征 构造函数是特殊的成员函数，需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是构造函数的主要任务并不是开空间创建对象，而是初始化对象。 其特征如下： 2.2.1. 函数名与类名相同。 2.2.2. 无返回值。 2.2.3. 对象实例化时编译器自动调用对应的构造函数。 2.2.4. 构造函数可以重载。 2.2.5. 构造函数可以在类中定义，也可以在类外定义 ++1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date()&#123; //构造函数，初始化了被它定义的对象 _year = 2019; _month = 3; _day = 10; &#125; Date1()&#123;&#125;//类里面声明，在类外面定义 Date(int year, int month, int day)&#123; //函数重载,函数名相同,参数不同 _year = year; _month = month; _day = day; &#125; void Print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125;private: int _year; int _month; int _day;&#125;;Date :: Date1()&#123; //构造函数可以在类外面定义 _year = 2019; _month = 3; _day = 10;&#125;int main()&#123; Date d1;//期望d1一出来就被初始化 d1.Print(); Date d2(2019,3,20); //函数的重载 d2.Print(); system("pause"); return 0;&#125; ++123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date();//类里面声明，在类外面定义 Date(int year, int month, int day)&#123; //函数重载,函数名相同,参数不同 _year = year; _month = month; _day = day; &#125; void Print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125;private: int _year; int _month; int _day;&#125;;Date :: Date()&#123; //构造函数可以在类外面定义 _year = 2019; _month = 3; _day = 10;&#125;int main()&#123; Date d2(2019,3,20); d2.Print(); Date d3; //构造函数可以在类中定义，也可以在类外定义 d3.Print(); system("pause"); return 0;&#125; 2.2.6 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成 ++12345678910111213141516171819202122class Date&#123;public: /* // 如果用户显式定义了构造函数，编译器将不再生成 Date (int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; */private: int _year; int _month; int _day;&#125;;void Test()&#123; // 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器生成的默认构造函数 Date d;&#125; 2.2.7.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一 个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为 [ ] 是默认成员函数。 ++123456789101112131415161718192021222324// 默认构造函数class Date&#123; public: Date()&#123; _year = 1900 ; _month = 1 ; _day = 1; &#125; Date (int year = 1900, int month = 1, int day = 1)&#123; _year = year; _month = month; _day = day; &#125;private : int _year ; int _month ; int _day ;&#125;;// 以下测试函数能通过编译吗？void Test()&#123; Date d1;&#125; 2.2.8 关于编译器生成的默认成员函数，很多童鞋会有疑惑：在我们不实现构造函数的情况下， 编译器会生成 ++123456789101112131415161718192021222324252627282930313233class Time&#123;public: Time() &#123; cout &lt;&lt; "Time()" &lt;&lt; endl; _hour = 0; _minute = 0; _second = 0; &#125;private: int _hour; int _minute; int _second;&#125;;class Date&#123;private: // 基本类型(内置类型) int _year; int _month; int _day; // 自定义类型 Time _t; //默认生成的构造函数对于 1 不做处理，对于 2 默认调用无参构造初始化 //1.基本类型：int 、char .... //2.自定义类型：class/struct定义的类型。。。&#125;;int main()&#123; Date d; return 0; &#125; 默认的构造函数。但是看起来默认构造函数又没什么用？d对象调用了编译器生成的默认构造函数，但是d对象year/month/_day，依旧是随机值。也就说在这里编译器生成的默认构造函数并没有什么卵用？ 解答：C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语法已经定义好的类型：如int/char…，自定义类型就是我们使用class/struct/union自己定义的类型，看看下面的程序，就会发现编译器生成默认的构造函数会对自定类型成员_t调用的它的默认成员函数 3.析构函数3.1 概念： 析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器 完成的。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作 3.2. 特性 析构函数是特殊的成员函数。 其特征如下3.2.1. 析构函数名是在类名前加上字符 ~ 。3.2.2. 无参数无返回值。3.2.3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。3.2.4. 对象生命周期结束时，C++编译系统系统自动调用析构函数. 析构函数建造时按定义的相反顺序建造函数 对于内置类型来说没有定义析构函数的话，编译器默认去掉用析构函数 ++12345678910111213141516171819202122232425262728typedef int DataType;class SeqList&#123; public : SeqList (int capacity = 10) &#123; _pData = (DataType*)malloc(capacity * sizeof(DataType)); assert(_pData); _size = 0; _capacity = capacity; &#125; ~SeqList() &#123; if (_pData) &#123; free(_pData ); // 释放堆上的空间 _pData = NULL; // 将指针置为空 _capacity = 0; _size = 0; &#125; &#125; private : int* _pData ; size_t _size; size_t _capacity;&#125;; 4.1 概念 构造函数：只是单个形参，该形参是对本类类型对象的引用(一般常用const 修饰)，在已存在的 类类型对象创建新对象时由编译器自动调用 ++123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date(int year = 1900, int month = 1, int day = 1)&#123; _year = year; _month = month; _day = day; &#125; void print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125; ~Date()&#123; cout &lt;&lt; "~Date" &lt;&lt; endl; &#125;private: int _year; int _month; int _day;&#125;;// 以下测试函数能通过编译吗？int main()&#123; Date d1; d1.print(); Date d2(d1); //拷贝构造 d2.print(); system("pause"); return 0;&#125; 4.2 特征4.2.1 拷贝构造函数是构造函数的一个重载形式4.2.2 拷贝构造函数的参数只有一个且必须使用引用传参，使用传参方式会引发无穷递归调用 4.2.3 若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝4.2.4 那么编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。 代码示例++1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date(int year = 2019, int month = 3, int day = 10)&#123; _year = year; _month = month; _day = day; &#125; void Print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125; Date ( Date&amp; d)&#123; //拷贝构造出现问题 _year = d._year; _month = d._month; _day = d._day; &#125; private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1; d1.Print(); Date d2(2018, 6, 30);// 特征2 d2.Print(); Date d3(2019); d3.Print(); Date d4(d2); //拷贝构造--&gt;浅拷贝(按字节进行拷贝) d4.Print(); system("pause"); return 0;&#125; ++123456789101112131415161718192021222324// 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。class String&#123;public: String(const char* str = "jack") &#123; _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); &#125; ~String() &#123; cout &lt;&lt; "~String()" &lt;&lt; endl; free(_str); &#125;private: char* _str;&#125;;int main()&#123; String s1("hello"); String s2(s1);&#125;//程序奔溃的原因是在进行浅拷贝时，将s1和s2的指针指向了同一片空间，在释放时空间//已经倍s2释放了，所以s1再去释放这块空间就会出错 5.赋值运算符重载5.1 运算符重载 C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。函数名字为：关键字operator后面接需要重载的运算符符号。函数原型：返回值类型 operator操作符(参数列表) ++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 全局的operator==class Date&#123; public: Date(int year = 1900, int month = 1, int day = 1) &#123; _year = year; _month = month; _day = day; &#125; //private: int _year; int _month; int _day;&#125;;// 这里会发现运算符重载成全局的就需要成员变量是共有的，那么问题来了，封装性如何保证？// 这里其实可以用我们后面学习的友元解决，或者干脆重载成成员函数。bool operator==(const Date&amp; d1, const Date&amp; d2)&#123; return d1._year == d2._year; &amp;&amp; d1._month == d2._month &amp;&amp; d1._day == d2._day;&#125;void Test ()&#123; Date d1(2018, 9, 26); Date d2(2018, 9, 27); cout&lt;&lt;(d1 == d2)&lt;&lt;endl;//可读性&#125;//////////////////class Date&#123; public: Date(int year = 1900, int month = 1, int day = 1) &#123; _year = year; _month = month; _day = day; &#125; // bool operator==(Date* this, const Date&amp; d2) //增加可读性 // 这里需要注意的是，左操作数是this指向的调用函数的对象 bool operator==(const Date&amp; d2) &#123; return _year == d2._year &amp;&amp; _month == d2._month &amp;&amp; _day == d2._day; &#125;private: int _year; int _month; int _day;&#125;;void Test ()&#123; Date d1(2018, 9, 26); Date d2(2018, 9, 27); cout&lt;&lt;(d1 == d2)&lt;&lt;endl; cout&lt;&lt;operator==(d1,d2)&lt;&lt;endl;&#125; 注意： 5.1.1 不能通过连接其他符号来创建新的操作符：比如operator@5.1.2 重载操作符必须有一个类类型或者枚举类型的操作数5.1.3 用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义5.1.4 作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参5.1.5 &lt; .* &gt;&lt; :: &gt; &lt; sizeof &gt; &lt; ?: &gt;&lt; . &gt;注意以上5个运算符不能重载。这个经常在笔试选择题中出现5.2. 赋值运算符重载赋值运算符主要有四点： 5.2.1. 参数类型5.2.2. 返回值5.2.3. 检测是否自己给自己赋值5.2.4. 返回*this5.2.5. 一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date(int year = 1900, int month = 1, int day = 1) &#123; _year = year; _month = month; _day = day; &#125; //d2=d1 //d2.operator(d1) //d2.operator(&amp;d2,d1) void operator=(const Date&amp; d)&#123; //默认含有第一个参数的地址， //已经被this指针所指代 if (this != &amp;d)&#123; //防止自己给自己传值 this-&gt;_year = d._year; this-&gt;_month = d._month; this-&gt;_day = d._day; &#125; &#125; /*Date operator=(const Date&amp; d)&#123; //有返回值 if (this != &amp;d)&#123; this-&gt;_year = d._year; this-&gt;_month = d._month; this-&gt;_day = d._day; &#125; return *this; &#125;*/ void print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1(2018,10, 20); Date d2(2019,10, 10); d1.print();// 这里d1调用的编译器生成operator=完成拷贝，d2和d1的值也是一样的。 Date d3(d1); //拷贝构造 d1 = d2; //赋值运算符的用运 d3.print(); d1.print(); //用运这个表达式需要调用函数Date operator=(const Date&amp; d) //d3 = d2 = d1;//被转换成 d3=(d2.oprator=(&amp;d2,d1)) //d3.print(); //Date d4 = d1; //拷贝构造，将已知的值赋给创建的变量。 //运算符重载 //函数重载 两者没有任何关系 system("pause"); return 0;&#125; 运行结果不加d3 = d2 = d1;加上d3 = d2 = d1; ++123Date operator-(int day);//日期减去日期int operator-(const Date&amp; day); //返回天数//两者而言即是函数重载，又是运算符重载 简单整理：封装：管理构造、析构：初始化、清理拷贝构造、operator= ： 复制 那么编译器生成的默认赋值重载函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。那么下面的类呢？验证一下试试？ ++123456789101112131415161718192021222324// 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。class String&#123;public: String(const char* str = "jack") &#123; _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); &#125; ~String() &#123; cout &lt;&lt; "~String()" &lt;&lt; endl; free(_str); &#125;private: char* _str;&#125;;int main()&#123; String s1("hello"); String s2("world"); s1 = s2;&#125;]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>类与对象(中)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--双向链表]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[DList.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#pragma once#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;assert.h&gt;typedef int DLDataType;//定义链表的结点结构typedef struct DListNode&#123; DLDataType value; //头节点中的value没有意义 struct DListNode *prev; //指向该节点的前一个结点 struct DListNode *next; //指向该节点的后一个结点&#125;DListNode;//定义双向链表typedef struct DList&#123; DListNode *head; //指向双向链表的头节点&#125;DList;//初始化void DListInit(DList *dlist);//销毁//1.清空链表void DListClear(DList *dlist);//2.彻底的清空链表，彻底销毁void DListDestory(DList *dlist);//申请空间的函数DListNode * DListBuyNode(DLDataType value);//增//头插void DListPushFront(DList *dlist,DLDataType value);//尾插void DListPushBack(DList *dlist, DLDataType value);//删//头删void DListPopFront(DList *dlist,DLDataType value);//尾删void DListPopBack(DList *dlist, DLDataType value);//查找DListNode * DListFind(DList *dlist,DLDataType value);//插// 在pos的前面进行插入void DListInsert(DListNode *pos, DLDataType value);// 删除pos位置的节点void DListErase(DListNode *pos);void ListRemove(DList * dlsit, DLDataType value);//打印void DListPrint(const DList *dlist); DList.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include"DList.h"//初始化void DListInit(DList *dlist)&#123; dlist-&gt;head = DListBuyNode(0);//0没有实际意义，这里指头结点 dlist-&gt;head-&gt;next = dlist-&gt;head; dlist-&gt;head-&gt;prev = dlist-&gt;head;&#125;//销毁//1.清空链表//保留链表的头结点void DListClear(DList *dlist)&#123; DListNode *cur, *next; cur = dlist-&gt;head -&gt;next; while (cur != dlist-&gt;head)&#123; next = cur-&gt;next; free(cur); cur = next; &#125; dlist-&gt;head-&gt;next = dlist-&gt;head-&gt;prev = dlist-&gt;head;&#125;//彻底的清空链表，彻底销毁void DListDestory(DList *dlist)&#123; DListClear(dlist); free(dlist-&gt;head); dlist-&gt;head = NULL;&#125;//申请新结点DListNode * DListBuyNode(DLDataType value)&#123; DListNode *new_node = (DListNode *)malloc(sizeof(DListNode)); new_node-&gt;value = value; new_node-&gt;next = new_node-&gt;prev = NULL; return new_node;&#125;//增//头插void DListPushFront(DList *dlist, DLDataType value)&#123; DListNode *node = DListBuyNode(value); node-&gt;prev = dlist-&gt;head; node-&gt;next = dlist-&gt;head-&gt;next; dlist-&gt;head-&gt;next-&gt;prev = node; dlist-&gt;head-&gt;next = node; //特殊情况，空链表是没有问题的 //DListInsert(dlist-&gt;head-&gt;next,value)&#125;//尾插void DListPushBack(DList *dlist,DLDataType value)&#123; DListNode *node = DListBuyNode(value); node-&gt;prev = dlist-&gt;head-&gt;prev; node-&gt;next = dlist-&gt;head; node-&gt;prev-&gt;next = node; dlist-&gt;head-&gt;prev=node; //DListInsert(dlist-&gt;head,value)&#125;//头删void DListPopFront(DList *dlist, DLDataType value)&#123; assert(dlist-&gt;head-&gt;next!=dlist-&gt;head); DListNode *cur = dlist-&gt;head-&gt;next; //指向头节点的下一结点 dlist-&gt;head-&gt;next= cur-&gt;next; // cur-&gt;next-&gt;prev = dlist-&gt;head; free(cur); //空链表也适用 //DListErase(dlist-&gt;head-&gt;next)&#125;//尾删void DListPopBack(DList *dlist, DLDataType value)&#123; assert(dlist-&gt;head-&gt;next!=dlist-&gt;head); DListNode *old_node = dlist-&gt;head-&gt;prev; old_node-&gt;prev-&gt;next = dlist-&gt;head; //dlist-&gt;head-&gt;prev-&gt;prev-&gt;next old_node-&gt;next-&gt;prev = old_node-&gt;prev;//dlist-&gt;head-&gt;prev; free(old_node); //DListErase(dlist-&gt;head-&gt;prev)&#125;//查找DListNode * DListFind(DList *dlist, DLDataType value)&#123; DListNode *cur; for (cur = dlist-&gt;head-&gt;next; cur != dlist-&gt;head; cur = cur-&gt;next)&#123; if (cur-&gt;value = value)&#123; return cur; &#125; return NULL; &#125;&#125;//插// 在pos的前面进行插入void DListInsert(DListNode *pos, DLDataType value)&#123; DListNode *node = DListBuyNode(value); node-&gt;next = pos; node-&gt;prev = pos-&gt;prev; node-&gt;prev-&gt;next = node; pos-&gt;prev = node;&#125;// 删除pos位置的节点void DListErase(DListNode *pos)&#123; pos-&gt;prev-&gt;next = pos-&gt;next; pos-&gt;next-&gt;prev = pos-&gt;prev; free(pos);&#125;//打印void DListPrint(const DList *dlist)&#123; for (DListNode *cur = dlist-&gt;head-&gt;next; cur != dlist-&gt;head; cur = cur-&gt;next) printf("%d --&gt;",cur-&gt;value); printf("\n");&#125; main.c123456789101112131415161718192021222324#include"DList.h"void TestDList1()&#123; DList dlist; DListInit(&amp;dlist); DListPushFront(&amp;dlist,1); DListPushFront(&amp;dlist, 15); DListPrint(&amp;dlist); DListPushFront(&amp;dlist, 16); DListPushBack(&amp;dlist, 18); DListPushFront(&amp;dlist, 2); DListPrint(&amp;dlist); DListPushBack(&amp;dlist,20); DListPushFront(&amp;dlist, 12); DListPushBack(&amp;dlist,17); DListPrint(&amp;dlist); DListDestory(&amp;dlist);&#125;int main()&#123; TestDList1(); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++入门]]></title>
    <url>%2F2019%2F03%2F18%2FC%20%2B%2B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[c++入门笔记4.基础的C++程序编写++1234567891011121314151617181920212223242526272829303132333435363738 #include&lt;iostream&gt; #include&lt;windows.h&gt; using namespace std;//不写这句会出现cin与cout 未定义的错误 namespace N1&#123; int a = 10; int b = 20; int Add(int a, int b)&#123; //命名空间中可以有函数的存在 return a + b; &#125; namespace N2&#123; //命名空间中可以出现嵌套式的命名空间 //引用时只需要注意调用方式即可 int Swap(int x, int y)&#123; return x*y; &#125; &#125; &#125; int main()&#123; int a,b; cin &gt;&gt; a; //c++语言的输入格式 cin &gt;&gt; b; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; //C++语言的输出格式，其中""中间的部分为输出的格式，而后面紧跟的 //则为输出的内容，“&lt;&lt;endl”表示的是“\n”-&gt;换行符 cout &lt;&lt;"b=" &lt;&lt;b &lt;&lt; endl; cout &lt;&lt; "a="&lt;&lt;N1::a &lt;&lt; endl; cout &lt;&lt; "b=" &lt;&lt; N1::b &lt;&lt; endl; cout &lt;&lt; "a+b="&lt;&lt;N1::Add(a,b) &lt;&lt; endl; cout &lt;&lt; "a*b=" &lt;&lt; N1::N2::Swap(a, b) &lt;&lt; endl; system("pause"); return 0; &#125; 5.函数重载5.1 概念：c++允许在同一作用域中声明几个功能相似的几个同名函数，这些函数的形参列表（参数的个数或类型或顺序）必须不同， 常用来处理实现功能类似数据类型不同的问题 ++123456789101112131415161718192021222324252627282930//函数重载实例#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;int Add(int a,int b)&#123; return a + b;&#125;double Add(double a, double b)&#123; //相较第一个而言形参的类型不同 return a + b;&#125;double Add(double a, int b, float c)&#123; //相较第一个而言形参的类型不同既个数不同 return a + b + c;&#125;int main()&#123; int a = 10; int b = 20; double c = 2.0; double d = 3.0; float f = 3; cout&lt;&lt;Add(a,b)&lt;&lt;endl; cout &lt;&lt; Add(c, d) &lt;&lt; endl; cout &lt;&lt; Add(d, a, f) &lt;&lt; endl; system("pause"); return 0;&#125; 5.2名字修饰 [ ] 在c/c++中，一个程序要跑起来需要经历：预处理、编辑、汇编、链接等步骤 5.2.1 预处理：去注释，宏替换，头文件展开5.2.2 汇编：语法检查，转换成汇编代码5.2.3 编译：汇编代码————&gt;机器码5.2.4 链接：生成可执行文件5.2.5 在Linux下的修饰 void F1(int a);//——Z2F1I其中—Z为前缀，2代表函数名有两个字符，F1为函数名，而i(int)为参数的类型的首字母void F1(char b);//_Z2F1Cvoid F1(int a,char b);//——Z2F1IC 5.2.6 C语言的名字修饰规则非常简单，只是在函数名字前面加一个下划线(_函数名)， [ ] 而在C++文件(xx.cpp)中在函数名字前面加一个 extern “c”既是告诉编辑器该函数按照c语言规则来编译 ++1234567extern "c" int Add(int a,int b)//一个函数的形式// 若需要全部都用C语言的风格来编辑，形式如下extern "c"&#123; //很多行C语言代码;&#125; 函数重载总结 1 C语言不支持，C++支持 2 特点：函数名相同，参数不同(1.类型不同。2.顺序不同 3.参数个数不同)-3 C++语言支持重载：函数名修饰规则 name mangling 4 C语言中底层函数名：”_” + 函数名 -5 C++底层函数名： 前缀+函数名+参数类型首字母 6：引用6.1 引用概念：引用不是重新定义了一个变量，而是给已经存在的变量取个别名，编译器不会为引用变量开辟内存空间。它和它引用的变量公用同一块内存空间 示例代码如下： 引用格式：类型名&amp; 引用变量名(对象名) = 引用对象 ++12345678910111213141516171819#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;void Testfun()&#123; int a = 10; int &amp;ra = a; cout &lt;&lt; ra &lt;&lt; endl; //结果出现一个10 cout &lt;&lt; ra &lt;&lt;endl&lt;&lt; a&lt;&lt;endl; //结果出现两个10&#125;int main()&#123; Testfun(); system("pause"); return 0;&#125; [ ] 监视结果：&amp;ra=&amp;a,ra=a=10; 注意点： 引用类型和引用实体必须是相同类型的 上例中如果出现 double &amp;ra=a; 则会报错 6.2 引用特性 1.引用在定义时必须初始化 [ ] 错误示例： int &ra; 2.一个变量可以有多个引用 ++12345//正确用法示例： int a=10; int &amp;ra=a; int &amp;rra=a; int &amp;rrra=a; 3.引用一旦引用一个实体则不能在引用其他实体 6.3 常引用++12345678910111213void TestContRef()&#123; const int a=10; //int &amp; ra=1; //该语句编译时出错，a为常量 const int &amp;ra=a; //int&amp; b=10; //该语句编译时出错，b为常量 const int&amp; b=10; double d=12.34; const int&amp; rd==d; //隐式类型转换---&gt;临时变量具有常性 int c=d; //int&amp; rd=d; //该语句编译时出错，类型不同 const int&amp; rd=d; &#125; 6.4 使用场景 [ ] 1. 做参数 传指针和传引用效果一样； ++123456789101112131415161718192021222324252627 //示例代码：#include&lt;iostream&gt;#include&lt;windows.h&gt; using namespace std; void Swap(int *pa,int *pb)&#123; int tmp = *pa; *pa = *pb; *pb = tmp;&#125;void Swap(int &amp;ra,int &amp;rb)&#123; int tmp = ra; ra = rb; rb = tmp;&#125;int main()&#123; int a = 10; int b = 20; Swap(a, b); Swap(&amp;a, &amp;b); system("pause"); return 0;&#125; 2.做返回值 ++12345678910111213141516 #include&lt;iostream&gt; #include&lt;windows.h&gt;using namespace std; int&amp; Testfuc(int &amp;a)&#123; a+=10; return 0; &#125; int main()&#123; int a = 10; int &amp;ra=Testfuc(a); system("pause"); return 0; &#125; //注意：如果函数返时，离开函数作用域后，其栈上空间已经还给了系统，因此不能用栈上的 //空间做为引用类型的返回，如果函数类型返回，返回值的生命周期必须不受函数的限制(既函数周期比较长) ++1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;time.h&gt;using namespace std;int main()&#123; size_t beginl = clock(); for (int i = 0; i &lt; 10000; i++)&#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; &#125; size_t endl = clock(); cout &lt;&lt; (endl- beginl) /CLOCKS_PER_SEC&lt;&lt; endl; system("pause"); return 0;&#125;//以毫秒的形式输出循环的//引用传值的效率高于值拷贝的形式 6.6 指针与引用的区别 引用语法层面：和指针指向同一块内存空间，引用没有开辟新的空间 引用底层实现：引用开辟新的空间，和指针的的实现相同 12345678910111213141516171819int a=10; inta=10;mov dword ptr [a], OAh mov dword ptr [a], 0Ah int&amp; ra = a; int* pa = &amp;a;lea eax, [a] lea еах,[a] mov dword ptr [ra], eax mov dword ptr [pa], eax ra = 20; *pa = 20；mov eax, dword ptr [ra] mov eax, dword ptr[ра]mov dword ptr [eax], 14h mov dword ptr [eax], 14h 引用和指针的不同点:6.6.1. 引用在定义时必须初始化，指针没有要求6.6.2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体6.6.3. 没有NULL引用，但有NULL指针6.6.4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)cout &lt;&lt; sizeof(*a)&lt;&lt;endl; //结果为46.6.5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小6.6.6. 有多级指针，但是没有多级引用6.6.7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理6.6.8. 引用比指针使用起来相对更安全7.内联函数7.1 概念：以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。++1234567inline Add(int a,int b)&#123; return a+b;&#125;int main()&#123; int ret=Add(1,3) -------&gt; return 0;&#125; 面试题： 【面试题】宏的优缺点？ 优点： 1.增强代码的复用性。 2.提高性能。缺点： 1.不方便调试宏。（因为预编译阶段进行了替换) 2.导致代码可读性差，可维护性差，容易误用。 3.没有类型安全的检查 。 C++有哪些技术替代宏 1. 常量定义 换用const 2. 函数定义 换用内联函数8.关键字auto 特点：使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化 表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明 时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。 ++1234567891011121314151617#include&lt;iostream&gt;#include&lt;windows.h&gt; using namespace std;int main()&#123; int a = 10; auto b = a; double c = 20.3; auto d = c; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; cout &lt;&lt; typeid(c).name() &lt;&lt; endl; cout &lt;&lt; typeid(d).name() &lt;&lt; endl; system("pause"); return 0;&#125;//显示出了类型的名称 8.2 使用规则8.2.1. auto与指针和引用结合起来使用用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;++1234567891011121314int main()&#123; int x = 10; auto a = &amp;x; auto* b = &amp;x; auto&amp; c = x; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; cout &lt;&lt; typeid(c).name() &lt;&lt; endl; *a = 20; *b = 30; c = 40; return 0;&#125; 8.2.2 在同一行定义多个变量 当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错， 为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。 ++12345void TestAuto()&#123; auto a = 1, b = 2; auto c = 3, d = 4.0; // 该行代码会编译失败，因为c和d的初始化表达式类型不同&#125; 若同一个程序中同时定义了多个 auto ，其会根据第一个变量表达式去推导类型。8.3 auto不能推导的场景。8.3.1 auto不能做函数的参数 ++123// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导void TestAuto(auto a)&#123;&#125; 8.3.2 auto不能直接用来声明数组++12345void TestAuto()&#123; int a[] = &#123;1,2,3&#125;; auto b[] = &#123;4，5，6&#125;;&#125; 8.3.3为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法8.3.4 auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用。 8.3.5 auto不能定义类的非静态成员变量(暂不做讲解，后面讲)8.3.6实例化模板时不能使用auto作为模板参数(暂不做讲解，后面讲)9. 基于范围的for循环(C++11)9.1 for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。++1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3,4,5,6,7,8,9&#125;; int size = sizeof(arr) / sizeof(arr[0]); int i = 0; for (; i &lt; size; i++)&#123; cout &lt;&lt; "arr1[i]=" &lt;&lt; arr[i] &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (int e : arr)&#123; cout &lt;&lt; "arr2[i]=" &lt;&lt; e &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (auto&amp; e : arr)&#123; cout &lt;&lt; "arr3[i]=" &lt;&lt;e &lt;&lt; endl; &#125; system("pause"); return 0;&#125; 注意：与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环9.2 范围for的使用条件1. for循环迭代的范围必须是确定的 对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提 供begin和end的方法，begin和end就是for循环迭代的范围。 注意：以下代码就有问题，因为for的范围不确定 ++12345void TestFor(int array[]) &#123; for(auto&amp; e : array) cout&lt;&lt; e &lt;&lt;endl; &#125; 10.指针空值nullptr(C++11)++12345678910111213141516#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std; int main()&#123; int *p = NULL; int *pp = nullptr; cout &lt;&lt; typeid(pp).name() &lt;&lt; endl; cout &lt;&lt; typeid(nullptr).name() &lt;&lt; endl; system("pause"); return 0;&#125;结果如下： //int *//std::nullptr_t 程序本意是想通过f(NULL)调用指针版本的f(int)函数，但是由于NULL被定义成 0，因此与程序的初衷相悖。在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void)常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void*)0。 10.2 nullptr 与 nullptr_t 为了考虑兼容性，C++11并没有消除常量0的二义性，C++11给出了全新的nullptr表示空值指针。C++11为什么不在NULL的基础上进行扩展，这是因为NULL以前就是一个宏，而且不同的编译器厂商对于NULL的实现可能不太相同，而且直接扩展NULL，可能会影响以前旧的程序。因此：为了避免混淆，C++11提供了nullptr， 即：nullptr代表一个指针空值常量。nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类型，nullptr_t被定义在头文件中 1typedef decltype(nullptr) nullptr_t; 注意： 1 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。 2 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。 3 为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++ 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构->链表]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[SList.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#pragma once#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;assert.h&gt;typedef int SLDataType;typedef struct SLNode&#123;//链表中的一个节点 SLDataType value; struct SLNode *next; //指向链表中的下一个结点地址&#125;SLNode;typedef struct SList&#123; //一个链表 SLNode *first; //指向链表中的第一个结点地址&#125;SList;//初始化void SListInit(SList*list);//销毁过程void SListDestory(SList *list);//增//头插void SListPushFront(SList *list,SLDataType value);//尾插void SListpushBack(SList *list, SLDataType value);//删//头删void SListPopFront(SList *list);//尾删void SListPopBack(SList *list);//打印void SListPrint(SList *list);//查SLNode * SListFind(const SList *list, SLDataType value);//改void SlistNodeUpdate(SLNode *node, SLDataType value);//指定位置插入元素//1--&gt;2--&gt;3--&gt;NULLvoid SListInsertAfter(SLNode *pos, SLDataType value);//删除给定pos位置后面的结点void SListEraseAfter(SLNode *pos);//指定位置pos 前面插入新结点void SListInsertBefore(SList *list, SLNode *pos, SLDataType value); SList.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147 #include"SList.h"//初始化void SListInit(SList*list)&#123; assert(list!= NULL); list-&gt;first = NULL;&#125;//销毁过程void SListDestory(SList *list)&#123; assert(list!=NULL); SLNode *cur = list-&gt;first; SLNode *next=NULL; while (cur != NULL)&#123; next = cur-&gt;next; free(cur); cur = next; &#125; list-&gt;first = NULL;&#125;//头插void SListPushFront(SList *list, SLDataType value)&#123; assert(list!=NULL); SLNode *node = (SLNode*)malloc(sizeof(SLNode)); assert(node); node-&gt;value = value; node-&gt;next = list-&gt;first; list-&gt;first = node;&#125;//尾插void SListpushBack(SList *list, SLDataType value)&#123; assert(list != NULL); if (list-&gt;first == NULL)&#123; //链表中没有结点,调用头插法 SListPushFront(list,value); return; &#125; //链表中有节点的情况 //找链表中的最后一个节点 SLNode *ptr; for (ptr = list-&gt;first; ptr-&gt;next != NULL; ptr = ptr-&gt;next)&#123; &#125; //ptr就是最后一个节点 SLNode *new_node = (SLNode*)malloc(sizeof(SLNode)); ptr-&gt;next = new_node; new_node-&gt;value = value; new_node-&gt;next = NULL;&#125;//头删void SListPopFront(SList *list)&#123; assert(list != NULL); //保证链表是有的 assert(list-&gt;first!=NULL); //保证链表不为空 SLNode *old_first = list-&gt;first; //拷贝原来的空间，防止丢失。 list-&gt;first = list-&gt;first-&gt;next; free(old_first);//释放老空间&#125;//尾删void SListPopBack(SList *list)&#123; assert(list != NULL); //保证链表是有的 assert(list-&gt;first != NULL); //保证链表不为空 //自己的想法 /*SLNode *ret; for (ret = list-&gt;first; ret-&gt;next-&gt;next != NULL; ret= ret-&gt;next)&#123; &#125; SLNode *cur = ret-&gt;next; ret-&gt;next = NULL; free(cur);*/ //如果只有一个节结点 if (list-&gt;first-&gt;next == NULL)&#123; SListPopFront(list); return; &#125; SLNode *ret = list-&gt;first; while (ret-&gt;next-&gt;next != NULL)&#123; ret = ret-&gt;next; &#125; free(ret-&gt;next); ret-&gt;next = NULL;&#125;//打印void SListPrint(SList *list)&#123; for (SLNode *cur = list-&gt;first; cur != NULL; cur = cur-&gt;next)&#123; printf("%d--&gt; ",cur-&gt;value); &#125; printf("NULL\n");&#125;//查找value//找到链表中遇到的第一个value ,如果没找到，返回NULLSLNode * SListFind(const SList *list, SLDataType value)&#123; assert(list != NULL); //自己的版本 /*SLNode *ret = list-&gt;first; while ( ret != NULL)&#123; if (ret-&gt;value == value)&#123; return ret; &#125; else&#123; ret = ret-&gt;next; &#125; &#125; return NULL;*/ for (SLNode *ret = list-&gt;first; ret != NULL; ret = ret-&gt;next)&#123; if (ret-&gt;value == value)&#123; return ret; &#125; &#125; return NULL;&#125;//改void SlistNodeUpdate(SLNode *node, SLDataType value)&#123; node-&gt;value = value;&#125;//指定位置插入元素//1--&gt;2--&gt;3--&gt;NULL//pos必须是链表中的有效结点void SListInsertAfter(SLNode *pos, SLDataType value)&#123; //给 value 申请结点 SLNode *node = (SLNode *)malloc(sizeof(SLNode)); node-&gt;value = value; node-&gt;next = pos-&gt;next; pos-&gt;next = node;&#125;//删除给定pos位置后面的结点void SListEraseAfter(SLNode *pos)&#123; SLNode *new_node = pos-&gt;next; pos-&gt;next = new_node-&gt;next; free(new_node);&#125;//指定位置pos 前面插入新结点void SListInsertBefore(SList *list, SLNode *pos, SLDataType value)&#123; assert(list != NULL); SLNode *cur = list-&gt;first; while (cur-&gt;next != pos)&#123;//判断cur 指向的是不是pos的前一个结点 cur = cur-&gt;next; &#125; SLNode *new_node = (SLNode*)malloc(sizeof(SLNode)); new_node-&gt;value = value; cur-&gt;next = new_node; new_node-&gt;next = pos;&#125; main.c12345678910111213141516171819202122232425262728293031323334353637383940414243#include"SList.h"void TestSList()&#123; SList list; SListInit(&amp;list); //检验头插尾插 /*SListPushFront(&amp;list,1); SListPushFront(&amp;list, 2); SListPushFront(&amp;list, 3); SListpushBack(&amp;list,11); SListpushBack(&amp;list,12); SListpushBack(&amp;list,13);*/ //检测没有节点时的尾插 SListpushBack(&amp;list,11); SListpushBack(&amp;list,12); SListpushBack(&amp;list,13); SListpushBack(&amp;list,14); SListpushBack(&amp;list,15); SListPrint(&amp;list); //尾删 SListPopFront(&amp;list); SListPopBack(&amp;list); SLNode *node = SListFind(&amp;list,14); assert(node!=NULL); SListInsertAfter(node, 103); SListPrint(&amp;list); SListEraseAfter(node); SListPrint(&amp;list); SListInsertBefore(&amp;list, node, 101); SListPrint(&amp;list); &#125;int main()&#123; TestSList(); printf("程序运行成功!\n"); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存管理]]></title>
    <url>%2F2019%2F03%2F17%2FC%2B%2B%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1 . 例题++123456789101112131415 int globalVar = 1; static int staticGlobalVar = 1; void Test() &#123; static int staticVar = 1; int localVar = 1; int num1[10] = &#123;1, 2, 3, 4&#125;; char char2[] = "abcd"; char* pChar3 = "abcd"; int* ptr1 = (int)malloc(sizeof (int)4); int* ptr2 = (int*)calloc(4, sizeof(int)); int* ptr3 = (int)realloc(ptr2, sizeof(int)4); free (ptr1); free (ptr3);&#125; 1.选择题：选项: A.栈 B.堆 C.数据段 D.代码段 globalVar在哪里？_C_ staticGlobalVar在哪里？C__staticVar在哪里？_C_ localVar在哪里？A__num1 在哪里？_A___char2在哪里？A_ char2在哪里？ApChar3在哪里？_A _ pChar3在哪里？Dptr1在哪里？_A *ptr1在哪里？B 全局变量放在数据段,静态的也放在数据段局部变量放在栈上(属于栈帧)，数组若为局部变量也放在栈上2. 填空题： sizeof(num1) =40 ; sizeof(char2) = 5; strlen(char2) =4 ; sizeof(pChar3) = _4 或者 8; strlen(pChar3) = _4; sizeof(ptr1) = _4 或者 8__;//跟系统有关系，32位的为4，64位的为8。 32/64 位与虚拟机的地址空间有关，虚拟机的地址空间又与进程有关 sizeof(ptr2)= 4/8 sizeof:类型大小 strlen: 有效字符长度 sizeof 用来计算类型或者是对象的大小strlen 遇到’\0’就结束，计算自字符的大小。3.总结 定义的局部变量(不管类型)都在栈空间上。 动态加载的都在堆上。 解引用的空间在堆上，本身的空间在栈上。 3.【说明】 1.栈又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的。 2.内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。（Linux课程如果没学到这块，现在只需要了解一下） 3.堆用于程序运行时动态内存分配，堆是可以上增长的。 4.数据段–存储全局数据和静态数据。 5.代码段–可执行的代码/只读常量。 2. c 语言中动态内存管理方式2.1 malloc/calloc/realloc和free123//验证32位平台中malloc 可以申请多大空间void * malloc(1024*1024*1024);//申请了1G的空间。管理在堆上的空间malloc 用于动态申请空间calloc 用于开辟空间并进行初始化 管理在堆上的空间malloc 用于动态申请空间 calloc 用于开辟空间并进行初始化 realloc 用于调整大小，用于扩容 realloc 用于调整大小，用于扩容 ++123456789101112131415161718void Test () &#123; int* p1 = (int*) malloc(sizeof(int)); free(p1); // 1.malloc/calloc/realloc的区别是什么？ int* p2 = (int*)calloc(4, sizeof (int)); int* p3 = (int)realloc(p2, sizeof(int)10); // 这里需要free(p2)吗？ free(p3 ); &#125; 2.1.1 malloc 动态申请内存 2.1.2 calloc 不光申请空间，还对这个空间进行初始化 初始化的空间用户不能指定，它自己规定为 0 2.1.3 realloc 调整空间 空间已经存在，只需要做调整空间大小 ++12345678910111213141516void realloc(int *ptr,int size) //ptr 指向需要调整的空间，而size 表示需要的空间大小 #include&lt;iostream&gt; using namespace std; int main()&#123; int *pi=(int *)malloc(sizeof(int )*20); //申请动态内存 free(pi); //将申请的内存释放掉 char *pc=(char *)malloc(20); char *ppc=(char *)realloc(pc,40); //free(pc); 释放pc 不保险 free(ppc); return 0; &#125; 3.C++ 的内存管理方式 C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：通过new和delete操作符进行动态内存管理。 3.1 new/delete操作内置类型++12345678910111213141516#include&lt;iostream&gt; using namespace std; int main()&#123; int *pa = new int; //new 为关键字， 而int 为需要申请的空间类型 int *pb = new int(1); //申请一块空间，并且初始值赋为 1 delete pb; //c++释放单个空间的方式 int *pc = new int[10]; //申请一块连续的空间，空间为10个int类型的空间大小为 40 字节 delete[]pc; //c++释放连续空间的方式 //new/delete new[]/delete [] return 0; &#125; 注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[] 内置类型 malloc 和 new 效果一样 自定义类型 malloc 和new 不一样 C++推荐使用new 3.2 new和delete操作自定义类型++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//例一#include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; class A&#123; private: int _a; int _b; &#125;; int main()&#123; A* pa = (A *)malloc(sizeof(A)); free(pa); A *pb = new A; delete pb; A *pc = new A[10]; delete[]pc; return 0; &#125;//例二 #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;windows.h&gt; using namespace std; class A&#123; public: A()&#123; cout &lt;&lt; "A" &lt;&lt; endl; &#125; ~A()&#123; //释放空间 //if(_pi)&#123; //free(_pi); //_pi=nullptr; cout &lt;&lt; "~A" &lt;&lt; endl; &#125; private: int _a; int _b; int *_pi; //加入申请了空间 &#125;; int main()&#123; /*A* pa = (A *)malloc(sizeof(A)); free(pa);*/ A *pb = new A; //new 调用自定义类型的构造函数，malloc不会 delete pb; //delete 调用自定义类型的析构函数，free不会 /*A *pc = new A[10]; delete[] pc;*/ system("pause"); return 0; &#125; //总结：new-&gt;operator new -&gt;构造 // delete --&gt;析构 ---&gt;opeator delete//例三#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Test&#123;public: Test() : _data(0) &#123; cout &lt;&lt; "Test():" &lt;&lt; this &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; "~Test():" &lt;&lt; this &lt;&lt; endl; &#125;private: int _data;&#125;;int main()&#123; Test* pa = (Test *)malloc(sizeof(Test));//只是开辟空间 free(pa); Test *pb = new Test; //new 对于自定义类型来说，他是开辟空间+调用构造函数(初始化) delete pb; Test *pc = new Test[10];//调用构造函数 delete[]pc; return 0;&#125; 课件例题 ++12345678910111213141516171819202122232425262728293031323334class Test &#123; public: Test() : _data(0) &#123; cout&lt;&lt;"Test():"&lt;&lt;this&lt;&lt;endl; &#125; ~Test() &#123; cout&lt;&lt;"~Test():"&lt;&lt;this&lt;&lt;endl; &#125; private: int _data; &#125;; void Test2() &#123; // 申请单个Test类型的空间 Test* p1 = (Test*)malloc(sizeof(Test)); free(p1); // 申请10个Test类型的空间 Test* p2 = (Test*)malloc(sizoef(Test) * 10); free(p2); &#125; void Test2() &#123; // 申请单个Test类型的对象 Test* p1 = new Test; delete p1; // 申请10个Test类型的对象 Test* p2 = new Test[10]; delete[] p2; &#125; 注意：在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc与free不会 4. operator new与operator delete函数 new和delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。 12345678内置类型new int==》operator new 开空间==》malloc==》构造函数malloc int ==》malloc int 也有构造函数；new Test ==&gt;operator new =&gt;malloc ==构造malloc Test== malloc ++12345678910111213141516171819 /* operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。 */ void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) &#123; // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) &#123; // report no memory // 如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); &#125; return (p); &#125;//用法上:opeartor new &lt;==&gt;封装了( malloc + 失败抛异常)//用法上:operatir delete &lt;==&gt; free 申请空间异常的情况 ++123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;windows.h&gt; using namespace std; int main()&#123; //两种处理异常的方式 cout &lt;&lt; "malloc:" &lt;&lt; endl; char *p = (char*)malloc(0x7ffffffff); cout &lt;&lt; (void*)p &lt;&lt; endl; free(p); cout &lt;&lt; "new:" &lt;&lt; endl; try&#123; char *p = new char[0X7fffffff]; cout &lt;&lt; (void*)p &lt;&lt; endl; &#125; catch (exception&amp; e)&#123; cout &lt;&lt; e.what() &lt;&lt; endl; //特殊接口：e.what() &#125; //operator new:malloc + 异常 //operator delete&lt;==&gt;free(相当于) system("pause"); return 0; &#125; 4.1双向链表中的应用++123456789101112131415161718192021struct ListNode&#123; ListNode *_prev; LisrNode *_next; int _date; void *operator new(size_t n)&#123; void *p=allocator&lt;ListNode&gt;().allocate(1); cout&lt;&lt;"mem pool allocate"&lt;&lt;endl; return p; &#125; void operator delete (void *p)&#123; allocator&lt;ListNode&gt; &#125; &#125;; int mian()&#123; List *p1=new List[10]; // free(p1); //用new 申请的空间必须要delete 来释放 delete[] p1; // return 0; &#125; new\delete\总结 自定义类型：new malloc delete free new: opeator new —-&gt;malloc + 构造 malloc: malloc new[N] : operator new [N]—&gt;opertor new —&gt;malloc + N次构造 delete :析构 + opeator delete —&gt;free free: free delete[]: N(析构 + operator delete –&gt; free) new 申请的空间，系统不会自己释放，需要自己手动释放(delete) 内置类型： new : malloc + 异常 malloc :malloc delete: 封装free free: free 5.new和delete的实现原理5.1 内置类型 如果申请的是内置类型的空间，new和malloc，delete和free基 本类似，不同的地方是：new/delete申请和释放的是单个元素的 空间，new[]和delete[]申请的是连续空间，而且new在申请空间 失败时会抛异常，malloc会返回NULL。 5.2 自定义类型 new的原理 : 调用operator new函数申请空间 在申请的空间上执行构造函数，完成对象的构造 delete的原理 在空间上执行析构函数，完成对象中资源的清理工作 new T[N]的原理 1.调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请 2.在申请的空间上执行N次构造函数 delete[]的原理 1.在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理 2.调用operator delete[]释放空间，实际在operator delete[]中 调用operator delete来释放空间 6.定位new表达式(placement-new) 定位new表达式是在已分配的原始内存空间中调用构造函数初始化一个对象。 使用格式： 1.new (place_address) type或者new (place_address) type(initializer-list) 2.place_address必须是一个指针，initializer-list是类型的初始化列表 使用场景： 定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化 ++1234567891011121314151617181920212223242526272829303132333435363738394041424344class Test &#123; public: Test() : _data(0) //初始化表达式 &#123; cout&lt;&lt;"Test():"&lt;&lt;this&lt;&lt;endl; &#125; ~Test() &#123; cout&lt;&lt;"~Test():"&lt;&lt;this&lt;&lt;endl; &#125; private: int _data; &#125;; void Test() &#123; // pt现在指向的只不过是与Test对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行 Test* pt = (Test*)malloc(sizeof(Test)); new(pt) Test; // 注意：如果Test类的构造函数有参数时，此处需要传参 &#125; //初始化表达式使用的例子 class Date&#123; public: Date(int year=1900,int month=1,int day=1) :_year(year) ,_month(month)//初始化表达式使用的例子 ,_day(day) &#123;&#125; private: int _year; int _month; int _day; &#125; int main()&#123; Date* pd=(Date*) malloc(sizeof(Date)); Date* pd2=(Date*) malloc(sizeof(Date)); //pd2的值是随机的 new(pd)Date; //不带参 new(pd2)Date（1939，2，3）; //带参 return 0; &#125; ++123456789class A&#123; int a; &#125;; int main()&#123; A* pa =new A; delete pa;//delete释放指针指向的那一快堆上的空间 return 0; &#125; 7.常见的面试题7.1 malloc/free和new/delete的区别 malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。不同的地方是： 1. malloc和free是函数，new和delete是操作符 2. malloc申请的空间不会初始化，new可以初始化 3.malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可 4.malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型 5 .malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要 捕获异常 6 .申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在 申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中 资源的清理 7. new/delete比malloc和free的效率稍微低点，因为new/delete的底层封装了malloc/free668 7.2 请设计一个类，该类只能在堆上创建对象 方法一：构造函数私有化 将类的构造函数私有，拷贝构造声明成私有。防止别人调用拷贝 在栈上生成对象 ++1234567891011121314151617class HeapOnly &#123; public: static HeapOnly* CreateObject() &#123; return new HeapOnly; &#125; private: HeapOnly() &#123;&#125; // C++98 // 1.只声明,不实现。因为实现可能会很麻烦，而你本身不需要 // 2.声明成私有 HeapOnly(const HeapOnly&amp;)； // or // C++11 HeapOnly(const HeapOnly&amp;) = delete; &#125;; ++1234567891011121314151617181920212223242526272829303132333435363738394041//上课例题代码 //指针访问 -&gt; //对象 . //1.构造函数私有化 //2.提供公共接口：在堆上创建对象 //3.在类外面无法创建对象，函数用类名调用，公共接口必须为static接口 //4.防止拷贝: //&lt;1&gt;:拷贝构造私有化，只声明不实现 //&lt;2&gt;：拷贝构造声明成delete函数(C++11的特性) class Heap &#123; friend void fun1(); public: static Heap* getHeap() &#123; return new Heap; &#125; Heap(const Heap&amp; hp) = delete; private: Heap()&#123;&#125; &#125;; Heap::Heap(const Heap&amp; hp)&#123;&#125; void fun1() &#123; Heap* hp = Heap::getHeap(); Heap hp2(*hp); &#125; int main() &#123; /*Heap* hp = new Heap; Heap hhp; hp-&gt;getHeap(); hhp.getHeap();*/ Heap* hp = Heap::getHeap(); Heap hp2(*hp); return 0; &#125; 7.3 请设计一个类，该类只能在栈上创建对象(类似上面) new 关键字是如何执行的 不能在堆上建造空间 ++123456789101112131415161718192021222324252627class Stack&#123; public: static Stack getStack()&#123; return Stack();//不能返回指针(也不能返回引用) //当前函数的返回值，在栈上 &#125; private: stack()&#123; &#125; &#125;; class statck2&#123; ///new --&gt; opeator new; void *operator new(size_t n)=delete; //放在公共的申明下，依旧不可调动 //无法使用，被删除的函数 private: void *operator new(size_t n); &#125;; int main()&#123; //Stack *ps=new Stack; Stack s=Stack :: getStack(): Stack cp(s); // cp在栈上 stack2 ps =new stack2; return 0; &#125; 只能在栈上创建对象的类 new —&gt;operator new –&gt;构造方法一： 构造函数私有化，间接阻止new 关键字的执行逻辑 构造公共接口：在栈上创建对象 在类外面无法创建对象，函数用类名调用，公共接口必须为static接口 方法二： 1.重载operator new 函数，申明成私有的，并且不实现 2.构造函数公有 单例模式:全局唯一一份 [ ] 1.饿汉 缺点： 1.启动比较慢 2.没有办法控制多个单例模式之间的启动顺序 ++12345678910111213141516171819202122232425//饿汉模式//优点：简单// 缺点：可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。 class singleton&#123; public: static singlleton* getInstance()&#123; return &amp; _sin; &#125; private: singleton()&#123; &#125; //防拷贝 //singleton (const singlenton &amp;s);//或写成删除函数都可以 singleton (const singlenton &amp;s)=delete; //singlrton &amp;operator=(const singleton &amp;s); static singleton _sin; //c程序启动前，已经定义好了 //singleton _sin;//不能如此定义，其会自己调自己。 &#125;; singleton singleton::_sin; int main()&#123; singleton *ps=singleton :: getInstance; singleton s(*ps); return 0; &#125; [ ] 饿汉模式 如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好. ++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class singleton&#123; public: singleton *getIntance()&#123; if(_ps==nullptr)&#123; _ps = new singleton; //第一次还没有，现场做 &#125; return _ps; //第二次以后已经做好了，直接拿去用 &#125; private: singleton()&#123;&#125; singleton(const singleton&amp; s);//只声明不是 static singleton* _ps;//全局唯一 &#125;; singleton *singleton ::_ps=nullptr; //先置空，啥时候需要再给你 int main()&#123; singleton* ps = singleton :: getIntance(); singleton *ps2 =singleton :: getIntance(); return 0; &#125; #include &lt;thread&gt; #include &lt;mutex&gt; class Singleton &#123; public: static Singleton* getInstance() &#123; // double check if (_ps == nullptr) &#123; _mtx.lock(); if (_ps == nullptr) &#123; _ps = new Singleton; &#125; _mtx.unlock(); &#125; return _ps; &#125; void testSing()//多线程 &#123; cout &lt;&lt; Singleton::getInstance() &lt;&lt; endl; &#125; int main() &#123; /*Singleton* ps = Singleton::getInstance(); Singleton* ps2 = Singleton::getInstance(); int i = 0; i++;*/den /*fun(); //串行 fun();*/ /*thread t1(fun); //并行，同时执行 thread t2(fun);*/ /*testSing(); testSing();*/ thread t1(testSing); thread t2(testSing); t1.join(); // 等待 t2.join(); return 0; &#125; //造成无限递归 ~Singleton()&#123; if(_ps)&#123; delete _ps; //无限递归 _ps=nullpte &#125; &#125; //能做到释放空间 ~Singleton() &#123; cout &lt;&lt; "~Singleton()" &lt;&lt; endl; &#125; class GC &#123; public: ~GC() &#123; if (_ps) &#123; delete _ps; _ps = nullptr; &#125; &#125; &#125;; int main() &#123; Singleton* ps = Singleton::getInstance(); //delete ps;//不能这样去释放堆上的空间，造成无限递归 //调用析构函数，造成栈溢出 return 0; &#125; //多线程：多个人做一份工作 //单线程：一个人做一份工作 //多个线程加把锁 include _mtx.clock(); // 加锁 。。。。。_mtx.unlock(); //解锁//加锁的代价 —&gt;//多个进程同时进行时，锁只影响第一批进程。static mutex 7.5 内存泄漏7.5.1 什么是内存泄漏 内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内 存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程 序分配某段内存后，因为设计错误，失去了对该段内存的控制， 因而造成了内存的浪费 ++12345678910111213141516171819//当使用delet时，调用析构函数，导致无限递归 ~singleton()&#123; if(_ps)&#123; //无限递归，导致栈溢出 delete _ps; _ps = nulllpter; &#125; &#125; void MemoryLeaks() &#123; // 1.内存申请了忘记释放 int* p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p3 = new int[10]; Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被放. delete []p3; &#125; 7.5.2 如何检测内存泄漏 在linux下内存泄漏检测：linux下几款内存泄漏检测工具 在windows下使用第三方工具：VLD工具说明 其他工具：内存泄漏工具比较 7.5.3如何避免内存泄漏 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状 态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。 ++12345678910111213141516//1. 采用RAII思想或者智能指针来管理资源。 void MemoryLeaks() &#123; // 1.内存申请了忘记释放 int* p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p3 = new int[10]; Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放. delete[] p3; &#125; 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。 出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。 总结一下: 内存泄漏非常常见，解决方案分为两种： 1、事前预防型。如智能指针等。 2、事后查错型。如泄漏检测工具。 7.6 如何一次在堆上申请4G的内存 ++123456789// 将程序编译成x64的进程，运行下面的程序试试？ #include &lt;iostream&gt; using namespace std; int main() &#123; void* p = new char[0xfffffffful]; cout &lt;&lt; "new:" &lt;&lt; p &lt;&lt; endl; return 0; &#125;]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C ++ 类与对象]]></title>
    <url>%2F2019%2F03%2F14%2FC%2B%2B%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1.类的引入1.1 c语言中对结构体的引用12345678910111213141516171819202122struct ListNode&#123; int data; struct ListNode* next; struct ListNode* prev;&#125;;//类型：struct ListNode//c++兼容c语言int main()&#123; struct ListNode node; return 0;&#125; 1.2 c++中也可以编过1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;struct ListNode&#123; int data; ListNode* next; ListNode* prev; //两个程序中的不同引用方式&#125;;//类型：struct ListNode//c++兼容c语言 int main()&#123; struct ListNode node; system("pause"); return 0;&#125; 1.3 struct的双重身份 1.3.1 c语言中表示结构体。 类型：struct ListNode 1.3.2 C++中升级成了类。类型：ListNode ， struct 为关键字，而 LIstnode为类名,就可以当作类型 [ ] struct 类里面既可以定义变量，也可以定义函数. [ ] struct 与 class的区别是啥？ struct 在c语言阶段就是一个结构体，而在c++中做为类存在。 class在c++中就是一个类， 两者做为类在c++中的区别是什么？ struct 是公有的，class 是私有的 2.类的定义2.1 类的定义方式：12345678 class classname&#123; //类体由成员变量和成员函数组成 &#125;; //一定要注意后面的分号//class 为关键字，classname 为类的名字 ，&#123;&#125;中的类为主体，注意类定义结束时后面的分号。//类中的元素称为类的成员：类的数据称为类的属性或者成员变量；类中的函数称为类的方法或者成员函数 2.2 类的两种定义方式2.2.1 : 声明和定义全都放到类体中123456789class A&#123; //成员函数 void fun()&#123; &#125; //成员变量 int a; int b; int c; &#125;; 需要注意的是：成员函数如果在类中定义，编译器可能会将 其当成内联函数处理 2.2.1.1 ；声明和定义全都放到类体中12345678910class A&#123; //成员函数 void fun()&#123; &#125; //成员变量 int a; int b; int c; &#125;; 2.2.1.2 :在类里面声明在外定义12345678class B&#123; void fun(); &#125;; void B::fun()&#123; //::作用域限定符 &#125; 2.2.2:声明在.h中，类的定义在.cpp中12345678//b.h class B&#123; void fun() ; &#125;; //b.cpp #include "p.h" void B::fun()&#123; //::作用域解析符 &#125; 3.类的访问限定符及封装3.1 访问限定符 C++实现封装的方式：用类将对象的属性与方法结合在一 块，让对象更加完善，通过访问权限选择性的将其 接口提供给外部的用户使用。 访问限定符； 1.public(公有) 2.protected(保护) 3.private (私有) ​ 1234567891011121314151617class A&#123; public: //公有成员函数 void fun()&#123; &#125; private: //私有成员变量 int a; int b; int c; &#125;; int main()&#123; A x; x.fun(); //可以访问到 x.b;//访问不到b return 0; &#125; 被访问限定符修饰的变量或函数在类里面是通用的，在类外 面private 修饰的变量或者函数在类外面不可以访问。 私有限定的是你不能类外面修改类内部的东西，而在类内部可修改 【访问限定符说明】 public 修饰的成员在类外可以直接被访问 ​ 2. protected 和 private 修饰的成员在类外不能直接被访问(此处 protected 和 private 是类似的) 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止 ​ class的默认访问权限为 private ， struct 为 public(因为struct要兼容C) 注意：访问限定符只在编译时有用，当数据映射到内存后， 没有任何访问限定符上的区别 而 struct 定义的变量还是函数都是公有的，但 class 类中 由公有的也有私有的 1234567891011121314151617181920class SeqList&#123; void PopBack();//默认是私有的 public: void PushBack(int x)&#123; ++size; //操作可以正确运行， //原因是访问限定符限制的类的外面，不限制类的里面 &#125; //将x 插到SeqList这个类中去 private: int *a; size_t size; szie_t capacity;&#125;;int main()&#123; SeqList s; //s叫做对象 s.PushBack(1);//把一插入到SeqList这个顺序表中 //s.size++;//语句错误，size 为私有成员 //S.PopBack() //私有成员不可以访问 return 0;&#125; 【面试题】 问题：C++中struct和class的区别是什么？ 解答：C++需要兼容C语言，所以C++中struct可以当成结构体去使用。另外C++中struct还可以用来定义类。和class是定义类是一样的，区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式是private。 3.2 封装3.2.1 【面试题】 面向对象的三大特性：封装、继承、多态。 分装就是为了管理 [ ] ​在类和对象阶段，我们只研究类的封装特性，那什么是封装呢？ 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。 1234567891011121314151617//封装//C语言的结构体struct SeqList&#123; int *a; size_t size; ....&#125;void PushBack(struct SeqList *ptr,int x)//将插到struct SeqList中//c++中class SeqList&#123; void PushBack(int x); //将x 插到SeqList这个类中去 int *a; size_t size; szie_t capacity;&#125;; 3.2.2 封装本质上是一种管理.4.类的作用域4.1:类定义了一个新的作用域，类的所有成员都在类的作用域中。 在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。 123456789101112class Person&#123;public: void PrintPersonInfo();private:char _name[20];char _gender[3];int _age;&#125;;// 这里需要指定PrintPersonInfo是属于Person这个类域void Person::PrintPersonInfo()&#123; cout&lt;&lt;name&lt;&lt;" "gender&lt;&lt;" "&lt;&lt;_age&lt;&lt;endl;&#125; 5.类的实例化 用类类型创建对象的过程，称为类的实例化 类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它 一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间类在计算机当中不占内存，只有来定义的对象才占内存 int a; int—&gt;变量类型 a—-&gt;int 类型的变量 class A( 楼房的设计图纸 ) A ra A —&gt;类型 ra—&gt; A类型的变量 —&gt;类的对象(按照图纸建造的房子) 1234567891011121314151617181920class SeqList&#123; public: void PushBack(int x)&#123;//类内部的申明 &#125; private: int *_a; //声明 size_t size; size_t capacity;&#125; void SeqList::PushBack(int x)//定义 int main()&#123; SeqList s;//现在才被定义出来 cout&lt;&lt;sizeof(SeqList)&lt;&lt;endl;//结果为12 return 0; &#125;//声明只是告诉说明它的类型与名称//定义是将声明的东西创建出来 拿着Person这个类定义man 这个对象 6.类对象模型 结论：一个类的大小，实际就是该类中”成员变量”之和，当 然也要进行内存对齐，注意空类的大小，空类比较特殊，编 译器给了空类一个字节来唯一标识这个类。 7.结构体内存对齐的规则7.1如何计算类对象的大小12345678910class A&#123;public: void PrintA &#123; cout&lt;&lt;_a&lt;&lt;endl; &#125;private: char _a;&#125;; 问题：类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大小 7.2 类对象的存储方式猜测7.2.1对象中包含类的各个成员 7.2.2:只保存成员变量，成员函数存放在公共的代码段 123456789101112131415// 类中既有成员变量，又有成员函数class A1 &#123;public: void f1()&#123;&#125;private: int _a;&#125;;// 类中仅有成员函数class A2 &#123;public: void f2() &#123;&#125;&#125;;//大小为1，不存储数据，占位，表示对象存在过// 类中什么都没有---空类class A3&#123;&#125;; sizeof(A1) : _4_ sizeof(A2) : _1_ sizeof(A3) : _1_结论：一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类。 7.3 内存对齐7.3.1. 第一个成员在与结构体偏移量为0的地址处。7.3.2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。VS中默认的对齐数为8，gcc中的对齐数为4 7.3.3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。7.3.4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处， 结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。 1234567891011121314151617#include &lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class A1&#123; char _ch; double _d;&#125;;class A2&#123; double _d; char _ch;&#125;;int main()&#123; cout &lt;&lt; "A1的大小="&lt;&lt;sizeof(A1) &lt;&lt; endl; cout &lt;&lt; "A2的大小=" &lt;&lt; sizeof(A2) &lt;&lt; endl; system("pause"); return 0;&#125; 8.this指针8.1 this指针的引出12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: void Print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125; void SetDate(int year, int month, int day)&#123; //构造的函数类似于买门票才能看到兵马用内部的东西 //公有函数提供了访问内部成员的机会 _year = year; // 加上"_"可以避免冲突 _month = month; _day = day; &#125;private://类似与兵马俑里面的展品。 int _year; int _month; int _day;&#125;;int main()&#123; Date d1; Date d2; d1.SetDate(2019, 3, 9); d2.SetDate(2018,3,9); d1.Print();//如何识别打印那个对象对应的日期--&gt;引出this指针 d2.Print();//如何识别打印那个对象对应的日期 //this指针隐含在形参的首位，把d2的地址传给对应函数Print system("pause"); return 0;&#125; 8.2 解释1234567891011//经过改造编译器后 d1.Print(); ===&gt;d1.Print(&amp;d1); d2.Print();====&gt;d2.Print(&amp;d2);void Print()&#123; \\ 改造后() 中间加入了 Date* this cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;//这一句中语句变成了 year ==&gt;this-&gt;year month ==&gt;this-&gt;month day ===&gt; this -&gt;day &#125;//此时d1.Print(&amp;d1) 或者 d2.Print(&amp;d2); 谁调用 Print 函数 this 指针就指向谁； this 指针类似于形参，谁调用就指向谁。 所以其存储在栈上,且其可以为空。 是否可以为空，面试题 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std; class Date&#123;public: void Func()&#123;//此处this传过来的地址为空时不影响该函数的输出 cout &lt;&lt; "Date::Func()" &lt;&lt; endl; &#125; void Print()&#123; //此处this传过来的地址为空时this-&gt;_year出错 cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; // cout &lt;&lt;this-&gt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125;private: //类似与兵马俑里面的展品。 int _year; int _month; int _day;&#125;;int main()&#123; Date* p1 = NULL;//此处为空，this解引用没有访问，可以运行 p1-&gt;Func(); //this指针隐含在形参的首位，把p1的地址传给对应函数 Date* p2 = NULL;//此处为空，解引用this 时， //this为空不能被访问，程序奔溃 p2-&gt;Print(); system("pause"); return 0;&#125;//内存访问是按最大对齐数整数倍访问的 即：C++编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。 8.3 this指针的特性 8.3.1. this指针的类型：类型* const 8.3.2. 只能在“成员函数”的内部使用 8.3.3. this指针本质上其实是一个成员函数的形参，是对象调用成员函数时， 将对象地址作为实参传递给this形参。所以对象中不存储this指针。 8.3.4. this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过 ecx寄存器自动传递，不需要用户传递 this 指针可以为空]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>类与对象(上)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F03%2F14%2Fc%20%E8%AF%AD%E8%A8%80%E7%89%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%A1%BA%E5%BA%8F%E8%A1%A8)%2F</url>
    <content type="text"><![CDATA[顺序表一：前言(初步认识) 1.1 顺序表概念顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用 **数组** 存储。在数组上完成数据的增删查改。 1.2 顺序表一般可以分为：a. 静态顺序表：使用定长数组存储。 b. 动态顺序表：使用动态开辟的数组存储。 二：代码实现A:顺序表的两种定义方式首先定义一个全局变量 1typedef int SDataType; a.定义静态存储结构 123456typedef struct SeqList&#123; //静态顺序表定义 int array[100]; // 能存 100 个数的静态顺序表 int size; //当前顺序表中存放的数，顺序表为空size=0 //顺便表示了即将插入的下标&#125; Seqlist; b.定义动态存储结构 123456typedef struct SeqList&#123; //动态顺序表定义 SDataType *array; int size; //当前顺序表中存放的数，顺序表为空size=0，当顺序表不为空是表示数据中元素的下标 int capacity; //顺序表的容量&#125; SeqList; B：顺序表的初始化与销毁a:初始化123456void SeqListInit(SeqList *seqlist, int capacity)&#123; assert(seqlist != NULL); seqlist-&gt;array = (SDataType*)malloc(sizeof(SDataType)*capacity); seqlist-&gt;size = 0; seqlist-&gt;capacity = capacity;&#125; 首先需要申请空间，而参数中的 capacity 指的是你在初始化时所需要的空间大小。 b:销毁建立的顺序表 代码 12345678void SeqListDestroy(SeqList *seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array!=NULL); seqlist-&gt;array = NULL; seqlist-&gt;size = 0; seqlist-&gt;capacity = 0; free(seqlist-&gt;array); //重点&#125; 辅助理解 在销毁时只需要将指向定义数组的指针设置为空(而非将顺序表中的元素一个一个的往掉删除)，并且将记录顺序表中元素数量的 size 置为 将申请的空间释放。(必须释放，不然会造成内存泄漏) C：增(往顺序表中添加元素)a:头插 代码 12345678910111213141516171819//头插//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标[size,0)// i 数据下标[size-1,0]//3. 搬移 // i对应空间下标： array[i]=array[i-1];// i对应数据下标： array[i+1]=array[i];void SeqListPushFront(SeqList *seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); for (int i = seqlist-&gt;size ; i &gt; 0; i--)&#123; //做数据的搬移，i代表空间下标 seqlist-&gt;array[i] = seqlist-&gt;array[i - 1]; &#125; seqlist-&gt;array[0] = value; seqlist-&gt;size++;&#125; 辅助理解 在进行头插运算时，需要考虑将原来顺序表中的元素从最后一位开始往后挪动一位，防止数据的丢失。 (若从第一位开始挪动，则会造成数的丢失。当打印时打印出来的顺序表元素全都是一个数字) 如下例中将value插入数组首地址时，应按顺序将数组中的元素往后移，然后再家将value的值插入。 b:尾插 代码 1234567891011void SeqListPushBack(SeqList *seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); CheckCapccity(seqlist); seqlist-&gt;array[seqlist-&gt;size] = value; seqlist-&gt;size++;&#125;//尾插时直接将 value 的值插入到顺序表的最后一位即可。 c: 从指定的位置 (position)处插入value 代码示例 123456789101112void SeqListInsert(SeqList *seqlist, int pos, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(pos &gt;= 0 &amp;&amp; pos &lt;= seqlist-&gt;size); //检查要插入的位置是否合法 for (int i = seqlist-&gt;size - 1; i &gt;= pos; i--)&#123; seqlist-&gt;array[i+1] = seqlist-&gt;array[i]; &#125;//做数组搬移，将pos位置往后的元素按顺序依次从往后移动一位 seqlist-&gt;array[pos] = value; seqlist-&gt;size++;&#125; D: 删(从顺序表中删除制定的元素)a:头删 代码示例 12345678910111213141516171819//头删//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标 [0,size-2]// i 数据下标 [1,size-1]//3. 搬移 // i对应空间下标： array[i-1]=array[i];// i对应数据下标： array[i]=array[i+1];void SeqListPopFront(SeqList* seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(seqlist-&gt;size &gt; 0); //i 代表的是空间下标 for (int i = 1; i &lt;seqlist-&gt;size ; i++)&#123; seqlist-&gt;array[i - 1] = seqlist-&gt;array[i]; &#125; seqlist-&gt;size--;&#125; b:中间删除(指定位置删除某位置元素) 代码示例 123456789101112//删除 pos 所在的下标数据void SeqListErase(SeqList *seqlist, int pos)&#123; assert(seqlist!=NULL); assert(seqlist-&gt;array!=NULL); assert(seqlist -&gt;size&gt;0); assert(pos &gt;= 0 &amp;&amp; pos &lt; seqlist-&gt;size); //做数据的搬移，因为是将指定位置的元素删除既可直接将其覆盖 for (int i = pos; i &lt;seqlist-&gt;size; i++)&#123; seqlist-&gt;array[i] = seqlist-&gt;array[i+1]; &#125; seqlist-&gt;size--;&#125; c:尾删 代码示例 123456void SeqListPopBack(SeqList*seqlist)&#123;gai assert(seqlist!=NULL); assert(seqlist-&gt;array!=NULL); assert(seqlist-&gt;size &gt; 0); seqlist-&gt;size--;&#125; E:改（修改pos 所在下标的所在数据） 代码示例 12345//修改pos 所在下标的所在数据为 valuevoid SeqListModify(SeqList *seqlist, int pos, SDataType value)&#123; assert(pos&gt;=0&amp;&amp;pos&lt;seqlist-&gt;size); seqlist-&gt;array[pos] = value;&#125; F:查(查找指定元素)a:查找 代码示例 1234567891011//查找//如果找到，返回第一个找到的下标//如果没找到返回-1int SeqListFind(const SeqList *seqlist, SDataType value)&#123; assert(seqlist!=NULL); for (int i - 0; i &lt; seqlist-&gt;size;i++)&#123; if (seqlist-&gt;array[i] == value) return i; &#125; return -1;&#125; b:找到并删除第一个遇到的 value 代码示例123456void SeqListRemove(SeqList *seqlist, SDataType value)&#123; int pos = SeqListFind(sqlist,value); if (pos != -1)&#123; SeqListErase(seqlist,pos); &#125;&#125; 以上即为数据结构顺序表中最基本的操作增 、删、改、查四种操作的代码示例。尽管理解起来比较抽象，但是只用自己敲一遍，并且理解透彻的话。你会发现也没有想象中的那么难以理解。 三：整体实现main.c1234567891011121314151617181920212223242526#include"SeqList.h"void TestSeqList()&#123; SeqList seqlist; SeqListInit(&amp;seqlist,100); SeqListPushBack(&amp;seqlist,1); SeqListPushFront(&amp;seqlist,11); SeqListPushBack(&amp;seqlist,2); SeqListPushFront(&amp;seqlist,12); SeqListPushBack(&amp;seqlist,3); SeqListPushFront(&amp;seqlist,13); SeqListInsert(&amp;seqlist,4,100); SeqListPopBack(&amp;seqlist); SeqListPopFront(&amp;seqlist); SeqListErase(&amp;seqlist, 3); SeqListPrint(&amp;seqlist); SeqListDestroy(&amp;seqlist);&#125;int main()&#123; TestSeqList(); system("pause"); return 0;&#125; SeqList.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include"SeqList.h"//扩容//条件:当size=capacity时说明顺序表已满static void CheckCapccity(SeqList *seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(seqlist-&gt;size &lt;= seqlist-&gt;capacity); if (seqlist-&gt;size &lt; seqlist-&gt;capacity)&#123; return; &#125; //走到这里，需要扩容 int capacity = 2 * seqlist-&gt;capacity; SDataType *array = (SDataType *)malloc(sizeof(SDataType)*capacity); assert(array); //把老数据搬过来 for (int i = 0; i &lt; seqlist-&gt;capacity; i++)&#123; array[i] = seqlist-&gt;array[i]; &#125; //释放老空间 free(seqlist-&gt;array); seqlist-&gt;array = array; //数组代表数组的首地址&#125;//顺序表的初始化void SeqListInit(SeqList *seqlist, int capacity)&#123; assert(seqlist != NULL); seqlist-&gt;array = (SDataType*)malloc(sizeof(SDataType)*capacity); seqlist-&gt;size = 0; seqlist-&gt;capacity = capacity;&#125;//顺序表的销毁//只管将数组的首地址置为空，将表示数组的数目size置为0即可//并且将原来初始化顺序表时申请的空间释放即可void SeqListDestroy(SeqList *seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array!=NULL); seqlist-&gt;array = NULL; seqlist-&gt;size = 0; seqlist-&gt;capacity = 0; free(seqlist-&gt;array); //重点&#125;//尾插，不需要搬移数组中的元素void SeqListPushBack(SeqList *seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); CheckCapccity(seqlist); seqlist-&gt;array[seqlist-&gt;size] = value; seqlist-&gt;size++;&#125;//头插void SeqListPushFront(SeqList *seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); CheckCapccity(seqlist); //做数据的搬移，i代表空间下标 for (int i = seqlist-&gt;size ; i &gt; 0; i--)&#123; seqlist-&gt;array[i] = seqlist-&gt;array[i - 1]; &#125; //注意循环的条件 seqlist-&gt;array[0] = value; seqlist-&gt;size++;&#125;//中间插入void SeqListInsert(SeqList *seqlist, int pos, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(pos &gt;= 0 &amp;&amp; pos &lt;= seqlist-&gt;size); CheckCapccity(seqlist); for (int i = seqlist-&gt;size - 1; i &gt;= pos; i--)&#123; seqlist-&gt;array[i+1] = seqlist-&gt;array[i]; &#125; seqlist-&gt;array[pos] = value; seqlist-&gt;size++;&#125;//尾删void SeqListPopBack(SeqList*seqlist)&#123; assert(seqlist!=NULL); assert(seqlist-&gt;array!=NULL); assert(seqlist-&gt;size &gt; 0); seqlist-&gt;size--;&#125;//头删//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标 [0,size-2]// i 数据下标 [1,size-1]//3. 搬移 // i对应空间下标： array[i-1]=array[i];// i对应数据下标： array[i]=array[i+1];void SeqListPopFront(SeqList* seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(seqlist-&gt;size &gt; 0); for (int i = 1; i &lt;seqlist-&gt;size ; i++)&#123; seqlist-&gt;array[i - 1] = seqlist-&gt;array[i]; &#125; seqlist-&gt;size--;&#125;//删除 pos 所在的下标数据void SeqListErase(SeqList *seqlist, int pos)&#123; assert(seqlist!=NULL); assert(seqlist-&gt;array!=NULL); assert(seqlist -&gt;size&gt;0); assert(pos &gt;= 0 &amp;&amp; pos &lt; seqlist-&gt;size); for (int i = pos; i &lt;seqlist-&gt;size; i++)&#123; seqlist-&gt;array[i] = seqlist-&gt;array[i+1]; &#125; seqlist-&gt;size--;&#125;//打印void SeqListPrint(const SeqList *seqlist)&#123; for (int i = 0; i &lt; seqlist-&gt;size; i++)&#123; printf("%d ", seqlist-&gt;array[i]); &#125; printf("\n");&#125;//修改pos 所在下标的所在数据为 valuevoid SeqListModify(SeqList *seqlist, int pos, SDataType value)&#123; assert(pos&gt;=0&amp;&amp;pos&lt;seqlist-&gt;size); seqlist-&gt;array[pos] = value;&#125;//查找//如果找到，返回第一个找到的下标//如果没找到返回-1int SeqListFind(const SeqList *seqlist, SDataType value)&#123; assert(seqlist!=NULL); for (int i = 0; i &lt; seqlist-&gt;size;i++)&#123; if (seqlist-&gt;array[i] == value) return i; &#125; return -1;&#125;//找到并删除第一个遇到的 valuevoid SeqListRemove(SeqList *seqlist, SDataType value)&#123; int pos = SeqListFind(seqlist,value); if (pos != -1)&#123; SeqListErase(seqlist,pos); &#125;&#125;//判断顺序表是否为空，bool SeqListEmpty(const SeqList *seqlist)&#123; return seqlist-&gt;size == 0;&#125;//返回数据个数int SeqListSize(const SeqList *seqlist)&#123; return seqlist-&gt;size;&#125;void SeqListRemoveALl(SeqList* seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array!=NULL); //方法一： ////申请一个与原数组等长的数组 //SDataType *array = (SDataType*)malloc(sizeof(SDataType)*seqlist-&gt;size); //assert(array); //int index = 0; //for (int i = 0; i &lt; seqlist-&gt;size; i++)&#123; // if (seqlist-&gt;array[i] != value)&#123; // array[index] = seqlist-&gt;array[i]; // index++; // &#125; //&#125; //for (int j = 0; j &lt; index; j++)&#123; // seqlist-&gt;array[j] = array[j]; //&#125; //seqlist-&gt;size = index; //法二 int index = 0; for (int i = 0; i &lt; seqlist-&gt;size; i++)&#123; if (seqlist-&gt;array[i] != value)&#123; seqlist-&gt;array[index] = seqlist-&gt;array[i]; index++; &#125; &#125; seqlist-&gt;size++;&#125; SeqList.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdint.h&gt;#include&lt;stdbool.h&gt;#include&lt;assert.h&gt;#include&lt;windows.h&gt;#pragma once//typedef struct SeqList&#123; // //静态顺序表定义// int array[100]; // 能存 100 个数的静态顺序表// int size; //当前顺序表中存放的数，// //顺序表为空size=0顺便表示了即将插入的下标//&#125; Seqlist;typedef int SDataType;typedef struct SeqList&#123; //动态顺序表定义 SDataType *array; int size; int capacity; //容量&#125; SeqList;//顺序表的初始化/销毁//seqlist 是一个变量的地址//capacity是顺序表的初始容量void SeqListInit(SeqList *seqlist, int capacity);void SeqListDestroy(SeqList *seqlist);//增删改查//1.增//尾插void SeqListPushBack(SeqList *seqlist, SDataType value);//头插//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标[size,0)// i 数据下标[size-1,0]//3. 搬移 // i对应空间下标： array[i]=array[i-1];// i对应数据下标： array[i+1]=array[i];void SeqListPushFront(SeqList *seqlist,SDataType value);//中间插入,往pos所在的下标插入value//1.从后往前// [size-1,pos] i 数据// array[i+1]=array[i];void SeqListInsert(SeqList *seqlist,int pos,SDataType value);//删//1.尾删void SeqListPopBack(SeqList* seqlist);//2.头删//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标 [0,size-2]// i 数据下标 [1,size-1]//3. 搬移 // i对应空间下标： array[i]=array[i+1];// i对应数据下标： array[i-1]=array[i];void SeqListPopFront(SeqList* seqlist);//删除 pos 所在的下标数据void SeqListErase(SeqList *seqlist,int pos);//打印void SeqListPrint(const SeqList *seqlist);//修改pos 所在下标的所在数据为 valuevoid SeqListModify(SeqList *seqlist,int pos, SDataType value);//查找int SeqListFind(const SeqList *seqlist,SDataType value);//找到并删除第一个遇到的 valuevoid SeqListRemove(SeqList *seqlist,SDataType value);//判断顺序表是否为空，bool SeqListEmpty(const SeqList *seqlist);//返回数据个数int SeqListSize(const SeqList *seqlist);//删除所有遇到的value值void SeqListRemoveALl(SeqList* seqlist,SDataType value);]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>顺序表</tag>
      </tags>
  </entry>
</search>
