<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库1.数据库的建立2.新建数据库对应表的建立3.删除表的操作4.简单的查询语句5.建立对应表的索引6.删除建立的索引 1.数据库的建立1.建库指令1create database &lt;数据库名&gt; 如下:建立一个叫 jack 的数据库 1create database jack 2.在新建的数据库下创建新表1.建表指令 1234use &lt;数据库名&gt; create table &lt;表名&gt;( &lt;表的列名&gt; &lt;该列将要存储的数据的类型&gt; (所存数据的长度)，); 如下：在 jack 库下建立一个student 表 12345678use jack create table student(sname char(10),sno char(20),ssex char(2),sage smallint,primary key nonclustered(sno)) 在 jack 库下建立一个 student 表 student 表包含学生姓名、学号、性别和年龄， 在建表是必须要申明主码既关键词 primary key 所修饰的列名 SQL server 在创建主码时会自动生成聚簇索引，如果表中还需要给别的字段创建聚簇，则可以通过 nonclustered 关键字来取消 好像不加那个use&lt;库名&gt;也可以创建新表 ，但是你要保证你只打开了这一个表 3.删除表的操作1.删表命令 1drop table &lt;要删除的表名&gt; 如下：删除表 ss 1drop table ss 4.简单的查询语句1.查询指令 123select &lt;所查属性1&gt;，&lt;所查属性n&gt;from &lt;标名/视图名&gt;where &lt;所查的对象&gt; 如下: 在jack库下的student表中查找sdept(系别)为is 的学生的学号和姓名及年龄 123select sno,sname,sagefrom student where sdept = &apos;is&apos; 查询结果如下 5.建立对应表的索引建立指令 1create [unique][clustered] index &lt;索引名&gt; 如下:为student表的sno 建立唯一索引 1create unique index stusno on student(sno) 命令运行结果 建立sname 的聚簇索引 1create clustered index stusname on student(sname) 执行结果 此处需要强调的是如果在建表是没有取消表默认的聚簇索引，则此时建立聚簇索引会报错 6.删除建立的索引1drop index &lt;建立的索引名&gt; on &lt;指定表名&gt; 删除建立的stusname 的聚簇索引 1drop index stusname on student]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>数据库基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统下cat指令与more指令的异同]]></title>
    <url>%2F2019%2F05%2F04%2FLinux-%E7%B3%BB%E7%BB%9F%E4%B8%8Bcat%E6%8C%87%E4%BB%A4%E4%B8%8Emore%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[Linux 系统下cat指令与more指令的异同 cat指令的功能 语法 cat 选项 文件 功能 查看目标文件的内容 使用方法主要选项 -b 对非空输出行编号-n 对输出的所有行编号-s 不输出多行空行 more的功能 大体功能相同与cat指令相同 语法 more 选项 文件 功能 more命令，功能类似 cat 使用方法主要选项 -n 对输出的所有行编号q 退出more 两者的相同点 相同点在于：都是用来查看文件内容的指令，两者用法基本相同两者的不同点不同点在于：cat指令查看完毕后会自动返回到正常模式而more指令则需要用户手动退出查看模式]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 系统下cat指令与more指令的异同</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim使用手册]]></title>
    <url>%2F2019%2F05%2F01%2FVim%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[VimTutor 中文版——vim 学习不二基础 =============================================================================== = 欢 迎 阅 读 《 V I M 教 程 》 —— 版本 1.5 =vim 是一个具有很多命令的功能非常强大的编辑器。限于篇幅，在本教程当中 就不详细介绍了。本教程的设计目标是讲述一些必要的基本命令，而掌握好这 些命令，您就能够很容易将 vim 当作一个通用的万能编辑器来使用了。 完成本教程的内容大约需要 25-30 分钟，取决于您训练的时间。 每一节的命令操作将会更改本文。推荐您复制本文的一个副本，然后在副本上 进行训练 (如果您是通过 &quot;vimtutor&quot; 来启动教程的，那么本文就已经是副本了)。 切记一点∶本教程的设计思路是在使用中进行学习的。也就是说，您需要通过 执行命令来学习它们本身的正确用法。如果您只是阅读而不操作，那么您可能 会很快遗忘这些命令的！ 好了，现在请确定您的 Shift-Lock(大小写锁定键) 还没有按下，然后按键盘上 的字母键 j 足够多的次数来移动光标，直到第一节的内容能够完全充满屏幕。 123456789101112131415 第一讲第一节∶移动光标 ※※ 要移动光标，请依照说明分别按下 h、j、k、l 键。 ※※ ^ k 提示∶ h 的键位于左边，每次按下就会向左移动。 &lt;h l&gt; l 的键位于右边，每次按下就会向右移动。 j j 键看起来很象一支尖端方向朝下的箭头。 v 1. 请随意在屏幕内移动光标，直至您觉得舒服为止。 2. 按下下行键 (j)，直到出现光标重复下行。---&gt; 现在您应该已经学会如何移动到下一讲吧。 3. 现在请使用下行键，将光标移动到第二讲。提示∶如果您不敢确定您所按下的字母，请按下 &lt;ESC&gt; 键回到正常 (Normal) 模式。 然后再次从键盘输入您想要的命令。提示∶光标键应当也能正常工作的。但是使用 hjkl 键，在习惯之后您就能够快速 地在屏幕内四处移动光标了。 第一讲第二节∶VIM 的进入和退出 !! 特别提示∶敬请阅读完整本一节的内容，然后才能执行以下所讲解的命令。 请按 键 (这是为了确保您处在正常模式)。 然后输入∶ :q! &lt;回车&gt;—&gt; 这种方式的退出编辑器绝不会保存您进入编辑器以来所做的改动。 如果您想保存更改再退出，请输入∶ :wq &lt;回车&gt; 如果您看到了命令行提示符，请输入能够带您回到本教程的命令，那就是∶vimtutor &lt;回车&gt;通常情况下您也可以用这种方式∶ vim tutor &lt;回车&gt;—&gt; 这里的’vim’ 表示进入 vim 编辑器，而’tutor’则是您准备要编辑的文件。 如果您自信已经牢牢记住了这些步骤的话，请从步骤 1 执行到步骤 3 退出，然后再次进入编辑器。接着将光标移动到第一讲第三节来继续我们的教程讲解。 123456789 第一讲第三节∶文本编辑之删除 ** 在正常 (Normal) 模式下，可以按下 x 键来删除光标所在位置的字符。** 1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。 2. 为了修正输入错误，请将光标移至准备删除的字符的位置处。 3. 然后按下 x 键将错误字符删除掉。 4. 重复步骤 2 到步骤 4，直到句子修正为止。---&gt; The ccow jumpedd ovverr thhe mooon. 5. 好了，该行已经修正了，下一节内容是第一讲第四节。特别提示∶在您浏览本教程时，不要强行记忆。记住一点∶在使用中学习。 第一讲第四节∶文本编辑之插入 在正常模式下，可以按下 i 键来插入文本。 请将光标移动到本节中下面标记有 —&gt; 的第一行。 为了使得第一行内容雷同于第二行，请将光标移至文本第一个字符准备插入的位置。 然后按下 i 键，接着输入必要的文本字符。 所有文本都修正完毕，请按下 &lt; ESC &gt; 键返回正常模式。重复步骤 2 至步骤 4 以便修正句子。 12---&gt; There is text misng this .---&gt; There is some text missing from this line. 如果您对文本插入操作已经很满意，请接着阅读下面的小结。 1234567891011121314 第一讲小结 1. 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 h (左移) j (下行) k (上行) l (右移) 2. 欲进入 vim 编辑器 (从命令行提示符)，请输入∶vim 文件名 &lt; 回车 &gt; 3. 欲退出 vim 编辑器，请输入以下命令放弃所有修改∶ &lt;ESC&gt; :q! &lt; 回车 &gt; 或者输入以下命令保存所有修改∶ &lt;ESC&gt; :wq &lt; 回车 &gt; 4. 在正常模式下删除光标所在位置的字符，请按∶ x 5. 在正常模式下要在光标所在位置开始插入文本，请按∶ i 输入必要文本 &lt;ESC&gt;特别提示∶按下 &lt;ESC&gt; 键会带您回到正常模式或者取消一个不期望或者部分完成的命令。好了，第一讲到此结束。下面接下来继续第二讲的内容。 第二讲第一节∶删除类命令 输入 dw 可以从光标处删除至一个单字 / 单词的末尾。 请按下 键确保您处于正常模式。 请将光标移动到本节中下面标记有 —&gt; 的那一行。 请将光标移至准备要删除的单词的开始。 接着输入 dw 删除掉该单词。特别提示∶您所输入的 dw 会在您输入的同时出现在屏幕的最后一行。如果您输 入有误，请按下 键取消，然后重新再来。—&gt; There are a some words fun that don’t belong paper in this sentence. 重复步骤 3 至步骤 4，直至句子修正完毕。接着继续第二讲第二节内容。 12345678 第二讲第二节∶其他删除类命令 ** 输入 d$ 从当前光标删除到行末。** 1. 请按下 &lt;ESC&gt; 键确保您处于正常模式。 2. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。 3. 请将光标移动到该行的尾部 (也就是在第一个点号‘.’后面)。 4. 然后输入 d$ 从光标处删至当前行尾部。---&gt; Somebody typed the end of this line twice. end of this line twice. 5. 请继续学习第二讲第三节就知道是怎么回事了。 第二讲第三节∶关于命令和对象 删除命令 d 的格式如下∶ [number] d object 或者 d [number] object 其意如下∶ number - 代表执行命令的次数 (可选项，缺省设置为 1)。 d - 代表删除。 object - 代表命令所要操作的对象 (下面有相关介绍)。 一个简短的对象列表∶ w - 从当前光标当前位置直到单字 / 单词末尾，包括空格。 e - 从当前光标当前位置直到单字 / 单词末尾，但是 不 包括空格。 $ - 从当前光标当前位置直到当前行末。特别提示∶ 对于勇于探索者，请在正常模式下面仅按代表相应对象的键而不使用命令，则 将看到光标的移动正如上面的对象列表所代表的一样。 123456789101112131415 第二讲第四节∶对象命令的特殊情况 ** 输入 dd 可以删除整一个当前行。 ** 鉴于整行删除的高频度，VIM 的设计者决定要简化整行删除，仅需要在同一行上 击打两次 d 就可以删除掉光标所在的整行了。 1. 请将光标移动到本节中下面的短句段落中的第二行。 2. 输入 dd 删除该行。 3. 然后移动到第四行。 4. 接着输入 2dd (还记得前面讲过的 number-command-object 吗？) 删除两行。 1) Roses are red, 2) Mud is fun, 3) Violets are blue, 4) I have a car, 5) Clocks tell time, 6) Sugar is sweet 7) And so are you. 第二讲第五节∶撤消类命令 输入 u 来撤消最后执行的命令，输入 U 来修正整行。 请将光标移动到本节中下面标记有 —&gt; 的那一行，并将其置于第一个错误处。 输入 x 删除第一个不想保留的字母。 然后输入 u 撤消最后执行的 (一次) 命令。 这次要使用 x 修正本行的所有错误。 现在输入一个大写的 U ，恢复到该行的原始状态。 接着多次输入 u 以撤消 U 以及更前的命令。 然后多次输入 CTRL-R (先按下 CTRL 键不放开，接着输入 R 键) ，这样就可以执行恢复命令，也就是撤消掉撤消命令。 1---&gt; Fiix the errors oon thhis line and reeplace them witth undo. 这些都是非常有用的命令。下面是第二讲的小结了。 1234567891011121314 第二讲小结 1. 欲从当前光标删除至单字 / 单词末尾，请输入∶dw 2. 欲从当前光标删除至当前行末尾，请输入∶d$ 3. 欲删除整行，请输入∶dd 4. 在正常模式下一个命令的格式是∶ [number] command object 或者 command [number] object 其意是∶ number - 代表的是命令执行的次数 command - 代表要做的事情，比如 d 代表删除 object - 代表要操作的对象，比如 w 代表单字 / 单词，$ 代表到行末等等。 $ (to the end of line), etc. 5. 欲撤消以前的操作，请输入∶u (小写的 u) 欲撤消在一行中所做的改动，请输入∶U (大写的 U) 欲撤消以前的撤消命令，恢复以前的操作结果，请输入∶CTRL-R 第三讲第一节∶置入类命令 ** 输入 p 将最后一次删除的内容置入光标之后 ** 请将光标移动到本节中下面示范段落的首行。 输入 dd 将该行删除，这样会将该行保存到 vim 的缓冲区中。 接着将光标移动到准备置入的位置的上方。记住∶是上方哦。 然后在正常模式下 ( 键进入)，输入 p 将该行粘贴置入。 重复步骤 2 至步骤 4，将所有的行依序放置到正确的位置上。d) Can you learn too? 123 b) Violets are blue, c) Intelligence is learned, a) Roses are red, 12345678910 第三讲第二节∶替换类命令 ** 输入 r 和一个字符替换光标所在位置的字符。** 1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。 2. 请移动光标到第一个错误的适当位置。 3. 接着输入 r ，这样就能将错误替换掉了。 4. 重复步骤 2 和步骤 3，直到第一行已经修改完毕。---&gt; Whan this lime was tuoed in, someone presswd some wrojg keys!---&gt; When this line was typed in, someone pressed some wrong keys! 5. 然后我们继续学校第三讲第三节。特别提示∶切记您要在使用中学习，而不是在记忆中学习。 第三讲第三节∶更改类命令 要改变一个单字 / 单词的部分或者全部，请输入 cw 请将光标移动到本节中下面标记有 —&gt; 的第一行。 接着把光标放在单词 lubw 的字母 u 的位置那里。 然后输入 cw 就可以修正该单词了 (在本例这里是输入 ine 。) 最后按 键，然后光标定位到下一个错误第一个准备更改的字母处。 重复步骤 3 和步骤 4，直到第一个句子完全雷同第二个句子。—&gt; This lubw has a few wptfd that mrrf changing usf the change command. —&gt; This line has a few words that need changing using the change command. 提示∶请注意 cw 命令不仅仅是替换了一个单词，也让您进入文本插入状态了。 12345678910 第三讲第四节∶使用 c 指令的其他更改类命令 ** 更改类指令可以使用同删除类命令所使用的对象参数。** 1. 更改类指令的工作方式跟删除类命令是一致的。操作格式是∶ [number] c object 或者 c [number] object 2. 对象参数也是一样的，比如 w 代表单字 / 单词，$ 代表行末等等。 3. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。 4. 接着将光标移动到第一个错误处。 5. 然后输入 c$ 使得该行剩下的部分更正得同第二行一样。最后按 &lt;ESC&gt; 键。---&gt; The end of this line needs some help to make it like the second.---&gt; The end of this line needs to be corrected using the c$ command. 第三讲小结 要重新置入已经删除的文本内容，请输入小写字母 p。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置 1 于当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 更改类命令允许您改变指定的对象，从当前光标所在位置直到对象的末尾。比如输入 cw 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当 1 前光标到行末的内容。 更改类命令的格式是∶[number] c object 或者 c [number] object下面我们继续学习下一讲。 1234567891011 第四讲第一节∶定位及文件状态 ** 输入 CTRL-g 显示当前编辑文件中当前光标所在行位置以及文件状态信息。 输入 SHIFT-G 则直接跳转到文件中的某一指定行。** 提示∶切记要先通读本节内容，之后才可以执行以下步骤!!! 1. 按下 CTRL 键不放开然后按 g 键。然后就会看到页面最底部出现一个状态信 息行，显示的内容是当前编辑的文件名和文件的总行数。请记住步骤 3 的行号。 2. 按下 SHIFT-G 键可以使得当前光标直接跳转到文件最后一行。 3. 输入您曾停留的行号，然后按下 SHIFT-G。这样就可以返回到您第一次按下 CTRL-g 时所在的行好了。注意∶输入行号时，行号是不会在屏幕上显示出来 的。 4. 如果愿意，您可以继续执行步骤 1 至步骤三。 第四讲第二节∶搜索类命令 输入 / 以及尾随的字符串可以用以在当前文件中查找该字符串。 在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底部，这跟 : 命令是一样的。 接着输入 errroor &lt;回车&gt;。那个 errroor 就是您要查找的字符串。 要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字符串，请输入 Shift-N 即可。 如果您想逆向查找字符串，请使用 ? 代替 / 进行。—&gt; When the search reaches the end of the file it will continue at the start.&quot;errroor&quot; is not the way to spell error; errroor is an error. 提示∶如果查找已经到达文件末尾，查找会自动从文件头部继续查找。 12345678 第四讲第三节∶配对括号的查找 ** 按 % 可以查找配对的括号 )、]、&#125;。** 1. 把光标放在本节下面标记有 --&gt; 那一行中的任何一个 (、[ 或 &#123; 处。 2. 接着按 % 字符。 3. 此时光标的位置应当是在配对的括号处。 4. 再次按 % 就可以跳回配对的第一个括号处。---&gt; This (is a test line with (&apos;s, [&apos;s] and &#123;&apos;s &#125; in it. ))提示∶在程序调试时，这个功能用来查找不配对的括号是很有用的。 第四讲第四节∶修正错误的方法之一 输入 :s/old/new/g 可以替换 old 为 new。 请将光标移动到本节中下面标记有 —&gt; 的那一行。 输入 :s/thee/the &lt;回车&gt; 。请注意该命令只改变光标所在行的第一个匹配串。 输入 :s/thee/the/g 则是替换全行的匹配串。—&gt; the best time to see thee flowers is in thee spring. 要替换两行之间出现的每个匹配串，请输入 :#,#s/old/new/g (#,# 代表的是两行的行号)。输入 :%s/old/new/g 则是替换整个文件中的每个匹配串。 123456789101112131415 第四讲小结 1. Ctrl-g 用于显示当前光标所在位置和文件状态信息。Shift-G 用于将光标跳 转至文件最后一行。先敲入一个行号然后按 Shift-G 则是将光标移动至该行 号代表的行。 2. 输入 / 然后紧随一个字符串是则是在当前所编辑的文档中向后查找该字符串。 输入问号 ? 然后紧随一个字符串是则是在当前所编辑的文档中向前查找该字 符串。完成一次查找之后按 n 键则是重复上一次的命令，可在同一方向上查 找下一个字符串所在；或者按 Shift-N 向相反方向查找下该字符串所在。 3. 如果光标当前位置是括号 (、)、[、]、&#123;、&#125;，按 % 可以将光标移动到配对的 括号上。 4. 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 选项，请输入 :%s/old/new/gc 第五讲第一节∶在 VIM 内执行外部命令的方法 输入 :! 然后紧随著输入一个外部命令可以执行该外部命令。 按下我们所熟悉的 : 命令设置光标到屏幕底部。这样就可以让您输入命令了。 接着输入感叹号 ! 这个字符，这样就允许您执行外部的 shell 命令了。 我们以 ls 命令为例。输入 !ls &lt;回车&gt; 。该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 ls 命令的结果一样。如果 !ls 没起 123 作用，您可以试试 :!dir 看看。---&gt; 提示∶ 所有的外部命令都可以以这种方式执行。---&gt; 提示∶ 所有的 : 命令都必须以 &lt;回车&gt; 告终。 1234567891011 第五讲第二节∶关于保存文件的更多信息 ** 要将对文件的改动保存到文件中，请输入 :w FILENAME 。** 1. 输入 :!dir 或者 :!ls 获知当前目录的内容。您应当已知道最后还得敲 &lt;回车&gt; 吧。 2. 选择一个尚未存在文件名，比如 TEST 。 3. 接着输入 :w TEST (此处 TEST 是您所选择的文件名。) 4. 该命令会以 TEST 为文件名保存整个文件 (VIM 教程)。为了确保正确保存， 请再次输入 :!dir 查看您的目录列表内容。---&gt; 请注意∶如果您退出 VIM 然后在以文件名 TEST 为参数进入，那么该文件内 容应该同您保存时的文件内容是完全一样的。 5. 现在您可以通过输入 :!rm TEST 来删除 TEST 文件了。 第五讲第三节∶一个具有选择性的保存命令 要保存文件的部分内容，请输入 :#,# w FILENAME 再来执行一次 :!dir 或者 :!ls 获知当前目录的内容，然后选择一个合适的不重名的文件名，比如 TEST 。 接着将光标移动至本页的最顶端，然后按 CTRL-g 找到该行的行号。别忘了行号哦。 接着把光标移动至本页的最底端，再按一次 CTRL-g 。也别忘了这个行好哦。 为了只保存文章的某个部分，请输入 :#,# w TEST 。这里的 #,# 就是上面要求您记住的行号 (顶端行号, 底端行号)，而 TEST 就是选定的文件名。 最后，用 :!dir 确认文件是否正确保存。但是这次先别删除掉。 123456789 第五讲第四节∶提取和合并文件 ** 要向当前文件中插入另外的文件的内容，请输入 :r FILENAME ** 1. 请键入 :!dir 确认您前面创建的 TEST 文件还在。 2. 然后将光标移动至当前页面的顶端。特别提示∶ 执行步骤 3 之后您将看到第五讲第三节，请届时再往下移动回到这里来。 3. 接着通过 :r TEST 将前面创建的名为 TEST 的文件提取进来。特别提示∶您所提取进来的文件将从光标所在位置处开始置入。 4. 为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份第 五讲第三节，一份是原本，另外一份是来自文件的副本。 第五讲小结 :!command 用于执行一个外部命令 command。请看一些实际例子∶ 12 :!dir - 用于显示当前目录的内容。 :!rm FILENAME - 用于删除名为 FILENAME 的文件。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 :#,#w FILENAME 可将当前编辑文件第 # 行至第 # 行的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 12345678910 第六讲第一节∶打开类命令 ** 输入 o 将在光标的下方打开新的一行并进入插入模式。** 1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。 2. 接着输入小写的 o 在光标 * 下方 * 打开新的一行并进入插入模式。 3. 然后复制标记有 ---&gt; 的行并按 &lt;ESC&gt; 键退出插入模式而进入正常模式。---&gt; After typing o the cursor is placed on the open line in Insert mode. 4. 为了在光标 * 上方 * 打开新的一行，只需要输入大写的 O 而不是小写的 o 就可以了。请在下行测试一下吧。当光标处在在该行上时，按 Shift-O 可以 在该行上方新开一行。Open up a line above this by typing Shift-O while the cursor is on this line. 第六讲第二节∶光标后插入类命令 输入 a 将可在光标之后插入文本。 请在正常模式下通过输入 $ 将光标移动到本节中下面标记有 —&gt; 的第一行的末尾。 接着输入小写的 a 则可在光标之后插入文本了。大写的 A 则可以直接在行末插入文本。 123提示∶输入大写 A 的操作方法可以在行末插入文本，避免了输入 i，光标定位到 最后一个字符，输入的文本，&lt;ESC&gt; 回复正常模式，箭头右键移动光标以及 x 删除当前光标所在位置字符等等诸多繁杂的操作。 操作之后第一行就可以补充完整了。请注意光标后插入文本与插入模式是基本完全一致的，只是文本插入的位置定位稍有不同罢了。 12---&gt; This line will allow you to practice---&gt; This line will allow you to practice appending text to the end of a line. 1234567891011 第六讲第三节∶另外一个置换类命令的版本 ** 输入大写的 R 可连续替换多个字符。** 1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。 2. 移动光标到第一行中不同于标有 ---&gt; 的第二行的第一个单词的开始，即单 词 last 处。 3. 然后输入大写的 R 开始把第一行中的不同于第二行的剩余字符逐一输入，就 可以全部替换掉原有的字符而使得第一行完全雷同第二行了。---&gt; To make the first line the same as the last on this page use the keys.---&gt; To make the first line the same as the second, type R and the new text. 4. 请注意∶如果您按 &lt;ESC&gt; 退出置换模式回复正常模式，尚未替换的文本将仍 然保持原状。 第六讲第四节∶设置类命令的选项 ** 设置可使查找或者替换可忽略大小写的选项 ** 要查找单词 ignore 可在正常模式下输入 /ignore 。要重复查找该词，可以重复按 n 键。 然后设置 ic 选项 (ic 就是英文忽略大小写 Ignore Case 的首字母缩写词)，即输入∶ 1 :set ic 现在可以通过键入 n 键再次查找单词 ignore。重复查找可以重复键入 n 键。 然后设置 hlsearch 和 incsearch 这两个选项，输入以下内容∶:set hls is 现在可以再次输入查找命令，看看会有什么效果∶/ignore 12345678910 第六讲小结 1. 输入小写的 o 可以在光标下方打开新的一行并将光标置于新开的行首，进入 插入模式。 输入大写的 O 可以在光标上方打开新的一行并将光标置于新开的行首，进入 插入模式。 2. 输入小写的 a 可以在光标所在位置之后插入文本。 输入大写的 A 可以在光标所在行的行末之后插入文本。 3. 输入大写的 R 将进入替换模式，直至按 &lt;ESC&gt; 键退出替换模式而进入正常 模式。 4. 输入 :set xxx 可以设置 xxx 选项。 第七讲∶在线帮助命令 ** 使用在线帮助系统 ** Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方 法之一∶ 按下 键 (如果键盘上有的话) 按下 键 (如果键盘上有的话) 输入 :help &lt;回车&gt;输入 :q &lt;回车&gt; 可以关闭帮助窗口。 提供一个正确的参数给 “:help” 命令，您可以找到关于该主题的帮助。请试验以 下参数 (可别忘了按回车键哦。:)∶ :help w &lt;回车&gt; :help c_&lt;T &lt; 回车&gt; :help insert-index &lt;回车&gt; :help user-manual &lt;回车&gt; 12345678910111213 第八讲∶创建一个启动脚本 ** 启用 vim 的功能 ** Vim 的功能特性要比 vi 多得多，但大部分功能都没有缺省激活。为了启动更多的 功能，您得创建一个 vimrc 文件。 1. 开始编辑 vimrc 文件，这取决于您所使用的操作系统∶ :edit ~/.vimrc 这是 Unix 系统所使用的命令 :edit $VIM/_vimrc 这是 Windows 系统所使用的命令 2. 接着导入 vimrc 范例文件∶ :read $VIMRUNTIME/vimrc_example.vim 3. 保存文件，命令为∶ :write 在下次您启动 vim 的时候，编辑器就会有了语法高亮的功能。您可以继续把您喜 欢的其它功能设置添加到这个 vimrc 文件中。 vim 教程到此结束。本教程只是为了简明地介绍一下 vim 编辑器，但已足以让您 很容易学会使用本编辑器了。全文完本文由 简悦 SimpRead 优化，用以提升阅读体验。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Vim 使用手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序 排序的概念 常见的排序种类 1.插入排序 直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。 2.希尔排序]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的开发工具]]></title>
    <url>%2F2019%2F04%2F29%2FLinux%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Linux 下的开发工具 vs是一个IDE(集成开发环境) 1.代码编辑器 2.编译器 3.调试器 4.工程管理工具 5其他 …. Java Eclipse ===&gt;也可以开发C++ IDEA ====&gt;也可开发c++ JetBrains(全家桶) CLion(C++) PHP(PHPStorm) PyCharm(Python) JavaScript(WebStorm) Go(GoLand) 开发工具1.代码编辑：vim 2.编译：gcc 3.调试：gdb 4.工程管理:makefile 包管理器 ： yum(命令行版的应用商店)对应的服务器叫做软件源 yum的所有操作都要在网络畅通的情况下使用 yum的局限性: 只能安装一些比较知名的软件(也可以直接以源代码的方式进行安装) 1yun list | grep tree “ | “ 左边的输出内容做为右边的输入 “ |” 叫做管道,能够链接两条指令 通过 “|” 将左边的指令执行结果进行过滤 yum 的基本用法 1.yum list //查找需要的软件(一般不按回车,服务器上的软件过多会导致电脑卡死) 2.yum install 安装(必须有管理员权限) 3.yum remove (卸载软件) 除了yum安装之外，还可以使用源代码直接编译的方式安装(极其复杂，非专业人士不要尝试) su 能够切到管理员用户 退出管理员:exit 或者 Ctrl + d sudo 不切换用户，但是要使用管理员权限运行程序 vim编辑器(神之编辑器)史上最牛逼的文本编辑器之一 并肩的存在:Emacs(编辑器之神)—-&gt;依赖的编程语言Lisp(与c语言齐名) Vim的强大之处 支持非常丰富的快捷键(操作效率非常高，学习成本比较高)演化成了一种思想。 支持非常强大的扩展能力(插件机制)。背后依赖着一个编程语言(VimL) Vim 的竞争对手 notepad++ / notepadplus /utrla edit /source insight Vim 基于模式的方式完成编辑 Vim 刚刚启动的时候是普通模式(vimtutor)，普通模式下不能直接输入内容。此时敲下的按键多半是带有特殊功能的快捷键，需要进入插入模式才能进行编辑 1.”：w “ 进行保存 2.”：q” 进行退出 3.普通模式下按 “:” 进入底行模式 vim[文件] 打开一个文件，不存在就会创建新文件 vim是一个多模式的文本编辑器 能够与Vim并肩的编辑器Sublimme Text(史上最性感的编辑器) 1.界面好看 2.支持vim风格的快捷键 Atom(Github官方编辑器 ) 1.界面好看 2.支持Vim风格的快捷键 3.支持非常强大的扩展(安装插件非常方便) 4.致命缺陷：启动非常慢 neovim 真正有望取代Vim的软件 VScode(MS) —-》依赖图形界面 1.界面好看 2.支持Vim 的扩展功能(安装插件极其方便) 3.启动速度很快 vim 打开的同是会产生一个 . swap文件gcc 预处理： 头文件替换，宏展开，去掉注释，条件编译，其他预处理指令 编译：源代码文件转换成汇编代码 汇编：汇编代码转换成二进制文件 链接：把所有的二进制文件和依赖的库合到一块，得到可执行程序 gcc test.c -o test //生成一个叫 test 的可执行文件 ，默认生成的是 a.out gcc -E //只进行预处理,不生成文件，你需要把他重定向到一个输出文件里面 gcc -E test.c -o test.i //对test.c进行预处理 vim test.i //查看预处理后的结果 gcc -S test.i - 0 test.s //进行编译得到汇编代码 -g 选项 编译的时候保留调试信息 gcc 下的选项 -E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面-S 编译到汇编语言不进行汇编和链接-c 编译到目标代码-o 文件输出到 文件-static 此选项对生成的文件采用静态链接-g 生成调试信息。GNU 调试器可利用该信息。-shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.-O0-O1-O2-O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高-w 不生成任何警告信息。-Wall 生成所有警告信息 优化级别越高程序的实际执行顺序就和原来的执行顺序差别越大必须 要关闭优化才能进行调试 一般调试的时候用 -O0 gbd ： Linux下的命令行调试工具Linux下调试的背景 程序的发布方式有两种，debug模式和release模式 Linux gcc/g++出来的二进制程序，默认是release模式 要使用gdb调试，必须在源代码生成二进制程序的时候, 加上 -g 选项［重要］ 使用场景 break n //在第n 行打断点，参数可以是一个行号，也可以是函数名 run/r : 开始执行 next/n :单步执行(逐过程) stp/s :单步执行(逐语句) bt : 调用函数栈帧 Ctrl + r :快速搜索 frame/f : 切换到某个指定栈帧 gdb的使用场景 1.使用gdb调试coredump(核心转储文件)文件(coredump是程序的临终遗言，最后的 运行状况) ​ 程序奔溃：可以利用空指针的方式 ​ 事后调试: 2.使用gdb attach(附加) 上一个程序。 ​ TODO(进程相关的内容) cgdb：更方便一点 调试一个问题的步骤和思路 1.确认是不是bug：唯一依据就是产品需求 2.确认有bug后，开始定位bug ：找到是那行代码引起的bug 3.分析问题的原因(幸福感). 4.提出方案并修改问题 5.测试(回归测试,防止代码的修改引入新的问题).由于回归测试 ，成本比较高 往往以自动化测试为主。 vs 中 调试的操作 1.打断点 2. 工程管理工具(c++,java中存在)解决大型项目中的模块之间的依赖问题 工具名称：makefile(40年前的技术) 当前的现代c/c++工程管理工具本质都是通过自动化 的方式生成makefile 1.先在当前目录中查找Makefile/Makefile 文件 2.找到要生成的目标(决定是否要真的生成) 3.检查以来的文件是否存在 4.执行生成动作的命令 增量编译 vim 的配置码云 Vimforcpp 按下Esc进入普通模式，按空格进人编辑器功能 选择模式 退出选择模式的方法 按下空格键然后按下 f 和a 其他的vim配置 spacevim 一套比较知名的配置(对于新手特别不友好) vimplus 稍微旧一点的，有些功能不是很科学 vimforcpp ：为比特同学量身定做 vimtutor下几种模式间的相互转换 《龙书》，《虎书》，《鲸书》]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux的开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统编程]]></title>
    <url>%2F2019%2F04%2F29%2F%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Linux进程的概念1.冯诺依曼体系 2. 操作系统 3.进程 3.1 主要：僵尸进程 系统编程冯诺依曼体系1.图示 2.计算机的组成分类 1.输入单元：包括键盘、鼠标、卡片阅读器、扫描仪、手写板、触摸屏等 中央处理器(CPU):含有算术逻辑、控制、记忆等单元 输出设备:例如屏幕、打印机等 CPU: 也可以通过”寄存器“存储少量的数据，寄存器的访问速度特别快 门电路: 与门 遇0则0 或 遇1则1 非 改变状态 异或门 相同为0，相异为1 储存设备: 内存: 空间比较小，访问速度快，成本较高，断电之后数据丢失 外存：空间较大。访问速度慢成本较低，断电之后数据依然存在 强调的点 这里的存储器指的是内存不考虑缓存情况，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)外设(输入或输出设备)要输入或者输出数据，也只能写入内存或者从内存中读取。一句话，所有设备都只能直接和内存打交道。 操作系统(搞管理的软件) 管理硬件设备 管理软件资源 概念 内核（进程管理，内存管理、文件管理、驱动管理） 其他程序(例如函数库，shell程序等等) 设计操作系统的目的 与硬件交互，管理所有的软硬件资源 为用户程序(应用程序)提供一个良好的执行环境 总结计算机管理硬件 1.描述起来 :用struct结构体 2.组织起来: 用链表或者其他高效的数据结构 进程查看 ps 相当于任务管理去器，能够查看系统都有哪些进程 ps aux 查看所有进程 ps aux | less 配合less 对查看结果进行翻页和其他操作 ps aux | grep [进程名] 查看匹配的结果 Ctrl + z 将一个程序放到后台，但是不退出程序 按下 fg 将后台的程序调到前台继续执行 Ctrl + c 关闭一个正在执行的进程 敲下的命令，在命令执行的过程中也是一个进程 进程的管理1.描述进程(PCB进程控制块 –&gt; 就是一个结构(task_struct))PCB：针对通常情况 task_struct：只针对Linux ​ task_struct 是一个很大的结构体，包含很多的内容 ​ a.进程标识符(pid) ​ b.内存指针(告诉 进程代码/数据都存在内存的那个部分) ​ c.进程状态 ​ d.优先级:数字，表示这个进程是先被调度还是后被调度执行 ​ PR: 数字越小，优先级别越高 ​ NI(nice): 优先级的修正值，PR+NI =&gt; 最终的PR 通过指令可以调整nice，宏观上往往看不出效果 e:上下文(寄存器) cpu 可能又几十个寄存器， ​ 作用：保存上下文，cpu寄存器的内容保存到内存中 ​ 恢复向下文，内存中的寄存器值恢复到cpu中 f:记账信息;每个进程已经在CPU上执行多久统计数据 进程的状态 R 就绪状态，进程在就绪队列中，就会处于这个状态 S 睡眠状态，单身状态，暂时还轮不到他 D 深度睡眠状态，密集地进行IO操作的时候(吐coredump) T 暂停stop t 跟踪trace X 进程已经结束，只是在Linux 源代码中存在，真实是看不到的 Z 僵尸进程 和父进程子进程这些有关联 父进程(ppid)与子进程(pid)使用代码来创建子进程 fork () fork有两个返回值父子进程代码共享，数据各自开辟空间，私有一份（采用写时拷贝） 1234567891011#include&lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include&lt;unistd.h&gt; int main()&#123; fork(); //gitpid 获取进程的进程 //gitppid 获取夫进程 printf("%d %d\n",getpid(),getppid()); sleep(1); return 0; &#125; fork 之后通常要用 if 进行分流 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123; int ret = fork(); if(ret &lt; 0)&#123; perror("fork"); return 1; &#125; else if(ret == 0)&#123; //child printf("I am child : %d!, ret: %d\n", getpid(), ret); &#125;else&#123; //father printf("I am father : %d!, ret: %d\n", getpid(), ret); &#125; sleep(1); return 0;&#125; fork ()1.返回值：一次调用两个返回值 父进程返回子进程的pid ​ 子进程返回 0 ​ 通常需要让父子进程执行不同的逻辑，就可以借助fork的返回值来进行区分 如果失败 返回&lt; 0 的结果(可能原因) a. 内存不够 b. 进程太多达到上限 ​ RLIMIT_NPROC 2. 执行过程 父子进程都是紧接着fork继续执行 3. 先后顺序 不确定，取决于操作系统的调度器 进程的调度让少量的CPU能够满足大量的进程同时执行的需求 并行：两个CPU分别执行两个进程 并发:一个CPU”同时”执行两个进程，切换执行，并非同时进行 僵尸进程成因:子进程结束之后，父进程没有回收子进程的资源，为了解决子进程向父进程汇报工作的问题 危害：处理不当会造成内存泄漏 处理：直kill 僵尸进程是kill 不掉的，可以kill 僵尸进程的父进程。更科学的处理办法是: 进程等待 为什么 kill 父进程僵尸进程没了？ 当kill 掉父进程之后，子进程就被称为孤儿进程，孤儿进程会被 1 号进程(init进程)收养，从而释放资源 init进程：开机时运行的第一个进程 2.组织进程 双向链表进行组织，每个结点就是一个task_ struct(只针对Linux) 除了ps 之外top也可以查看进程的状态 PR:数字越小，优先级别越高 NI(nice):优先级的修正值，PR+NI =&gt; 最终的PR 通过指令可以调整nice，宏观上往往看不出效果 环境变量概念 环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些参数 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。 环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性 常见环境变量PATH : 指定命令的搜索路径HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)SHELL : 当前Shell,它的值通常是/bin/bash。 查看环境变量的命令echo $NAME //NAME:你的环境变量名称 例如: echo $PATH 或者echo $HOME 键值对(key_value)环境变量是一个键值对结构 键：变量名 值：变量内容 和环境变量相关的命令 echo: 显示某个环境变量值［重点］ export: 设置一个新的环境变量［重点］ env: 显示所有环境变量［重点］ unset: 清除环境变量 set: 显示本地定义的shell变量和环境变量 Linux 上查看键值对命令:env env : 查看系统上所有的环境变量 echo $ (环境变量名) 查看某个环境变量 export 修改环境变量，对于PATH 修改一般只是进行追加，不会把原来内容(路径)去掉 可以通过重启终端来恢复PATH PATH：shell中敲下的指令，去哪些目录中查找对应的可执行程序 修改这个文件 ~ /. bashrc 能够让环境变量持久生效 mian函数的参数1234int main(int argc /*命令行参数个数*/ ,char* argv[]/*命令行参数命令*/ )//没参数//int argc,char* argv[] //int argc,char* argv[],char* env[] （env 数组的结束标志 NULL） 程序地址空间栈 保存局部变量 在(centors 上大小约为8M) 栈的大小可以配置(要看平台) 如果是小对象，并且需要频繁创建和销毁，推荐在栈上分配栈上空间内存更高效 堆 动态申请的空间 如果是大对象，必须在堆上分配 malloc/new 申请空间 数据段 全局变量/静态变量 代码段 存放二进制代码/字符串的字面常量 内存池 需要比较大的内存又需要频繁的申请和释放的就用内存池比较好]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础]]></title>
    <url>%2F2019%2F04%2F23%2FLinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一：Linux 的基本指令 1.Linux 的基本指令和开发环境(操作方式：命令行操作) 2.Linux 系统编程 3. Linux网络编程 Linux 的简介 Linux是 一个 操作系统内核(操作系统=内核+一组配套的应用程序) 内核来负责对于软件资源和硬件设备的管理 我们使用的是Centos 操作系统(内核为Linux) Android (内核也为LInux),Ubuntu Redhat (大部分公司中使用的发行版) 搭建Linux环境需要拷贝那些内容 1.安装 Vmware ​ Linux 可以直接安装到物理电脑上,操作起来不方便 2.拷贝Centos 镜像 3.安装 Xshell (远程终端工具,依赖网络登陆) 远程终端工具。 Unix 高级环境编程 ， Unix 网络编程 学习Linux 的原因全世界市场份额最高的操作系统，任何一个程序猿都会用的操作系统 1.移动端领域(安卓) 2.服务器领域(90% 的服务器使用Linux)3 3.嵌入式领域 4.桌面领域(Linux 在桌面领域表现不佳) 怎么学Linux 敲代码 Linux难度远高于c/c++、数据结构 花时间 = 理论(理论+读书海报的管家年书籍) + 自己总结博客 + 多看其他相关资料 )+ 实践(多敲相关代码) Linux 基本操作123456ls(list):相当于windows上的文件资源管理器ls / ls / xxx （进入根目录下的 xxx 目录）ls -l &lt;==&gt; ll (一种更详细的显示文件信息)Tab 键快速完成补全，快速按两下Tab显示改目录下所有可能的情况 在Linux终端和 shell中复制与粘贴不能用 Ctrl +c y与 Ctrl+v 要用Ctrl+Insert 和Shift +Insert 来完成复制与粘贴 ls / 进入当前机器的根目录(/: 根目录) ll 的结果的第一个字母为 - 表示不同文件，为 d 表示为目录 1ifconfig 命令用途： 查看Linux机器 的 IP 地址 1clear/Ctrl + l 命令作用：清屏 1pwd 查看当前目录的路径 /home/jack 是一登陆主机就进入的默认目录，这个目录就叫做jack用户的home 目录 “~” 表示home目录 1cd (change ) 修改当前目录 绝对路径： /home/jack 以/开头的 相对路径： 从当前目录出发经历若干个结点到达最终目录 以. /..开头 其中 “ . “ 表示当前目录 “..” 表示当前目录的上级目录 cd 总结 cd .. : 返回上级目录 cd /home/litao/linux/ : 绝对路径 cd ../day02/ : 相对路径 cd ~：进入用户家目录(cd 啥都不加也是同样的效果) cd -：返回最近访问目录(完成两个目录之间的快速来回切换) cd .. /x ：返回 上级目录并且进入到与当前目录同级的x 目录下 1Ctrl+c 命令用途： 有特的功能，终止当前程序，或者重新输入一个命令 1touch 命令用途： 创建一个新的文件 1echo 命令用途： 写文件 echo总结 echo “hello” //显示到屏幕上，输出一个字符串 echo “hello” &gt; a.txt 把字符串写道文件中 向文件 a.txt中写入内容 “hello” 1cat 命令用途： 查看文件内容 1mkdir 命令用途：创建目录 rm 的相关操作命令1rm bd.txt 删出 bd.txt 文件 1rm -r bd 删除 bd 目录（递归删除） 1rm -r -i bd 不仅递归删除而且提示你是否要删除文件/目录(先删除目录中的文件，在删除指定的目录) 1rm -rf bd 彻底删除 1su 切换到 root 用户(管理员用户) 1yum install XXXX 安装一个XXX程序 1ping 检查网络的联通状态 git 1.代码被喵星人吃掉的问题 2.产品经理被程序猿打死的问题 3.程序猿之间的互殴问题 mv的使用1mv(move) 移动文件/目录，也能重命名 1move 1.txt b 移动1.txt 文件 到 b 目录 1mv a/2.txt c 将a 目录下的 2.txt 文件移动到 c目录中 (此时用户在a,c目录的上级目录中) cp的用法1cp 拷贝文件/目录 1cp -r 拷贝目录(递归式的拷贝) 1cp xxx ../ x 将当前目录下的xxx文件复制到与当前目录同级的x目录下 man的用法man：能够查看命令的使用方法， 可以使用 k/向上键 向上翻屏 使用 j/向下键 向下翻屏 按 q 退出man less命令 使用less可以打开一个比较大的文件 less可以打开大文件效率很高，尤其是几个G大小的文件 less在打开文件的时候，只把一小部分数据加载到内存中二大部分其他的编辑器都是直接吧整个文件都加载,而大部分其他的编辑器都是直接把整个文件都加载(延时加载/懒加载) head用途：查看文件的前几行 1head -n 10 yum.conf #只看yum.conf文档的前10行 查看文档的前几行 tail的用途1tail -n 10 yum.conf #只看yum.conf文档的后10行 命令用途：只看yum.conf文档的后10行 date:获取当前时间 1.获取到任意格式化的时间。 2.格式化时间和时间戳的换算。 srand() 设置随机种子 使用格式: rand() date +%s 获取到当前时间戳 date -d@[时间戳] 将时间戳转换成当前时间 时间戳:当前时间与1970年1月1号0时0分0秒时刻的秒数差 1date +&quot;%Y-%m-%d %H:%M:%S&quot; 获取当前的时间 与操作系统无关的数据类型写法 头文件 ： #include&lt;stdint.h&gt; int8_t int16_t int32_t int 64_t 这种类型的数字在任何平台下它的大小是固定的 开始时间是 b 计算一段程序运算时间 结束时间是 a a - b&lt; 0 时 时间在出现闰秒的情况下可能为负，所以记录时间要用有符号数 Cal 指令 日历的调用 find -name (按照文件名字查找文件 ) “*” 表示通配符，代表着任意多个字符， 大部分Linux 命令都支持统配符 压缩/解压缩1zip 1.txt.zip 将1.txt文件压缩生成1.txt.zip 压缩包 zip a.zip a/* -r 将a 目录递归压缩 1unzip 1.txt.zip 将 1.txt.zip 解压 shell（普通的应用程序） shell 可以理解为用户和操作系统之间的桥梁 1bash shell 是一个统称，当前系统上默认的shell 程序叫做 bash bash这样的程序是使用最广泛的Linux Shell 程序 权限 读： r 写： w 执行： x (./xxx) 任何一个文件具体的权限，针对不同的用户是不一样的。 第一组rwx 表示的是文件的拥有者的权限 第二组rwx 表示的是和文件拥有者同组的用户的权限 第三组rwx 表示的是其他用户的权限 d：文件夹-：普通文件l：软链接（类似Windows的快捷方式）b：块设备文件（例如硬盘、光驱等）p：管道文件c：字符设备文件（例如屏幕等串口设备）s：套接口文件 在Linux中其实还有一个特殊的用户，凌驾于权限体系之上的–&gt;root chmod 指令1chmod chmode -r xxx 去掉xxx文件的读权限 chmod +r xxxx 增加xxx文件的读权限 chmod u-r xxx 只处理文件拥有着的写权限 chmod u+r xxx 只处理文件拥有者的写权限 chmod g-r 操作同组用户的权限 chmod o-r 操作其他用户的权限 chmod [三位八进制的数字] 修改文件权限 chmod [9位二进制的数字] 修改文件权限 ​ 二进制的 000 110 100 ​ 八进制的 0 6 4 所谓的执行权限是一个程序能执行的必要条件，但不是充要条件 文件必须要满足系统可执行的格式要求文件才能够执行 123rm -rf a/ //删除a 目录rm -rf a / //删除a文件 并且删除了根目录 whereis1whereis xxx 能够找到某个指令xxx对应的可执行程序路径 1sz 把linux 上的文件发送到 Windows上 Windows上的文件弄到Linux 上只需要拖拽到Linux上即可(Xshell上的功能） 不同平台上的可执行程序它们的格式都是不一样的，不可以混着执行 对于普通文件 1.读意味着能够查看文件的内容 2.写意味着能够修改文件内容 3.执行意味着能够运行程序 对于目录文件来说 1.读意味着能够查看目录中包含了那些文件和目录 2.写意味着能够修改目录中包含的内容(新增/删除文件)(-w 就不能在目录中创建文件或者目录) 3.执行意味着能够进入到目录中(cd)(- x 就不能进入到目录中) 只要用户拥有了目录的写权限，不管用户能否具有文件的读写权限，都能删除文件 粘滞位 ： chmod +t]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基本指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下.c文件与.cpp文件的编辑和运行命令]]></title>
    <url>%2F2019%2F04%2F22%2FLinux%E4%B8%8B-c%E6%96%87%E4%BB%B6%E4%B8%8E-cpp%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%BE%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux平台下.c文件的编辑和运行命令 在 Linux 平台下我是用vim文本编辑器编写代码的 一：在Linux环境下编辑、编译并执行一个 xxx.c 文件步骤 1.首先要创建一个test.c文件 输入命令: touch test.c 2. 开始写代码 输入命令 : vim test.c (前提是你已经安装了vim文本编辑器) 进入编辑器后：按 英文字母”i”进入编辑模式 3. 退出文本文档 按一下Esc ，然后按出”:”冒号 接着输入对应字母 输入字母 q 表示退出(既不保存你输入的代码直接退出) 输入字母 w 和字母 q 表示保存并且退出 4. 编译代码 输入命令: gcc test.c 完成对test.c 文件的编译工作 5. 执行代码 输入命令： ./a.out test.c 即可执行你所写的test.c 文件，并输出对应结果 二：在 Linux 环境下编辑、编译并执行一个 xxx.cpp 文件步骤 1..首先要创建一个test.cpp文件 输入命令: touch test.cpp 2. 开始写代码 输入命令 : vim test.cpp (前提是你已经安装了vim文本编辑器) 进入编辑器后：输入英文字母”i”进入编辑模式 3. 退出文本文档 按一下Esc ，然后按出”:”冒号 接着输入对应字母 输入字母 q 表示退出(既不保存你输入的代码直接退出) 输入字母 w 和字母 q 表示保存并且退出 4. 编译代码 输入命令: g++ test.cpp 完成对 test.cpp 文件的编译工作 5. 执行代码 输入命令： ./a.out test.cpp 即可执行你所写的test.cpp 文件，并输出对应结果]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux下.c文件与.cpp文件的编辑和运行命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态 一：多态的简介1.多态的概念复习 多态：不同对象 执行同一种行为的多种表现形态(或者执行同一种行为产生的不同结果) 0.前提是继承 1.调用函数的对象必须是引用或指针 2.被调用的函数必须为虚函数，且在子类当中被重写 非多态看类型： 多态看对象： 函数重写： 函数分别存在于子类和父类，函数名，参数，返回值都相同(可以是协变) 协变： 返回值的类型可以是构造父子关系的指针或者引用 非多态 汇编代码： 语句简单 多态 如何实现多态 多态的对象模型：只要类中有虚函数，对象 模型中就存放了一个虚标指针，虚表指针指向虚表，虚表本质上为函数指针数组，虚表在vs下存在代码段、 1.本质上是通过虚表实现：程序在运行的 时候，根据引用或者指针指向的对象，访问对象模型中虚表指针，获取虚表中对应位置的函数指针，]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承 1. 对继承的理解a.继承的理解： class(类)级别的代码复用 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;class Person&#123;public: void Print() &#123; cout &lt;&lt; "name:" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; "age:" &lt;&lt; _age &lt;&lt; endl; &#125;protected: string _name = "peter"; // 姓名 int _age = 18; // 年龄&#125;; class Student : public Person //继承了Person 的内容&#123;protected: int _stuid= 4170903; // 学号&#125;;class Teacher : public Person&#123;protected: int _jobid=147632; // 工号&#125;;int main()&#123; Person p; Student s; Teacher t; system("pause"); return 0;&#125; 监视结果 由上图可以看到Student和Teacher类中多出了自己内部并没有定义过的Person类中的内容。他们从Person类中 继承 了Person类中的内容。 继承的图例说明 注意：Student类中此时只有name,age__stuid三个变量，并没有Person这个内部类，Teacher类中也没有Person这个类 运行结果 继承的格式 b.继承关系和访问权限 1.继承方式和基类中的访问方式结合起来就有9种子类的访问方式，在子类中的访问方式取两者中权限最小的。 2.不管在子类中是如何继承的基类中的私有成员在子类中都是不可见的,但是它确实存在与子类中。 3.基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。 5.基类中的保护类型在子类中可以被访问，但是在子类之外定义的变量不可以访问。 6.使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过最好显示的写出继承方式 7.基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它 protected:在类外无法访问，但是在子类内部可以访问 private：在类外和子类中都无法访问 public继承：不改变基类成员在子类中的访问权限 protected继承：基类成员在子类中的最低访问权限为protected的 private继承：基类成员在子类中的最低访问权限为private的 2.基类和派生类对象赋值转换切片操作图示 切片理解 1.派生类对象可以赋值给基类的对象 / 基类的指针 / 基类的引用。这里有个形象的说法叫切片或者切割。寓意把派生类的内容中将父类中的那部分切下来赋值给父类。 2.父类对象不能赋值给子类对象 父类指针只能看到和自己类型大小的空间,所以不能赋给子类指针char :一个字节int : 四个字节子类对象的地址可以赋给父类的指针(父类指针可以在子类对象所占空间大小中只访问自己能访问到的大小)指针类型决定访问的空间大小 子类可以赋值给父类引用：引用的底层就是指针父类的指针不能赋给子类指针：可能会存在访问越界的风险(若子类中没有定义新的成员，则基类于与子类的大小相同就不存在访问越界的情况) 需要做强制类型转换：Student ptr =(Studennt ) &p; 强转存在风险:若子类中定义了新的变量，强转父类指针类型就存在访问越界的风险。 int a=10;float b=1.5;隐式类型转换：类型相似的变量可以进行相互赋值，通过隐式类型转换。 3.继承中的作用域 在继承体系中基类和派生类都有独立的作用域。 子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显示访问） 需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。 注意在实际中在继承体系里面最好不要定义同名的成员 类的成员变量的隐藏 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;class Person&#123;protected: string _name = "小李子"; // 姓名 int _num = 111; // 身份证号&#125;;class Student : public Person&#123;public: void Print() &#123; cout &lt;&lt; " 姓名:" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; " 身份证号:" &lt;&lt; Person::_num &lt;&lt; endl; cout &lt;&lt; " 学号:" &lt;&lt; _num &lt;&lt; endl; &#125;protected: int _num = 999; // 学号&#125;;void Test()&#123; Student s1; s1.Print();&#125;; int main()&#123; Test(); system("pause"); return 0;&#125;//当定义类只尽量将变量名取的不一样//子类与父类中定义的变量名相同时，子类变量会将父类变量隐藏 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;class Person&#123;public: string _name = "小李子"; // 姓名 int _num = 111; // 身份证号&#125;;class Student : public Person&#123;public: void Print() &#123; cout &lt;&lt; " 姓名:" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; " 身份证号:" &lt;&lt; Person::_num &lt;&lt; endl; cout &lt;&lt; " 学号:" &lt;&lt; _num &lt;&lt; endl; &#125;public: int _num = 999; // 学号&#125;;void Test()&#123; Student s1; s1.Print();&#125;;int main()&#123; Person p; Student s; cout &lt;&lt; s._num &lt;&lt; endl; cout &lt;&lt; s.Person::_num &lt;&lt; endl; //可以通过这种方法访问父类中的对象 cout &lt;&lt; p._num &lt;&lt; endl; cout &lt;&lt; s.Student::_num &lt;&lt; endl; system("pause"); return 0;&#125; 类中函数的同名隐藏 条件：子类中的函数与父类中的函数名字相同 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;//函数的隐藏using namespace std;class A&#123;public: void fun() &#123; cout &lt;&lt; "func()" &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void fun(int i) &#123; A::fun();//指明调用 cout &lt;&lt; "func(int i)-&gt;" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;void Test()&#123; B b; b.fun(10);&#125;int main()&#123; Test(); system("pause"); return 0;&#125;//重载：函数在同以作用域，函数名相同，参数不同//重定义：重定义/隐藏：子类函数和父类函数名相同就会构成隐藏//子类会把父类同名的函数隐藏掉 4.派生类的默认成员函数 6个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类中，这几个成员函数是如何生成的呢？ a.派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。 b.派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化 c.派生类的operator=必须要调用基类的operator=完成基类的复制。 d.派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。 e.派生类对象初始化先调用基类构造再调派生类构造。 f.派生类对象析构清理先调用派生类析构再调基类的析构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;class Person&#123;public: Person(const char* name = "peter") : _name(name) &#123; cout &lt;&lt; "Person()" &lt;&lt; endl; &#125; Person(const Person&amp; p) : _name(p._name) &#123; cout &lt;&lt; "Person(const Person&amp; p)" &lt;&lt; endl; &#125; Person&amp; operator=(const Person&amp; p) &#123; cout &lt;&lt; "Person operator=(const Person&amp; p)" &lt;&lt; endl; if (this != &amp;p) _name = p._name; return *this; &#125; ~Person() &#123; cout &lt;&lt; "~Person()" &lt;&lt; endl; &#125;protected: string _name; // 姓名&#125;;class Student : public Person&#123;public: //完成父类对象的初始化，子类的构造函数先调用基类的构造函数， //再执行子类的构造函数 //必须先调用父类的构造函数和拷贝构造进行初始化 Student(const char* name, int num) : Person(name) , _num(num) &#123; cout &lt;&lt; "Student()" &lt;&lt; endl; &#125; //如果子类不显示的调用父类的拷贝构造，则调用父类的默认构造函数 //如果子类显示的调用父类类的拷贝构造，就不会再去调用父类的默认构造 Student(const Student&amp; s) //(Student *this,const Student &amp;s)还发生了指针的欺骗。 : Person(s)//此处是一个切片的操作，调用父类的拷贝构造 , _num(s._num) &#123; cout &lt;&lt; "Student(const Student&amp; s)" &lt;&lt; endl; &#125; //父类的成员变量可以直接在子类的赋值运算符重载函数长中直接赋值 //如果是编译器默认生成的子类赋值运算符重载函数，会调用父类的 //赋值运算符重载函数进行赋值 Student&amp; operator = (const Student&amp; s) &#123; cout &lt;&lt; "Student&amp; operator= (const Student&amp; s)" &lt;&lt; endl; if (this != &amp;s) &#123; //建议直接显示调用父类的赋值运算符重载函数，代码复用 //operator =(s);不可以这样写 Person::operator =(s);//此处调用的this指针为子类对象的this指针 _num = s._num; &#125; return *this; //若if中没有显示的写出父类的赋值运算符重载的话， //子类中不会调用父类的赋值运算符重载 &#125; //析构函数:不允许显示调用父类的析构函数 ~Student() &#123; //~Person();坑:同名隐藏，编译器底层对析构函数的名字做了 //修改为了使用多条调不动 //Person::~Person(); //可以调动 cout &lt;&lt; "~Student()" &lt;&lt; endl; &#125;protected: int _num; //学号&#125;;void Test()&#123; Student s1("jack", 18); Student s2(s1); Student s3("rose", 17); s1 = s3;&#125;int main()&#123; Test(); system("pause"); return 0;&#125;//构造顺序：先是基类构造————》派生类构造 //析构顺序：派生类析构--》基类析构//原因为函数栈帧的排列顺序 常见面试题：实现一个不能被继承的类 123456789101112131415// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承class NonInherit&#123; public: static NonInherit GetInstance() &#123; return NonInherit(); &#125;private: NonInherit() &#123;&#125;&#125;;// C++11给出了新的关键字final禁止继承class NonInherit final&#123;&#125;; 复习 继承： 类级别的代码复用 继承方式： public,protectd,private 基类成员在子类中的访问权限：min(在基类中的限定符，继承方式) ​ 基类的私有成员在子类中不可见 protected ：在基类和子类中可见，在类外不可见 private :只在基类中可见，其他地方不可见 类域： 基类和子类的作用域独立成员隐藏 1.成员变量隐藏：子类相同名称的成员隐藏基类同名的成员，通过基类作用域访问基类成员变量 2.成员函数隐藏：函数名相同既构成隐藏.同名函数会隐藏基类函数，和参数无关 函数重载： 在同一个作用域，函数名相同，参数不同。 函数隐藏： 函数一个在子类，一个在父类，函数名相同。 子类的6大成员函数构造： 1.默认生成的，首先会自动调用父类的默认构造函数，再调用自己的构造函数 2.显示定义：如果父类有默认构造，可以不显示调用，如果父类无默认构造函数，需要在初始化列表显示调用。 拷贝构造： 1.默认构成的，编译器会自动调用父类的拷贝构造 ​ 2.显示定义：如果不显式调用父类拷贝构造，编译器会调用父类的默认构造 赋值运算符： 1.默认生成的，编译器会自动调用父类的赋值运算符重载函数 ​ 2.显示定义：如果不显示的调用父类的赋值运算符重载函数，编译器不会调用父类的任何成员函数 析构： 1.默认生成：先执行自己的析构函数，编译器再调用父类的析构 ​ 2.显示定义：不需要显示调用父类的析构，编译器会自动调用，注意父类析构和子类析构构成函数隐藏。 取地址：使用编译器默认生成的即可 父类子类对象之间的赋值： 切片操作 ​ 1.子类对象可以赋值给父类对象，指针，引用 ​ 2.父类对象不能赋值给子类对象，可能会造成访问异常 ​ 3.父类指针在特定条件下可以赋值给子了指针，如果父类指针本身指向的为子类对象的空间，赋值时是安全的，否则不安全 ，会导致访问异常。 友元关系不能继承 继承体系 中的静态]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>c++ 进阶 继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F04%2F14%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树 一：二叉树的概述1.二叉树的概念 一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵别称为左子树和右子树的二叉树组成 2.二叉树的特点： 每个结点最多有两棵子树，即二叉树不存在度大于2的结点。 二叉树的子树有左右之分，其子树的次序不能颠倒。 3.二叉树的几种形态 4.两种特殊的二叉树4.1：满二叉树 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。 满二叉树的图例 满二叉树的特点 如果二叉树的高度为 h 则满二叉树的节点个数为 2^h - 1; 而除了最后一层外。剩余的节点个数为2 ^ (h-1) -1个 最后一层的节点个数为 2 ^ (h-1) -1个 特点：满二叉树的最后一层节点个数为其他层数的结点个数之和 - 1‘ 4.2完全二叉树 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 完全二叉树的特点 已知:父亲节点的下标为[parent] 则其左孩子的结点下标为[left] = 2* [parent] + 1 其右孩子的下标为[right] = 2 * [parent] + 2 已知：左孩子或者右孩子的下标[child] 其双亲结点的下标为[parent] = ( [child] - 1 ) / 2(结果取整) 要注意的是满二叉树是一种特殊的完全二叉树 满二叉树与完全二叉树的联系与区别 满二叉树一定是完全二叉树，但是完全二叉树并不一定是满二叉树 二叉树的重要特征 1.二叉树上第i层上至多有2^(i-1)个结点（i&gt;=1） 2.深度为h的二叉树至多有2^h - 1个结点 3.对于任意一颗二叉树，如果其叶子结点数为n，度为2 的结点数为n1,则n=n1+1; 4.具有n个结点的完全二叉树的深度为[log2 (n+1)]或者为[log2 n]+1(备注:此处的[]为取整，不是中括号) 5. 二叉树存储 1.顺序存储 顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。 2. 链式存储 二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 三：二叉树链式存储结构及实现1.二叉树的遍历A:前序遍历 前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前 B:中序遍历 中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。 C:后序遍历 后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。 三种遍历的使用 二叉树的层序遍历 在遍历二叉树时按照层的方式遍历 二叉树的代码实现模块1.二叉树结构体的定义1#define BTDdataType int 1234567typedef struct BinaryTreeNode&#123;BTDataType _data;struct BinaryTreeNode* _left;struct BinaryTreeNode* _right;&#125;BTNode;//以左孩子右孩子的方式定义 2.二叉树的前序遍历123456789void BinaryTreePrevOrder(BTNode* root)&#123; if(root==NULL)&#123; return ; &#125; printf("%d ",root-&gt;val); BinaryTreePrevOrder(root-&gt;left); BinaryTreePrevOrder(root-&gt;right);&#125;//按照递归的形式遍历二叉树的每一个结点 3.二叉树的中序遍历12345678void BinaryTreeInOrder(BTNode* root) &#123; if (root == NULL) &#123; return; &#125; BinaryTreeInOrder(root-&gt;left); // 左子树 printf("%d ", root-&gt;val); // 根 BinaryTreeInOrder(root-&gt;right); // 右子树&#125; 4.二叉树的后序遍历12345678void BinaryTreePostOrder(BTNode* root)&#123; if (root == NULL) &#123; return; &#125; BinaryTreePostOrder(root-&gt;left); BinaryTreePostOrder(root-&gt;right); printf("%d ", root-&gt;val);&#125; 5.二叉树的层序遍历1234567891011121314151617181920212223242526void LevelorderTraversal(TreeNode *root) &#123; if (root == NULL) &#123; return; &#125; std::queue&lt;TreeNode *&gt; qu; qu.push(root); while (!qu.empty()) &#123; TreeNode *front = qu.front(); qu.pop(); printf("%c ", front-&gt;val); if (front-&gt;left != NULL) &#123; qu.push(front-&gt;left); &#125; if (front-&gt;right != NULL) &#123; qu.push(front-&gt;right); &#125; &#125;&#125;//此算法是用c++语言实现的。//队列存放结点的地址 总体思想：首先需要另外创建一个空的队列，在判断二叉树不为空树的情况下,先将二叉树的根节点入队，然后在根节点出队的时候将它的左右孩子放到队列中，下一次它的左右孩子又是它左右子树的根节点，依次放到队列中，然后出栈，直到队列为空。 总结 前序|中序|后序 深度优先 栈 层序 广度优先 队列 四:二叉树面试题1.判断两个二叉树是否相等12//接口bool isSameTree(struct TreeNode* p,struct TreeNode *q)； 解题思路 首先考虑到如果两棵树都为空，则两棵树是相等的；如果两者中的一个为空，另外一个不为空，则两棵树肯定不相等。若两者都不为空，则需要将两颗二叉树分别分成三部分：1.根结点，2.左子树，3.右子树。然后按照递归的思想一直递推下去。 123456789101112//利用递归的思想，先判断根的情况，再判断左右子树的情况bool isSameTree(struct TreeNode* p,struct TreeNode *q)&#123; if(p==NULL&amp;&amp;q==NULL)&#123; return true; &#125; if(p==NULL||q==NULL)&#123; return false; &#125; return p-&gt;_data==q-&gt;_data &amp;&amp;isSameTree(p-&gt;left,q-&gt;left) &amp;&amp;isSameTree(p-&gt;right,q-&gt;right);&#125; 2.判断对称树12//接口bool isMirror(struct TreeNode *p, struct TreeNode *q)； 解题思路 还是利用递推的思想,将所传的两个结点先进行检查。而后在确保两个结点的值相等的情况下，判断一个根节点的左孩子与另一个根结点的右孩子的情况继而判断这个根节点的右孩子和另外一个根节点的左孩子的情况。 代码实现 1234567891011bool isMirror(struct TreeNode *p, struct TreeNode *q)&#123; if(p==NULL&amp;&amp;q==NULL)&#123; return true; &#125; if(p==NULL||q==NULL)&#123; return false; &#125; return p-&gt;val==q-&gt;val &amp;&amp;isMirror(p-&gt;left,q-&gt;right) &amp;&amp;isMirrorq-&gt;left,p-&gt;right);&#125; 3.判断一棵树是否为另外一棵树的子树接口 1bool isSymmetric(struct TreeNode* root) 解题思路 判断是否是子树1）前序遍历(查找父树上节点的值和子树上结点的值相等的第一个节点，当所要查找的父树上结点的值和子树上根结点的值相等时再判断各自子树的情况)2）判断两棵树是否相同3）对于返回值的处理是难点 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940//当子树的根结点的值和父树上对应的值相等时，判断两者对应的子树是否相等bool isSameTree(struct TreeNode* p, struct TreeNode* q) &#123; if (p == NULL &amp;&amp; q == NULL) &#123; return true; &#125; if (p == NULL || q == NULL) &#123; return false; &#125; // 递推 return p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);&#125;//先序遍历，在父树上找与子树根节点值相等的结点bool preorderTraversal(struct TreeNode *root, struct TreeNode *t) &#123; if (root == NULL) &#123; return false; &#125; // 根 if (root-&gt;val == t-&gt;val &amp;&amp; isSameTree(root, t)) &#123; return true; &#125; // 左子树 bool left = preorderTraversal(root-&gt;left, t); if (left == true) &#123; return true; &#125; // 右子树 bool right = preorderTraversal(root-&gt;right, t); return right;&#125;//该问题所对应的接口bool isSubtree(struct TreeNode* s, struct TreeNode* t) &#123; if (t == NULL) &#123; return true; &#125; return preorderTraversal(s, t);&#125; 4.求一棵二叉树的最大深度接口 1int maxDepth(TreeNode* root)； 解题思路 拿到一颗二叉树 代码实现 12345678int maxDepth(TreeNode* root)&#123; if(root==NULL)&#123; return 0; &#125; int left= MaxDepth(root-&gt;left); int right=MaxDepth(root-&gt;right); return (left&gt;right?left:right)+1;&#125; 5.判断平衡二叉树 判断依据：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 接口 1bool isBalanced(struct TreeNode* root); 解题思路 首先要判断所传的树是否为空树，是空树就为真，不是空树就对根节点的左右子树进行必要的判断。如果都满足则求出左右子树的高度，然后判断根结点对应的左右子树的高度差，并判断高度差满足的条件 代码实现 1234567891011121314151617181920212223242526272829303132333435363738//c语言版int getHeight(struct TreeNode *root) &#123; if (root == NULL) &#123; return 0; &#125; int left = getHeight(root-&gt;left); int right = getHeight(root-&gt;right); return (left&gt;right?left:right) + 1;&#125;bool isBalanced(struct TreeNode* root) &#123; if (root == NULL) &#123; return true; &#125; //处理左子树 bool is_left_balance = isBalanced(root-&gt;left); if (is_left_balance == false) &#123; return false; &#125; //处理右子树 bool is_right_balance = isBalanced(root-&gt;right); if (is_right_balance == false) &#123; return false; &#125; //求左子树的高度 int left_height = getHeight(root-&gt;left); //求右子树的高度 int right_height = getHeight(root-&gt;right); int diff = left_height - right_height; if (diff &gt;= -1 &amp;&amp; diff &lt;= 1) &#123; return true; &#125; else &#123; return false; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041//c++版class Solution &#123;public: bool isBalanced(struct TreeNode* root) &#123; if (root == NULL) &#123; return true; &#125; //处理左子树 bool is_left_balance = isBalanced(root-&gt;left); if (is_left_balance == false) &#123; return false; &#125; //处理右子树 bool is_right_balance = isBalanced(root-&gt;right); if (is_right_balance == false) &#123; return false; &#125; //求左子树的高度 int left_height = getHeight(root-&gt;left); //求右子树的高度 int right_height = getHeight(root-&gt;right); int diff = left_height - right_height; if (diff &gt;= -1 &amp;&amp; diff &lt;= 1) &#123; return true; &#125; else &#123; return false; &#125;&#125; int getHeight(struct TreeNode *root) &#123; if (root == NULL) &#123; return 0; &#125; int left = getHeight(root-&gt;left); int right = getHeight(root-&gt;right); return (left&gt;right?left:right) + 1;&#125;&#125;; 6.完全二叉树的判断判定依据 在层序遍历二叉树的过程中如果没有遍历完所有结点之前就遇到了空结点的话，就说明该树不是完全二叉树 解题思路 解题思路大致与层序遍历的相同，不同之处在于。判断二叉树的结点情况的时候两次判断了队列是否为空的情况，第一次遇到空结点就跳出循环，第二次判断队列是否为空 接口 1bool BinaryTreeComplete(TreeNode* root); 代码实现 12345678910111213141516171819202122232425bool BinaryTreeComplete(TreeNode* root)&#123; if(root == NULL)&#123; return true; &#125; std::queue&lt;TreeNode *&gt; qu; qu.push(root); while(!qu.empty())&#123; TreeNode *front=qu.front(); qu.pop(); if(front==NULL)&#123; break; &#125; qu.push(root-&gt;left); qu.push(root-&gt;right); &#125; //检查队列中是否还有其他元素 while(!qu.empty())&#123; TreeNode *node=qu.front(); qu.pop(); if(node != NULL)&#123; return false; &#125; &#125; return true;&#125; 五：二叉树的前序|中序|后序的非递归实现，自己用栈来实现 栈(用来存放结点地址) 前序的非递归实现 1234567891011121314151617181920212223242526272829303132333435363738void PreorderTraversalNor(TreeNode *root)&#123; TreeNode *cur = root; // 遍历结点的指针 TreeNode *top; // 返回栈顶数据的指针 TreeNode *last = NULL; std::stack&lt;TreeNode *&gt; st; while (!st.empty() || cur != NULL) &#123; while (cur != NULL) &#123; // 第一次访问结点：cur printf("%c ", cur-&gt;val); st.push(cur); cur = cur-&gt;left; &#125; top = st.top(); // 从栈里取出栈顶元素 st.pop(); if (top-&gt;right == NULL) &#123; // 既是第二次访问，也是第三次访问 cur = top-&gt;right; st.pop(); last = top; &#125; else &#123; if (top-&gt;right != last) &#123; // 第二次访问 cur = top-&gt;right; &#125; else &#123; // 第三次访问 st.pop(); last = top; &#125; &#125; &#125;&#125; 方法二 12345678910111213141516171819202122void PreorderTraversalNor2(TreeNode *root)&#123; TreeNode *cur = root; // 遍历结点的指针 TreeNode *top; // 返回栈顶数据的指针 // std:: 命名空间 // &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode * std::stack&lt;TreeNode *&gt; st; while (!st.empty() || cur != NULL) &#123; while (cur != NULL) &#123; // 第一次访问结点：cur printf("%c ", cur-&gt;val); st.push(cur); cur = cur-&gt;left; &#125; top = st.top(); // 从栈里取出栈顶元素 st.pop(); cur = top-&gt;right; &#125;&#125; 中序遍历 1234567891011121314151617181920212223242526272829303132333435363738void InorderTraversalNor(TreeNode *root)&#123; TreeNode *cur = root; // 遍历结点的指针 TreeNode *top; // 返回栈顶数据的指针 TreeNode *last = NULL; // std:: 命名空间 // &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode * std::stack&lt;TreeNode *&gt; st; while (!st.empty() || cur != NULL) &#123; while (cur != NULL) &#123; // 第一次访问结点：cur st.push(cur); cur = cur-&gt;left; &#125; top = st.top(); // 从栈里取出栈顶元素 if (top-&gt;right == NULL) &#123; // 既是第二次访问，也是第三次访问 printf("%c ", top-&gt;val); cur = top-&gt;right; st.pop(); last = top; &#125; else &#123; if (top-&gt;right != last) &#123; // 第二次访问 printf("%c ", top-&gt;val); cur = top-&gt;right; &#125; else &#123; // 第三次访问 st.pop(); last = top; &#125; &#125; &#125;&#125; 方法二 ++1234567891011121314151617181920212223//方法二void InorderTraversalNor2(TreeNode *root)&#123; TreeNode *cur = root; // 遍历结点的指针 TreeNode *top; // 返回栈顶数据的指针 // std:: 命名空间 // &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode * std::stack&lt;TreeNode *&gt; st; while (!st.empty() || cur != NULL) &#123; while (cur != NULL) &#123; // 第一次访问结点：cur st.push(cur); cur = cur-&gt;left; &#125; top = st.top(); // 从栈里取出栈顶元素 // 既是第二次访问，也是第三次访问 printf("%c ", top-&gt;val); cur = top-&gt;right; st.pop(); &#125;&#125; 后序遍历 1234567891011121314151617181920212223242526272829303132333435363738void PostorderTraversalNor(TreeNode *root)&#123; TreeNode *cur = root; // 遍历结点的指针 TreeNode *top; // 返回栈顶数据的指针 TreeNode *last = NULL; // std:: 命名空间 // &lt;&gt; 模板，表示栈里存的数据类型是 TreeNode * std::stack&lt;TreeNode *&gt; st; while (!st.empty() || cur != NULL) &#123; while (cur != NULL) &#123; // 第一次访问结点：cur st.push(cur); cur = cur-&gt;left; &#125; top = st.top(); // 从栈里取出栈顶元素 if (top-&gt;right == NULL) &#123; // 既是第二次访问，也是第三次访问 printf("%c ", top-&gt;val); cur = top-&gt;right; st.pop(); last = top; &#125; else &#123; if (top-&gt;right != last) &#123; // 第二次访问 cur = top-&gt;right; &#125; else &#123; // 第三次访问 printf("%c ", top-&gt;val); st.pop(); last = top; &#125; &#125; &#125;&#125; 123456递归的写法 根 左子树 右子树 左子树 根 右子树 左子树 右子树 根 非递归写法 ： 便利的同时，找到第一次，第二次，第三次 访问点]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊的一些用法]]></title>
    <url>%2F2019%2F04%2F05%2F%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[逆波兰表达式 123451.操作数入栈2.遇到操作符，从栈中取出操作数需要的操作数，取出的操作数的位置应该为从右到左，进行运算，运算结果继续压栈3.复制1，24：返回栈顶元素，即为表达式的最终运行结果 二叉树的镜像 1.递归做法 12345678910class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if(pRoot==nullptr) return ; swap(pRoot-&gt;left,pRoot-&gt;right); Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); &#125;&#125;; 2.非递归 12345678910111213class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; queue&lt;TreeNode*&gt; q; if(pRoot)&#123; q.push(pRoot); &#125; while(!q.empty())&#123; q.push(); if() &#125; &#125;&#125;; //需要补充 第k大个元素 123456class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; &#125;&#125;; 利用适配器模拟实现deque 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;deque&gt;using namespace std;template &lt;class T,class container = deque&lt;T&gt;&gt;class Queue&#123;public: void Push(const T&amp; x)&#123; _con.push_back(x); &#125; void Pop()&#123; _con.pop_front(); &#125; T&amp; Front()&#123; return _con.front(); &#125; size_t size()&#123; return _con.size(); &#125; bool Empty()&#123; return _con.empty(); &#125; T&amp; Back()&#123; return _con.back(); &#125;private: container _con;&#125;;int main()&#123; Queue&lt;int&gt; q; q.Push(1); q.Push(2); q.Push(3); q.Push(4); q.Push(5); while (!q.Empty())&#123; cout &lt;&lt; q.Front() &lt;&lt; " "; q.Pop(); &#125; cout &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>一些特殊的用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与队列]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈与队列 1.栈的实现A：栈的介绍 栈 ：一种特殊的线性表其只允许在固定的一端进行插入和删除元素操作 进行数据插入和删除操作的一端称为 栈顶 ，另一端称为栈底。栈中的数据元素遵守 后进先出LIFO（Last In First Out）的原则压栈 ：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。出栈 ：栈的删除操作叫做出栈。出数据也在栈顶 特点 ：只允许在一端进行插入弹出操作。 例如 ：手枪里的子弹，在装子弹时先装进去的子弹在射击过程中是最后射出来的，而最后装进去的子弹却是最先射出来的 。砌墙的石头后来居上有木有？ 12]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deque]]></title>
    <url>%2F2019%2F04%2F05%2Fstack%26deque%2F</url>
    <content type="text"><![CDATA[deque的使用 1.队列12345template&lt;class T,class &gt; class Deque&#123; public : iterator &#125; 二叉树的遍历 用非得递归的方法来前序遍历二叉树 1.先遍历左节点，左节点全部压栈，左节点遍历完成 2.按照栈 的顺序后进先出，取出每一个压栈的结点，从下向上遍历右结点] 找最近公共祖先]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector]]></title>
    <url>%2F2019%2F04%2F04%2Fvector%2F</url>
    <content type="text"><![CDATA[vector 的相关知识 1.vector的概述A: cbegin()与cend ()迭代器内的值不可修改 头文件#include 迭代器失效出现实现的代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); auto it = v.begin(); while (it != v.end())&#123; if (*it % 2 == 0)&#123; v.erase(it); &#125; ++it; &#125; for (auto e : v)&#123; cout &lt;&lt; e &lt;&lt; " "; &#125; cout &lt;&lt; endl; system("pause"); return 0;&#125;//指针指向了 原来的空间，使得指针你已失效的内存地址。 解决方案123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); auto it = v.begin(); while (it != v.end())&#123; if (*it % 2 == 0)&#123; it = v.erase(it); &#125; else&#123; ++it; &#125; &#125; for (auto e : v)&#123; cout&lt;&lt;e&lt;&lt; " "; &#125; cout &lt;&lt; endl; system("pause"); return 0;&#125;//输出结果为 1 3 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); auto it = v.begin(); while (it != v.end())&#123; it = v.erase(it); ++it; &#125; for (auto e : v)&#123; cout &lt;&lt; e &lt;&lt; " "; &#125; cout &lt;&lt; endl; system("pause"); return 0;&#125;//输出结果为2 4 vector在oj中的使用12345678910111213141516171819202122class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int value = 0; for(size_t i =0 ; i &lt; nums.size(); ++i)&#123; value ^= nums[i]; &#125; return value; &#125;&#125;;//在c++11中class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int value = 0; for(const auto&amp; e:nums)&#123; value ^= e; &#125; return value; &#125;&#125;; 12//迭代器值的交换接口v1.swap(v2);]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string类]]></title>
    <url>%2F2019%2F03%2F30%2Fstring%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[###String 一点关于转义字符的知识 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; char a1[]= "\0";//\0 被认为是一个字符，转义字符 cout &lt;&lt; sizeof(a1) &lt;&lt; endl; //2 cout &lt;&lt; strlen(a1) &lt;&lt; endl; //0 char a2[] = "\\0"; cout &lt;&lt; sizeof(a2) &lt;&lt; endl; //3 cout &lt;&lt; strlen(a2) &lt;&lt; endl;//2 char a3[]= "0000"; cout &lt;&lt; sizeof(a3) &lt;&lt; endl;//5 cout &lt;&lt; strlen(a3) &lt;&lt; endl;//4 char a4[]= "\0000"; // \000 0 \0 cout &lt;&lt; sizeof(a4) &lt;&lt; endl;//3 cout &lt;&lt; strlen(a4) &lt;&lt; endl;//0 char a5[] = "\000 0"; cout &lt;&lt; sizeof(a5) &lt;&lt; endl;//4 cout &lt;&lt; strlen(a5) &lt;&lt; endl;//0 char a6[] = "\0 000"; cout &lt;&lt; sizeof(a5) &lt;&lt; endl;//6 cout &lt;&lt; strlen(a5) &lt;&lt; endl;//0 system("pause"); return 0;&#125;//复习转义字符 12345678//管理动态增长字符串的数组template &lt;class T&gt; class basic_string&#123; private: T* _str; size_t _size; //Linux 下不要这句 size_t _capacity; &#125; 1234567891011121314151617181920//string构造时最常见的几种方法#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; string s1; string s2 ("hello"); string s3(s2);//拷贝构造 string s4 = "world!"; //单参数的构造函数的隐式类型转换(explicit) cout &lt;&lt;s1&lt;&lt; endl; cout &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; s3 &lt;&lt; endl; cout &lt;&lt; s4 &lt;&lt; endl; system("pause"); return 0;&#125; 1.string 的简介 字符串是表示字符序列的类 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。 string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信息，请参阅basic_string)。 string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。 注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作 总结： string是表示字符串的字符串类 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。 string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt;string; 不能操作多字节或者变长字符的序列。在使用string类时，必须包含头文件以及using namespace std; 1.1用法接口1.1.1 string常用的构造方式 123456789101112131415161718192021222324252627282930void TestString()&#123; string s1; // 构造空的string类对象s1 string s2("hello bit"); // 用C格式字符串构造string类对象s2 string s3(10, 'a'); // 用10个字符'a'构造string类对象s3 string s4(s2); // 拷贝构造s4 string s5(s3, 5); // 用s3中前5个字符构造string对象s5&#125;//完整示例//string构造时最常见的几种方法#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; string s1; string s2 ("hello"); string s3(s2);//拷贝构造 string s4 = "world!"; //单参数的构造函数的隐式类型转换(explicit) cout &lt;&lt;s1&lt;&lt; endl; cout &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; s3 &lt;&lt; endl; cout &lt;&lt; s4 &lt;&lt; endl; system("pause"); return 0;&#125; 1.1.2 string类对象的容量操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// size/length/clear/resizevoid TestString1()&#123; // 注意：string类对象支持直接用cin和cout进行输入和输出 string s("hello, bit!!!"); cout&lt;&lt;s.length(); cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; cout &lt;&lt; s &lt;&lt;endl; // 将s中的字符串清空，注意清空时只是将size清0，不改变底层空间的大小 s.clear(); cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; // 将s中有效字符个数增加到10个，多出位置用'a'进行填充 // “aaaaaaaaaa” s.resize(10, 'a'); cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; // 将s中有效字符个数增加到15个，多出位置用缺省值'\0'进行填充 // "aaaaaaaaaa\0\0\0\0\0" // 注意此时s中有效字符个数已经增加到15个 s.resize(15); cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; cout &lt;&lt; s &lt;&lt; endl; // 将s中有效字符个数缩小到5个 s.resize(5); cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; cout &lt;&lt; s &lt;&lt; endl;&#125;//======================================================================================void TestString2()&#123; string s; // 测试reserve是否会改变string中有效元素个数 s.reserve(100); cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; // 测试reserve参数小于string的底层空间大小时，是否会将空间缩小 s.reserve(50); cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl;&#125; 需要注意的点 size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。 clear()只是将string中有效字符清空，不改变底层空间大小。 resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的元素空间。注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。 reserve(size_t res_arg=0)：为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserver不会改变容量大小. 1.1.3 string 类对象的访问操作用法 示例代码 12345678910111213141516void TestString()&#123; String s1("hello Bit"); const String s2("Hello Bit"); cout&lt;&lt;s1&lt;&lt;" "&lt;&lt;s2&lt;&lt;endl; cout&lt;&lt;s1[0]&lt;&lt;" "&lt;&lt;s2[0]&lt;&lt;endl; s1[0] = 'H'; cout&lt;&lt;s1&lt;&lt;endl; for(size_t i = 0; i &lt; s1.size(); ++i) &#123; cout&lt;&lt;s1[i]&lt;&lt;endl; &#125; // s2[0] = 'h'; 代码编译失败，因为const类型对象不能修改&#125; 1.1.4. string类对象的修改操作用法接口 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void TestString()&#123; string str; str.push_back(' '); // 在str后插入空格 str.append("hello"); // 在str后追加一个字符"hello" str += 'b'; // 在str后追加一个字符'b' str += "it"; // 在str后追加一个字符串"it" cout&lt;&lt;str&lt;&lt;endl; cout&lt;&lt;str.c_str()&lt;&lt;endl; // 以C语言的方式打印字符串 // 获取file的后缀 string file1("string.cpp"); size_t pos = file.rfind('.'); string suffix(file.substr(pos, file.size()-pos)); cout &lt;&lt; suffix &lt;&lt; endl; // npos是string里面的一个静态成员变量 // static const size_t npos = -1; // 取出url中的域名 sring url("http://www.cplusplus.com/reference/string/string/find/"); cout &lt;&lt; url &lt;&lt; endl; size_t start = url.find("://"); if (start == string::npos) &#123; cout &lt;&lt; "invalid url" &lt;&lt; endl; return; &#125; start += 3; size_t finish = url.find('/', start); string address = url.substr(start, finish - start); cout &lt;&lt; address &lt;&lt; endl; // 删除url的协议前缀 pos = url.find("://"); url.erase(0, pos+3); cout&lt;&lt;url&lt;&lt;endl;&#125;// 利用reserve提高插入数据的效率，避免增容带来的开销//======================================================================================void TestPushBack()&#123; string s; size_t sz = s.capacity(); cout &lt;&lt; "making s grow:\n"; for (int i = 0; i &lt; 100; ++i) &#123; s += 'c'; if (sz != s.capacity()) &#123; sz = s.capacity(); cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n'; &#125; &#125;&#125;void TestPushBack_P()&#123; string s; s.reserve(100); size_t sz = s.capacity(); cout &lt;&lt; "making s grow:\n"; for (int i = 0; i &lt; 100; ++i) &#123; s += 'c'; if (sz != s.capacity()) &#123; sz = s.capacity(); cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n'; &#125; &#125;&#125; 注意 在string尾部追加字符时，s.push_back(c) / s.append(1, c) / s += ‘c’三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。 对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留好。 1.1.5. string类非成员函数一些用法 1.1.6 面试题目翻转字符串 12345678910111213141516171819class Solution &#123;public: string reverseString(string s) &#123; if(s.empty()) return s; size_t start = 0; size_t end = s.size()-1; //末尾的元素下标 while(start &lt; end) &#123; swap(s[start], s[end]);//将两个元素交换， ++start; --end; &#125; return s; &#125;&#125;; 只出现一次的字符的下标 12 字符串里面最后一个单词的长度 12 验证一个字符串是否为回文结构 12 字符串相加 12 string 的迭代器1.迭代器的使用1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;//迭代器的使用void test_string()&#123; string num = "1234"; //迭代器的优势：迭代器给出了统一的方法去访问容器，屏蔽掉底层复杂的结构细节 string::iterator it = num.begin(); //string::iterator 是一个类型 //it 为类名 //num.begin 为返回值指向字符串的第一个位置的迭代器 //num.end 为指向字符串的最后一个数据的下一个位置的迭代器('\0')的 while (it!=num.end())&#123; cout &lt;&lt; *it &lt;&lt; " "; ++it; &#125; cout &lt;&lt; endl;&#125;int main()&#123; test_string(); system("pause"); return 0;&#125; 三种不同迭代器的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;list&gt;#include&lt;windows.h&gt;using namespace std;//迭代器的使用，打印出原来的字符串方法void test_string( )&#123; string num = "1234"; string::iterator it = num.begin(); int value=0; while (it != num.end())&#123; value*=10; value+=*it-'0'; it++; &#125; cout&lt;&lt;value &lt;&lt; endl; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(5); vector&lt;int&gt; ::iterator vit = v.begin(); while (vit != v.end())&#123; cout &lt;&lt; *vit &lt;&lt; " "; ++vit; &#125; cout &lt;&lt; endl; list&lt;int&gt; l; l.push_back(3); l.push_back(4); l.push_back(6); list&lt;int&gt;::iterator lit = l.begin(); while (lit != l.end())&#123; cout &lt;&lt; *lit &lt;&lt; " "; ++lit; &#125; cout &lt;&lt; endl;&#125;int main()&#123; test_string(); system("pause"); return 0;&#125; 迭代器的使用，倒叙访问字符串12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;windows.h&gt;using namespace std;void test_string3()&#123; string num = "1234"; //反向迭代器 string::reverse_iterator rit = num.rbegin(); while (rit != num.rend())&#123; cout &lt;&lt; *rit &lt;&lt; " "; ++rit; &#125; cout &lt;&lt; endl;&#125;int main()&#123; test_string3(); system("pause"); return 0;&#125; const 迭代器12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;windows.h&gt;using namespace std;int StrToNum(const string&amp; str)&#123; int value=0; string::const_iterator it = str.begin(); while (it != str.end())&#123; value *= 10; value += (*it - '0'); ++it; &#125; return value;&#125;void test_string3()&#123; string num = "1234"; //反向迭代器 string::reverse_iterator rit = num.rbegin(); while (rit != num.rend())&#123; (*rit) += 1; ++rit; &#125; cout &lt;&lt; endl; cout &lt;&lt; StrToNum(num) &lt;&lt; endl;&#125;int main()&#123; test_string3(); system("pause"); return 0;&#125; 迭代器的总结 涉及模式：访问机制 在外部：看指针使用，内部实现上，不同容器有不同的实现方式，不一定是原生指针。 迭代器分类： 1.正向迭代器(可读可写) 2.反向迭代器(可读可写) 3.const迭代器(只读) begin: 第一个元素的位置 end:最后一个元素的下一个位置 rbegin :最后一个元素的位置 rend:第一个元素的前一个位置 迭代器所指的空间为一个左闭右开的空间 string 新的访问方式 1.迭代器—-不常用，跟其他容器保持统一的访问方式 2.for+下标 — 更常用 3.c++ 11 语法糖 for循环+下标123456789101112131415161718192021222324252627282930313233343536//for循环+下标#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;windows.h&gt;using namespace std;int StrToNum(const string&amp; str)&#123; int value = 0; for (size_t i = 0; i &lt; str.size();++i)&#123; value *= 10; value += (str[i]-'0'); &#125; return value;&#125;void test_string3()&#123; string num = "1234"; //反向迭代器 string::iterator rit = num.begin(); while (rit != num.end())&#123; (*rit) += 1; ++rit; &#125; cout &lt;&lt; endl; cout &lt;&lt; StrToNum(num) &lt;&lt; endl;&#125;int main()&#123; test_string3(); system("pause"); return 0;&#125; .c++ 11 语法糖1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;windows.h&gt;using namespace std;int StrToNum(const string&amp; str)&#123; int value = 0; for (auto e:str)&#123; value *= 10; value += (e - '0'); &#125; return value;&#125;void test_string()&#123; string num = "1234"; //反向迭代器 string::iterator rit = num.begin(); while (rit != num.end())&#123; (*rit) += 1; ++rit; &#125; cout &lt;&lt; endl; cout &lt;&lt; StrToNum(num) &lt;&lt; endl;&#125;int main()&#123; test_string(); system("pause"); return 0;&#125; string 的capacity1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;void test_string()&#123; string s("hello world!"); cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; //为字符串预留空间 reserve s.reserve(50); cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; s.resize(51); //resize 空间不够的话增容，空间够的话剩余位置用 //0 补，若给定值得话就会把剩余位置补成给定的值 //s.resize(80,'1'); cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; s.capacity() &lt;&lt; endl; &#125;int main()&#123; test_string(); system("pause"); return 0;&#125; string 类的对象的访问操作 12 string 类对象的修改操作 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;void test_string()&#123; string s1 = "hello"; s1 += ' '; s1 += "world"; string s2 = "!!!!"; s1 += s2; cout &lt;&lt; s1 &lt;&lt; endl;&#125;int main()&#123; test_string(); system("pause"); return 0;&#125;//c_str的用法 string的相加1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;windows.h&gt;using namespace std;void test_string()&#123; string s1 = "hello "; string s2 = "world!!"; cout &lt;&lt; s1 + "world!" &lt;&lt; endl; cout &lt;&lt; "hello " + s2 &lt;&lt; endl; cout &lt;&lt; s1+s2 &lt;&lt; endl;&#125;int main()&#123; test_string(); system("pause"); return 0;&#125;//效率比较低 ###### 123456789101112131415class Solution&#123; public: int firstUniqChar(string s)&#123; int hashtable[26]=&#123;0&#125;; for(auto c:s)&#123; hanshtable[c-'a']++; &#125; for(size_t i=0;i&lt;s.size();i++)&#123; if(hashtable[s[i]-'a'==1]) &#123; return i; &#125; &#125; return -1; &#125;&#125;; 1234567891011string operator+ (string s1,string s2)&#123; string s=s1; s1+=s2; return s;&#125;string&amp; operator +=(stirng s2)&#123; return *this;&#125;//+的效率比较低 计算字符串最后一个单词的长度，单词以空格隔开。12 判断字符串是否是回文结构(看例子，自己写)123class Solution&#123; bool&#125; 字符串相加12345678910111213141516171819202122232425262728293031323334class Solution&#123;public: string addstrings(string num1, string num2)&#123; int end1 = num1.size() - 1, end2 = num2.size() - 1; string retstr; //进位 char next = 0; while (end1 &gt;= 0 &amp;&amp; end2 &gt;= 0)&#123; char value1 = 0; if (end1 &gt;= 0)&#123; value1 = num1[end1] - '0'; &#125; char value2 = 0; if (end2 &gt;= 0)&#123; value2 = num2[end2] - '0'; &#125; char addvalue = value1 + value2 + next; if (addvalue&gt;90)&#123; next = 1; addvalue -= 10; &#125; else&#123; next = 0; &#125; retstr.insert(retstr.begin(), addvalue + '0'); //头插 --end1; --end2; &#125; if (next == 1) retstr.insert(retstr.begin(), '1'); return retstr; &#125;&#125;; 版本改进123456789101112131415161718192021222324252627282930313233343536class Solution&#123;public: string addstrings(string num1, string num2)&#123; int end1 = num1.size() - 1, end2 = num2.size() - 1; string retstr; retstr.reserve(num1.size()&gt;num2.size()? num1.size()+1:um2.szie()+1); //进位 char next = 0; while (end1 &gt;= 0 &amp;&amp; end2 &gt;= 0)&#123; char value1 = 0; if (end1 &gt;= 0)&#123; value1 = num1[end1] - '0'; &#125; char value2 = 0; if (end2 &gt;= 0)&#123; value2 = num2[end2] - '0'; &#125; char addvalue = value1 + value2 + next; if (addvalue&gt;90)&#123; next = 1; addvalue -= 10; &#125; else&#123; next = 0; &#125; retstr+=(addvalue+'0'); --end1; --end2; &#125; if (next == 1) retstr+='1'; //reverse(retstr.begin(),retstr.end()); //和上面的注释掉的那句搭配使用 return retstr; &#125;&#125;; stringf的部分实现1char 浅拷贝:按字节拷贝12 深拷贝12 写时考贝 kmp 在字符串相似度较高时效率才比较高 。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>string类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[模板初阶1.泛型编程 实现函数的交换 123456789101112131415161718void Swap(int&amp; left, int&amp; right)&#123; int temp = left; left = right; right = temp;&#125;void Swap(double&amp; left, double&amp; right)&#123; double temp = left; left = right; right = temp;&#125;void Swap(char&amp; left, char&amp; right)&#123; char temp = left; left = right; right = temp;&#125; 函数重载的缺点 1.重载函数仅仅是类型不同，代码的复用率比较低，只要有新的类型出现就需要 增加对应的重载函数。 2.代码的可维护性查，一个出错可能所有的重都会出现问题 模板：相当于一个模型，让编辑器通过它来推演不同的函数。 比如：造泥人的模子只有一个，而造出来的你人却有很多不同颜色的 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;template&lt;class T&gt;void Swap(T&amp; left, T&amp; right)&#123; T temp = left; left = right; right = temp;&#125;int main()&#123; int a = 0, b = 1; double aa = 1.0000000, bb = 2.000000; swap(a,b); swap(aa,bb); system("pause"); return 0;&#125; c++ 模板的示意图 2.模板的分类2.1函数模板2.1.1概念：函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。2.1.2函数模板格式： template (语法格式) 返回值类型 函数名(参数列表){} 2.13 模板的引用方式12345678template&lt;typename T&gt;void Swap( T&amp; left, T&amp; right)&#123; T temp = left; left = right; right = temp;&#125;//其中typename是用来定义模板参数的关键字，可以用class 来代替，但是不可以用struct来替换 本质的理解:看起来是调用一个函数，实际调用的是不同的函数。2.2 函数模板的实例化 用不同类型的参数使用函数模板时，称为函数模板的实例化。 模板参数实例化分为：隐式实例化和显式实例化。 2.2.1 隐式实例化：让编辑器根据实参推演模板参数的实际类型12345678910111213141516171819202122template&lt;class T&gt;T Add(const T&amp; left, const T&amp; right)//调用方式为引用&#123; return left + right;&#125;int main()&#123; int a1 = 10, a2 = 20; double d1 = 10.0, d2 = 20.0; Add(a1, a2); Add(d1, d2); /* 该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int 或者 double类型而报错 注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅 Add(a1, d1); */ // 此时有两种处理方式：1. 用户自己来强制转化 2. 使用显式实例化 Add(a, (int)d); return 0;&#125;//Add(a1,d1)编译器编译不通过，两个参数类型不同，将一个强转成另一个的类型`` 2.2.2 显式实例化：在函数名后面的&lt;&gt;中指定模板参数的实际类型1234567891011121314151617181920212223242526272829303132333435363738int main(void)&#123; int a = 10; double b = 20.0; // 显式实例化的两种方式 Add&lt;int&gt;(a, b); Add(a,(int)b); return 0;&#125;//如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。//实例#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;template&lt;class T&gt;T Add( T left, T right)//此时不需要引用，引用出错&#123; return left + right;&#125;int main()&#123; int a = 0, b = 1; double aa = 1.0000000, bb = 2.000000; int sum=Add(a,b); double sum1 = Add(aa, bb); Add&lt;int&gt;(a, aa); cout &lt;&lt; "sum="&lt;&lt;sum &lt;&lt; endl; cout &lt;&lt; "sum1="&lt;&lt;sum1 &lt;&lt; endl; cout &lt;&lt; Add&lt;int&gt;(a, aa) &lt;&lt; endl; cout &lt;&lt; Add(a,(int)bb) &lt;&lt; endl; system("pause"); return 0;&#125; 2.3 模板参数的匹配原则1.一个非模板函数可以和同名的模板函数同时存在，而且该函数还可以被实例化为这个非模板实例化函数12345678910111213141516// 专门处理int的加法函数int Add(int left, int right)&#123; return left + right;&#125;// 通用加法函数template&lt;class T&gt;T Add(T left, T right)&#123; return left + right;&#125;void Test()&#123; Add(1, 2); // 与非模板函数匹配，编译器不需要推演，直接调用int型的Add函数 Add&lt;int&gt;(1, 2); // 调用编译器特化的Add版本&#125; 2.对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板123456789101112131415// 专门处理int的加法函数int Add(int left, int right)&#123; return left + right;&#125;// 通用加法函数template&lt;class T1, class T2&gt;T1 Add(T1 left, T2 right)&#123; return left + right;&#125;void Test()&#123; Add(1, 2); // 与非函数模板类型完全匹配，不需要函数模板实例化 Add(1, 2.0); // 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配 &#125; //的Add函数 3. 类模板3.1 类模板的定义格式1234template&lt;class T1,class T2,....,class Tn&gt;class 类模板名&#123;//类内成员定义&#125;； 任务看vector 文档（任务）string 内存管理的面试题，模板基础语法。string使用及其obj的面试题]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++类与对象(下)]]></title>
    <url>%2F2019%2F03%2F24%2FCPP%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[1. 再谈构造函数 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class Date&#123;public: Date(int year)&#123; //构造函数用来初始变量 _year = year; &#125;private: int _year;&#125;;int main()&#123; Date d1(2019); //自动调用Date(int year ) 函数 Date d2 = 2018; //也可以自动调用Date(int year ) 函数 return 0;&#125; 1.2 初始化列表 存在于函数名与函数体之间 初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个”成员变量”后面跟一个放在括号中的初始值或表达式。 默认构造函数:无参或者全缺省 如下例1234567891011121314class Date&#123;public: Date(int year, int month, int day) : _year(year) , _month(month) , _day(day) &#123;&#125; private: int _year; int _month; int _day;&#125;; 1.3关键字explicit 构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用 12345678910111213141516171819202122232425262728class Date&#123;public: Date(int year) :_year(year) &#123;&#125; /*explicit Date(int year) :_year(year) &#123;&#125;*/private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1(2018); // 用一个整形变量给日期类型对象赋值 // 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值 d1 = 2019;//使用explicit时这种赋值也可以使用,阻止单三形式的隐式转换&#125;int main()&#123; TestDate(); system("pause"); return 0;&#125; 上述代码可读性不是很好，用explicit修饰构造函数，将会禁止单参构造函数的隐式转换。 ​ 2.关键字 static2.1 概念声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化对于静态成员函数不能访问它的成员变量，因为他没有this指针12345678910111213class Date&#123; public: Date()&#123; &#125;Date (const Date&amp;d1)&#125;;int main()&#123; Date d; cout&lt;&lt;Date::count&lt;&lt;endl; cout&lt;&lt;d.count&lt;&lt;endl; //公有成员的访问方式 return 0;&#125; 静态函数需要用类名+作用限定符去调用或者用对象去调用(. 操作符); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;Windows.h&gt;//此情况为static定义的函数为公有的using namespace std;class Date&#123;public: Date(int year)&#123; _count++; _year = year; cout &lt;&lt; "Date(int)" &lt;&lt; endl; &#125; Date(const Date&amp; d1)&#123; _count++; _year = d1._year; cout &lt;&lt; "Dtae(const Date&amp; d1)" &lt;&lt; endl; &#125;//private: //将static定义为私有成员时就不能用d1._count 的方式访问了。 int _year; static int _count; //static定义的变量在类外面进行初始化&#125;;int Date::_count = 0; //static定义的变量在类外初始化格式为"类型+作用域"Date fun1(Date d1)&#123; return d1;&#125;int main()&#123; Date d1(2019); Date d2(2015); Date d3(2015);//到此为止已经调用了3次构造函数 fun1(d1); // cout &lt;&lt; d1._count&lt;&lt; endl; cout &lt;&lt; &amp;d1._count &lt;&lt; endl; cout &lt;&lt; &amp;d2._count &lt;&lt; endl; cout &lt;&lt; &amp;d3._count &lt;&lt; endl; system("pause"); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;Windows.h&gt;//此情况为static定义的函数为私有的using namespace std;class Date&#123;public: Date(int year)&#123; _count++; _year = year; cout &lt;&lt; "Date(int)" &lt;&lt; endl; &#125; Date(const Date&amp; d1)&#123; _count++; _year = d1._year; cout &lt;&lt; "Dtae(const Date&amp; d1)" &lt;&lt; endl; &#125; int getCount()&#123; //作用是将count 的值传到需要调用count的地方 return _count; &#125;//改为静态函数后,出现错误，静态函数不能调用非静态函数 // static int getCount()&#123; // // // return _count; // &#125;private: int _year; static int _count;&#125;;int Date::_count = 0;//static定义的变量在类外初始化Date fun1(Date d1)&#123; //fun(Date *this) //非静态函数可以调用非静态函数 return d1;&#125;int main()&#123; Date d1(2019); Date d2(2015); Date d3(2015); fun1(d1); cout &lt;&lt; d1.getCount() &lt;&lt; endl; system("pause"); return 0;&#125; 2.2 特性 静态成员为所有类对象所共享，不属于某个具体的实例 静态成员变量必须在类外定义，定义时不添加static关键字 类静态成员即可用类名::静态成员或者对象.静态成员来访问 静态成员函数没有隐藏的this指针，不能访问任何非静态成员 静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值，const修饰符等参数 3.c++ 11的成员初始化新玩法c++11 支持非静态的成员变量在声明时直接进行初始化12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date(int year,int month,int day)//构造函数 :_year(year) //初始化可以放在初始化列表哪里构造函数赋值实现 //也可以在声明时直接赋值 ,_month(month) ,_day(day) //既在这里完成了函数参数的初始化 &#123; cout &lt;&lt; _year &lt;&lt;"-"&lt;&lt; _month&lt;&lt;"-" &lt;&lt; _day &lt;&lt; endl; //输出的结果即为传参时传递上来的值 &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1(2019,3,30); system("pause"); return 0;&#125; ###### 4. 友元 友元分为：友元函数和友元类友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用 4.1友元函数 友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字 1234567891011121314151617181920212223242526class Date&#123;public: Date(int year, int month, int day) : _year(year) , _month(month) , _day(day) &#123;&#125; ostream&amp; operator&lt;&lt;(ostream&amp; _cout) &#123; _cout&lt;&lt;d._year&lt;&lt;"-"&lt;&lt;d._month&lt;&lt;"-"&lt;&lt;d._day; return _cout; &#125; prvate: int _year; int _month; int _day&#125;;int main()&#123; Date d(2017, 12, 24); d&lt;&lt;cout; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637class Date&#123;friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);friend istream&amp; operator&gt;&gt;(istream&amp; _cin, const Date&amp; d);public: Date(int year, int month, int day) : _year(year) , _month(month) , _day(day) &#123;&#125; prvate: int _year; int _month; int _day&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)&#123; _cout&lt;&lt;d._year&lt;&lt;"-"&lt;&lt;d._month&lt;&lt;"-"&lt;&lt;d._day; return _cout;&#125;istream&amp; operator&gt;&gt;(istream&amp; _cin, const Date&amp; d)&#123; _cin&gt;&gt;d._year; _cin&gt;&gt;d._month; _cin&gt;&gt;d._day; return _cin;&#125;int main()&#123; Date d; cin&gt;&gt;d; cout&lt;&lt;d&lt;&lt;endl; return 0;&#125; 说明:友元函数可访问类的私有成员，但不是类的成员函数友元函数不能用const修饰友元函数可以在类定义的任何地方声明，不受类访问限定符限制一个函数可以是多个类的友元函数友元函数的调用与普通函数的调用和原理相同 4.2 友元类 友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。 友元关系是单向的，不具有交换性。 比如下述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time 类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。 友元关系不能传递.如果B是A的友元，C是B的友元，则不能说明C时A的友元 12345678910111213class Date&#123; friend class Time //Time 可以访问 Date 对象的所有成员&#125;; class Time&#123; friend class Date //Date 可以访问 Time 对象的所以成员&#125;; 友元关系不能传递 123456789101112131415161718192021222324252627282930313233343536373839class Date; // 前置声明class Time&#123; friend class Date; // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量public: Time(int hour, int minute, int second) : _hour(hour) , _minute(minute) , _second(second) &#123;&#125; private: int _hour; int _minute; int _second;&#125;;class Date&#123;public: Date(int year = 1900, int month = 1, int day = 1) : _year(year) , _month(month) , _day(day) &#123;&#125; void SetTimeOfDate(int hour, int minute, int second) &#123; // 直接访问时间类私有的成员变量 _t._hour = hour; _t._minute = minute; _t.second = second; &#125; private: int _year; int _month; int _day; Time _t;&#125;; 5. 内部类特性：内部类可以定义在外部类的public、protected、private都是可以的。注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。sizeof(外部类)=外部类，和内部类没有任何关系。12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class A&#123;public: //B是A的内部类,相当于B是A的友元类 class B&#123; public: void display(A&amp; a)&#123; cout &lt;&lt; a._a &lt;&lt; endl; //外部类的普通的私有成员只能通过 对象. 的方式访问 cout &lt;&lt; _s &lt;&lt; endl; //直接访问 cout &lt;&lt; a._s &lt;&lt; endl; //对象. 的方式访问 //外部类的静态的私有成员可以通过 对象. 的方式访问 也可以直接访问 &#125; private: int _b; void Display(B&amp; b)&#123; //外部类对于内部类没有任何优越的访问权限，不能访问内部的私有成(_b) cout &lt;&lt; b._b &lt;&lt; endl; &#125; &#125;;private: int _a=10;//非静态变可以直接在定义的时候初始化 static int _s;//静态变量必须在类外面进行初始化&#125;;int A::_s = 0;int main()&#123; A::B b; A a; b.display(a); system("pause"); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class A&#123; //B是A的内部类，相当于B是A的友元类 public: //若不写作用限定符则会出现访问不了B的现象 class B&#123; public : void Print(A&amp; a)&#123; cout &lt;&lt; a._a &lt;&lt; endl; //外部类的普通成员必须通过“对象 . ”的方式去访问 cout &lt;&lt; _s &lt;&lt; endl; //外部类的静态成员可以通过“对象 .”的方式去访问 // 也可以直接去访问 cout &lt;&lt; a._s &lt;&lt; endl; &#125; private: int b; &#125;; void Print(B&amp; b)&#123; //外部类对于内部类没有任何优越的访问权限，不能访问 //内部类的私有成员 //cout &lt;&lt; b._b &lt;&lt; endl; &#125;private: int _a=0; static int _s;&#125;;int A::_s = 1;int main()&#123; A::B a; a.Print(A()); system("pause"); return 0;&#125; 题目2.求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C).12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class A&#123;public: class Sum&#123; public: Sum()&#123; _sum += _i; ++_i; &#125; &#125;; int Sum_solution(int n)&#123; _sum=0; //重新初始化，防止多次调用造成多加的情况 _i=1; Sum arr[5]; return _sum; &#125;private: static int _sum; static int _i;&#125;;int A::_sum = 0;int A::_i = 1;int main()&#123; A a; cout &lt;&lt; a.Sum_solution(0) &lt;&lt; endl; system("pause"); return 0;&#125; 输入年月日,判断改天是今年的多少天123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; int days[13] = &#123; 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 &#125;; int year, month, day; cin &gt;&gt; year&gt;&gt; month&gt;&gt; day; int total = days[month - 1] + day; if (month&gt;2)&#123; if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || (year % 400 == 0))&#123; total += 1; &#125; &#125; cout &lt;&lt; total &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言内存管理]]></title>
    <url>%2F2019%2F03%2F22%2Fc%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一：数据在内存中的存储 数据类型介绍1.基本的内存类型：类型的意义1.使用这个类型开辟内存空间的大小（大小决定了使用范围）。2.如何看待内存空间的视角。 char //字符数据类型占1个字节shot //短整形占2个字节int //整形占4个字节long // 长整形占4个字节long long //更长的整形占8个字节float //单精度浮点数占4个字节double // 双精度浮点数占8个字节 验证这些类型长度12345678910111213#include&lt;stdio.h&gt;int main()&#123; printf("%d\n",sizeof(char)); printf("%d\n",sizeof(short)); printf("%d\n",sizeof(int )); printf("%d\n",sizeof(long)); printf("%d\n",sizeof(long long)); printf("%d\n",sizeof(float)); printf("%d\n",sizeof(double)); return 0;&#125; 2.整形家族： 1.char————————&gt; unsigned char //无符号字符形———————— &gt; signed char //有符号字符形2.short———————— &gt; unsigned short[int ] //无符号短整形———————— &gt; signed short [int] //有符号短整形3.int———————— &gt; unsigned int //无符号整形————————&gt; signed int //有符号整形4.long————————&gt; unsigned long [int] //无符号长整形 ————————&gt; signed long [int] //有符号长整形 3.浮点数家族 ： floatdouble 4.构造类型： 数组类型结构体类型 ————————&gt; struct枚举类型—————————–&gt; enum联合类型 —————————&gt; union 5.指针类型————空类型： void不能定义变量【空类型、大小为0】（32位平台下大小为0字节 ，64位平台下为1字节–&gt;但也不能定义变量） 通常用于函数的返回类型、函数的参数、指针类型。void 可以定义变量，可以接受任意类型，与其他类型指针一样占四个字节 。（在32位平台下任何类型指针大小都为4个字节）void 不能被截引用 1234567#include &lt;stdio.h&gt;int main()&#123; printf("%d\n",sizeof(void)); printf("%d\n",sizeof(void*)); return 0;&#125; 32位平台下void 与void *的大小如图 二：整形在内存中的存储1.一个变量的创建是要在内存中开辟空间的，空间的大小是根据不同的类型决定的。 计算机中符号数有三种表示方法，既原码、补码、反码。三种表示方法均有符号位和数值位两部分 符号位都是用0表示“正”，用1表示“负”。 而数值位有三种表示方法 原码 直接将二进制按照正负数的形式翻译成二进制 反码 将原码的符号位不变，其他位依次按位取反 补码 反码+1就得到补码（负数）。 正数的原、反、补码都相同 ~~~~ 无符号数原、反、补码都相同 &amp; 正数的原、反、补码都相同。~~~~ 对于整数来说：数据存放在内存中时，其实存放的是数据的补码。只是正数的原、反、补码都相同。12345678910#include&lt;stdio.h&gt;int main()&#123; int a=-20; signed int b=-20; unsigned int c=-20; printf("a=%d,b=%d,c=%u\n",a,b,c); return 0;&#125; 那么为什么-20会被储存成ec ff ff ff 呢？(大小端有介绍) 2.数据存储和读取的差别123456789#include&lt;stdio.h&gt; int main()&#123; int a=-20; unsigned int b=10; printf("%d\n",a+b); printf("%u\n",a+b); return 0;&#125; 运算过程 存储数据时存到内存中的数据 程序运行结果 由上面的程序和内存中储存的数值来看，不管定义的变量是什么类型的其往计算机中储存数据时存入的都是数据本身的反码，只是在取出的时候改变了它们的类型。 3.在计算机中读取整形数据时的规则 4.整形的提升 下面拿char 类型转成 int形的提升来看1234567891011121314#include&lt;stdio.h&gt;int main()&#123; char a=-3; unsigned char b=-3; unsigned int c=a; unsigned int d=b; printf("%d\n",c); printf("%u\n",c); printf("%u\n",d); printf("%d\n",d); return 0;&#125;c 监视结果 将 a 赋给 c 时，y由于涉及到提升比特位的缘故。所以将char形 -3 的反码1111 1101提升成了int 类型的1111 1111 1111 1111 1111 1111 1111 1101（十进制的4294967293）因为原数据类型为有符号数所以按符号位补充；将 b 赋给 d 时，由于涉及到提升比特位的缘故。所以将unsigned char形 -3 的反码1111 1101提升成了int 类型的0000 0000 0000 0000 0000 0000 1111 1101（十进制的253）因为原数据类型为无符号整数所以拿“0”补充； 运行结果 三：大端、小端 地址有高低地址之分 数据有高低权位之别 1.大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中； 2.小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。 那么为什么会有大端、小端的储存方式呢？ 这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。 例如：一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。 在32位平台下 1234567#include&lt;stdio.h&gt;int main()&#123; int a=20; printf("a=%d\n",a); return 0;&#125;` 如下图： 20按16进制储存时应该为00 00 00 14，但是电脑却储存成14 00 00 00。原因就是32位平台采用的是小端的储存方式。 既数值权位小的数据储存在低位置端为小端储存方式四：浮点数在内存中的储存 例如：十进制的6.0，写成二进制是 110.0 ，相当于 1.10×2^2 。 那么，按照上面V的格式，可以得出s=0，M=1.10，E=2。而十进制的-6.0，写成二进制是 -110.0 ，相当于 -1.10×2^2 。 那么，按照上面V的格式，可以得出s=1，M=1.10，E=2。 2.对于32位浮点数，最高的1位是符号位s,接着的8位是指数E，剩下的23位为有效数字M。 3.对于64位浮点数，最高的1位是符号位s,接着的11位是指数E，剩下的52位为有效数字M. 有效数字M和指数E，还有一些特别规定。 前面说过， 1≤M&lt;2 ，也就是说，M可以写成 1.xxxxxx的形式，其中xxxxxx表示小数部分.在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。 至于指数E首先，E为一个无符号整数（unsigned int） 这意味着，如果E为8位，它的取值范围为0~255；如果E为11位， 它的取值范围为0~2047。但是，我们知道，科学计数法 中的E是可以出现负数的，存入内存 时E的真实值必须再加上一个中间数，对于8位的E， 这个中间数是127；对于11位的E，这个中间数是1023。比如：2^10的E是10，所以保存成32位浮点数时，必须 保存成10+127=137，即10001001。 #### 如表例题： 存-7时 存入120（-7+127=120） ，取时取出-7（120-127=-7） 存入0时 存入127(0+127=127)，取时取出0（127-127=0） 总结 存时浮点数+127,取时浮点数-127 ### 指数E还可以再分成三种情况： 1.E不全为0或不全为1 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M加上第一位的1。 比如： 0.5（1/2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则1.0*2^(-1)，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到2300000000000000000000000，则其二进制表示形式为: 2.E全为0（浮点数的0值，不能直接与0比较）这时，浮点数的指数E等于1-127（或者1-1023）即为真实值， 有效数字M不再加上第一位的1，而是还原0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 3.E全为1（S为0，E全为1，则为float表示的最大正数）这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>数据的存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 类与对象(中)]]></title>
    <url>%2F2019%2F03%2F20%2FC%20%2B%2B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[类与对象 1.类的6个默认成员函数 1.1 构造函数 1.2 拷贝函数构造 1.3 析构函数 1.4 赋值操作符重载 1.5 取地址操作符重载 1.6 const修饰的取地址操作符重载 2. 构造函数 2.1 概念：不是创建，某种意义上来说是初始化 对于以下的日期类： ++123456789101112131415161718192021222324252627282930class Date &#123;&#125;;&#123; public: void SetDate(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; void Display() &#123; cout &lt;&lt;_year&lt;&lt; "-" &lt;&lt;_month &lt;&lt; "-"&lt;&lt; _day &lt;&lt;endl; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1,d2; d1.SetDate(2018,5,1); d1.Display(); Date d2; d2.SetDate(2018,7,1); d2.Display(); return 0;&#125; 对于Date类，可以通过SetDate公有的方法给对象设置内容，但是如果每次创建对象都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次 2.2. 特征 构造函数是特殊的成员函数，需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是构造函数的主要任务并不是开空间创建对象，而是初始化对象。 其特征如下： 2.2.1. 函数名与类名相同。 2.2.2. 无返回值。 2.2.3. 对象实例化时编译器自动调用对应的构造函数。 2.2.4. 构造函数可以重载。 2.2.5. 构造函数可以在类中定义，也可以在类外定义 ++1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date()&#123; //构造函数，初始化了被它定义的对象 _year = 2019; _month = 3; _day = 10; &#125; Date1()&#123;&#125;//类里面声明，在类外面定义 Date(int year, int month, int day)&#123; //函数重载,函数名相同,参数不同 _year = year; _month = month; _day = day; &#125; void Print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125;private: int _year; int _month; int _day;&#125;;Date :: Date1()&#123; //构造函数可以在类外面定义 _year = 2019; _month = 3; _day = 10;&#125;int main()&#123; Date d1;//期望d1一出来就被初始化 d1.Print(); Date d2(2019,3,20); //函数的重载 d2.Print(); system("pause"); return 0;&#125; ++123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date();//类里面声明，在类外面定义 Date(int year, int month, int day)&#123; //函数重载,函数名相同,参数不同 _year = year; _month = month; _day = day; &#125; void Print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125;private: int _year; int _month; int _day;&#125;;Date :: Date()&#123; //构造函数可以在类外面定义 _year = 2019; _month = 3; _day = 10;&#125;int main()&#123; Date d2(2019,3,20); d2.Print(); Date d3; //构造函数可以在类中定义，也可以在类外定义 d3.Print(); system("pause"); return 0;&#125; 2.2.6 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成 ++12345678910111213141516171819202122class Date&#123;public: /* // 如果用户显式定义了构造函数，编译器将不再生成 Date (int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; */private: int _year; int _month; int _day;&#125;;void Test()&#123; // 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器生成的默认构造函数 Date d;&#125; 2.2.7.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一 个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为 [ ] 是默认成员函数。 ++123456789101112131415161718192021222324// 默认构造函数class Date&#123; public: Date()&#123; _year = 1900 ; _month = 1 ; _day = 1; &#125; Date (int year = 1900, int month = 1, int day = 1)&#123; _year = year; _month = month; _day = day; &#125;private : int _year ; int _month ; int _day ;&#125;;// 以下测试函数能通过编译吗？void Test()&#123; Date d1;&#125; 2.2.8 关于编译器生成的默认成员函数，很多童鞋会有疑惑：在我们不实现构造函数的情况下， 编译器会生成 ++123456789101112131415161718192021222324252627282930313233class Time&#123;public: Time() &#123; cout &lt;&lt; "Time()" &lt;&lt; endl; _hour = 0; _minute = 0; _second = 0; &#125;private: int _hour; int _minute; int _second;&#125;;class Date&#123;private: // 基本类型(内置类型) int _year; int _month; int _day; // 自定义类型 Time _t; //默认生成的构造函数对于 1 不做处理，对于 2 默认调用无参构造初始化 //1.基本类型：int 、char .... //2.自定义类型：class/struct定义的类型。。。&#125;;int main()&#123; Date d; return 0; &#125; 默认的构造函数。但是看起来默认构造函数又没什么用？d对象调用了编译器生成的默认构造函数，但是d对象year/month/_day，依旧是随机值。也就说在这里编译器生成的默认构造函数并没有什么卵用？ 解答：C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语法已经定义好的类型：如int/char…，自定义类型就是我们使用class/struct/union自己定义的类型，看看下面的程序，就会发现编译器生成默认的构造函数会对自定类型成员_t调用的它的默认成员函数 3.析构函数3.1 概念： 析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器 完成的。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作 3.2. 特性 析构函数是特殊的成员函数。 其特征如下3.2.1. 析构函数名是在类名前加上字符 ~ 。3.2.2. 无参数无返回值。3.2.3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。3.2.4. 对象生命周期结束时，C++编译系统系统自动调用析构函数. 析构函数建造时按定义的相反顺序建造函数 对于内置类型来说没有定义析构函数的话，编译器默认去掉用析构函数 ++12345678910111213141516171819202122232425262728typedef int DataType;class SeqList&#123; public : SeqList (int capacity = 10) &#123; _pData = (DataType*)malloc(capacity * sizeof(DataType)); assert(_pData); _size = 0; _capacity = capacity; &#125; ~SeqList() &#123; if (_pData) &#123; free(_pData ); // 释放堆上的空间 _pData = NULL; // 将指针置为空 _capacity = 0; _size = 0; &#125; &#125; private : int* _pData ; size_t _size; size_t _capacity;&#125;; 4. 拷贝构造函数4.1 概念 构造函数：只是单个形参，该形参是对本类类型对象的引用(一般常用const 修饰)，在已存在的 类型对象创建新对象时由编译器自动调用 ++123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date(int year = 1900, int month = 1, int day = 1)&#123; _year = year; _month = month; _day = day; &#125; void print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125; ~Date()&#123; cout &lt;&lt; "~Date" &lt;&lt; endl;//析构函数 &#125;private: int _year; int _month; int _day;&#125;;// 以下测试函数能通过编译吗？int main()&#123; Date d1; d1.print(); Date d2(d1); //拷贝构造 d2.print(); system("pause"); return 0;&#125; 4.2 特征4.2.1 拷贝构造函数是构造函数的一个重载形式4.2.2 拷贝构造函数的参数只有一个且必须使用引用传参，使用传参方式会引发无穷递归调用 4.2.3 若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝4.2.4 那么编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。 代码示例++1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date(int year = 2019, int month = 3, int day = 10)&#123; _year = year; _month = month; _day = day; &#125; void Print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125; Date ( Date&amp; d)&#123; //拷贝构造出现问题 _year = d._year; _month = d._month; _day = d._day; &#125; private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1; d1.Print(); Date d2(2018, 6, 30);// 特征2 d2.Print(); Date d3(2019); d3.Print(); Date d4(d2); //拷贝构造--&gt;浅拷贝(按字节进行拷贝) d4.Print(); system("pause"); return 0;&#125; ++123456789101112131415161718192021222324// 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。class String&#123;public: String(const char* str = "jack") &#123; _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); &#125; ~String() &#123; cout &lt;&lt; "~String()" &lt;&lt; endl; free(_str); &#125;private: char* _str;&#125;;int main()&#123; String s1("hello"); String s2(s1);&#125;//程序奔溃的原因是在进行浅拷贝时，将s1和s2的指针指向了同一片空间，在释放时空间//已经倍s2释放了，所以s1再去释放这块空间就会出错 5.赋值运算符重载5.1 运算符重载 C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。函数名字为：关键字operator后面接需要重载的运算符符号。函数原型：返回值类型 operator操作符(参数列表) ++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 全局的operator==class Date&#123; public: Date(int year = 1900, int month = 1, int day = 1) &#123; _year = year; _month = month; _day = day; &#125; //private: int _year; int _month; int _day;&#125;;// 这里会发现运算符重载成全局的就需要成员变量是共有的，那么问题来了，封装性如何保证？// 这里其实可以用我们后面学习的友元解决，或者干脆重载成成员函数。bool operator==(const Date&amp; d1, const Date&amp; d2)&#123; return d1._year == d2._year; &amp;&amp; d1._month == d2._month &amp;&amp; d1._day == d2._day;&#125;void Test ()&#123; Date d1(2018, 9, 26); Date d2(2018, 9, 27); cout&lt;&lt;(d1 == d2)&lt;&lt;endl;//可读性&#125;//////////////////class Date&#123; public: Date(int year = 1900, int month = 1, int day = 1) &#123; _year = year; _month = month; _day = day; &#125; // bool operator==(Date* this, const Date&amp; d2) //增加可读性 // 这里需要注意的是，左操作数是this指向的调用函数的对象 bool operator==(const Date&amp; d2) &#123; return _year == d2._year &amp;&amp; _month == d2._month &amp;&amp; _day == d2._day; &#125;private: int _year; int _month; int _day;&#125;;void Test ()&#123; Date d1(2018, 9, 26); Date d2(2018, 9, 27); cout&lt;&lt;(d1 == d2)&lt;&lt;endl; cout&lt;&lt;operator==(d1,d2)&lt;&lt;endl;&#125; 注意： 5.1.1 不能通过连接其他符号来创建新的操作符：比如operator@5.1.2 重载操作符必须有一个类类型或者枚举类型的操作数5.1.3 用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义5.1.4 作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参5.1.5 &lt; .* &gt;&lt; :: &gt; &lt; sizeof &gt; &lt; ?: &gt;&lt; . &gt;注意以上5个运算符不能重载。这个经常在笔试选择题中出现5.2. 赋值运算符重载赋值运算符主要有四点： 5.2.1. 参数类型5.2.2. 返回值5.2.3. 检测是否自己给自己赋值5.2.4. 返回*this5.2.5. 一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: Date(int year = 1900, int month = 1, int day = 1) &#123; _year = year; _month = month; _day = day; &#125; //d2=d1 //d2.operator(d1) //d2.operator(&amp;d2,d1) void operator=(const Date&amp; d)&#123; //默认含有第一个参数的地址， //已经被this指针所指代 if (this != &amp;d)&#123; //防止自己给自己传值 this-&gt;_year = d._year; this-&gt;_month = d._month; this-&gt;_day = d._day; &#125; &#125; /*Date operator=(const Date&amp; d)&#123; //有返回值 if (this != &amp;d)&#123; this-&gt;_year = d._year; this-&gt;_month = d._month; this-&gt;_day = d._day; &#125; return *this; &#125;*/ void print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1(2018,10, 20); Date d2(2019,10, 10); d1.print();// 这里d1调用的编译器生成operator=完成拷贝，d2和d1的值也是一样的。 Date d3(d1); //拷贝构造 d1 = d2; //赋值运算符的用运 d3.print(); d1.print(); //用运这个表达式需要调用函数Date operator=(const Date&amp; d) //d3 = d2 = d1;//被转换成 d3=(d2.oprator=(&amp;d2,d1)) //d3.print(); //Date d4 = d1; //拷贝构造，将已知的值赋给创建的变量。 //运算符重载 //函数重载 两者没有任何关系 system("pause"); return 0;&#125; 运行结果不加d3 = d2 = d1;加上d3 = d2 = d1; ++123Date operator-(int day);//日期减去日期int operator-(const Date&amp; day); //返回天数//两者而言即是函数重载，又是运算符重载 简单整理：封装：管理构造、析构：初始化、清理拷贝构造、operator= ： 复制 那么编译器生成的默认赋值重载函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。那么下面的类呢？验证一下试试？ ++123456789101112131415161718192021222324// 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。class String&#123;public: String(const char* str = "jack") &#123; _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); &#125; ~String() &#123; cout &lt;&lt; "~String()" &lt;&lt; endl; free(_str); &#125;private: char* _str;&#125;;int main()&#123; String s1("hello"); String s2("world"); s1 = s2;&#125;]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>类与对象(中)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--双向链表]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[DList.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#pragma once#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;assert.h&gt;typedef int DLDataType;//定义链表的结点结构typedef struct DListNode&#123; DLDataType value; //头节点中的value没有意义 struct DListNode *prev; //指向该节点的前一个结点 struct DListNode *next; //指向该节点的后一个结点&#125;DListNode;//定义双向链表typedef struct DList&#123; DListNode *head; //指向双向链表的头节点&#125;DList;//初始化void DListInit(DList *dlist);//销毁//1.清空链表void DListClear(DList *dlist);//2.彻底的清空链表，彻底销毁void DListDestory(DList *dlist);//申请空间的函数DListNode * DListBuyNode(DLDataType value);//增//头插void DListPushFront(DList *dlist,DLDataType value);//尾插void DListPushBack(DList *dlist, DLDataType value);//删//头删void DListPopFront(DList *dlist,DLDataType value);//尾删void DListPopBack(DList *dlist, DLDataType value);//查找DListNode * DListFind(DList *dlist,DLDataType value);//插// 在pos的前面进行插入void DListInsert(DListNode *pos, DLDataType value);// 删除pos位置的节点void DListErase(DListNode *pos);void ListRemove(DList * dlsit, DLDataType value);//打印void DListPrint(const DList *dlist); DList.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include"DList.h"//初始化void DListInit(DList *dlist)&#123; dlist-&gt;head = DListBuyNode(0);//0没有实际意义，这里指头结点 dlist-&gt;head-&gt;next = dlist-&gt;head; dlist-&gt;head-&gt;prev = dlist-&gt;head;&#125;//销毁//1.清空链表//保留链表的头结点void DListClear(DList *dlist)&#123; DListNode *cur, *next; cur = dlist-&gt;head -&gt;next; while (cur != dlist-&gt;head)&#123; next = cur-&gt;next; free(cur); cur = next; &#125; dlist-&gt;head-&gt;next = dlist-&gt;head-&gt;prev = dlist-&gt;head;&#125;//彻底的清空链表，彻底销毁void DListDestory(DList *dlist)&#123; DListClear(dlist); free(dlist-&gt;head); dlist-&gt;head = NULL;&#125;//申请新结点DListNode * DListBuyNode(DLDataType value)&#123; DListNode *new_node = (DListNode *)malloc(sizeof(DListNode)); new_node-&gt;value = value; new_node-&gt;next = new_node-&gt;prev = NULL; return new_node;&#125;//增//头插void DListPushFront(DList *dlist, DLDataType value)&#123; DListNode *node = DListBuyNode(value); node-&gt;prev = dlist-&gt;head; node-&gt;next = dlist-&gt;head-&gt;next; dlist-&gt;head-&gt;next-&gt;prev = node; dlist-&gt;head-&gt;next = node; //特殊情况，空链表是没有问题的 //DListInsert(dlist-&gt;head-&gt;next,value)&#125;//尾插void DListPushBack(DList *dlist,DLDataType value)&#123; DListNode *node = DListBuyNode(value); node-&gt;prev = dlist-&gt;head-&gt;prev; node-&gt;next = dlist-&gt;head; node-&gt;prev-&gt;next = node; dlist-&gt;head-&gt;prev=node; //DListInsert(dlist-&gt;head,value)&#125;//头删void DListPopFront(DList *dlist, DLDataType value)&#123; assert(dlist-&gt;head-&gt;next!=dlist-&gt;head); DListNode *cur = dlist-&gt;head-&gt;next; //指向头节点的下一结点 dlist-&gt;head-&gt;next= cur-&gt;next; // cur-&gt;next-&gt;prev = dlist-&gt;head; free(cur); //空链表也适用 //DListErase(dlist-&gt;head-&gt;next)&#125;//尾删void DListPopBack(DList *dlist, DLDataType value)&#123; assert(dlist-&gt;head-&gt;next!=dlist-&gt;head); DListNode *old_node = dlist-&gt;head-&gt;prev; old_node-&gt;prev-&gt;next = dlist-&gt;head; //dlist-&gt;head-&gt;prev-&gt;prev-&gt;next old_node-&gt;next-&gt;prev = old_node-&gt;prev;//dlist-&gt;head-&gt;prev; free(old_node); //DListErase(dlist-&gt;head-&gt;prev)&#125;//查找DListNode * DListFind(DList *dlist, DLDataType value)&#123; DListNode *cur; for (cur = dlist-&gt;head-&gt;next; cur != dlist-&gt;head; cur = cur-&gt;next)&#123; if (cur-&gt;value = value)&#123; return cur; &#125; return NULL; &#125;&#125;//插// 在pos的前面进行插入void DListInsert(DListNode *pos, DLDataType value)&#123; DListNode *node = DListBuyNode(value); node-&gt;next = pos; node-&gt;prev = pos-&gt;prev; node-&gt;prev-&gt;next = node; pos-&gt;prev = node;&#125;// 删除pos位置的节点void DListErase(DListNode *pos)&#123; pos-&gt;prev-&gt;next = pos-&gt;next; pos-&gt;next-&gt;prev = pos-&gt;prev; free(pos);&#125;//打印void DListPrint(const DList *dlist)&#123; for (DListNode *cur = dlist-&gt;head-&gt;next; cur != dlist-&gt;head; cur = cur-&gt;next) printf("%d --&gt;",cur-&gt;value); printf("\n");&#125; main.c123456789101112131415161718192021222324#include"DList.h"void TestDList1()&#123; DList dlist; DListInit(&amp;dlist); DListPushFront(&amp;dlist,1); DListPushFront(&amp;dlist, 15); DListPrint(&amp;dlist); DListPushFront(&amp;dlist, 16); DListPushBack(&amp;dlist, 18); DListPushFront(&amp;dlist, 2); DListPrint(&amp;dlist); DListPushBack(&amp;dlist,20); DListPushFront(&amp;dlist, 12); DListPushBack(&amp;dlist,17); DListPrint(&amp;dlist); DListDestory(&amp;dlist);&#125;int main()&#123; TestDList1(); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++入门]]></title>
    <url>%2F2019%2F03%2F18%2FC%20%2B%2B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[c++入门笔记 4.基础的C++程序编写++1234567891011121314151617181920212223242526272829303132333435363738 #include&lt;iostream&gt; #include&lt;windows.h&gt; using namespace std;//不写这句会出现cin与cout 未定义的错误 namespace N1&#123; int a = 10; int b = 20; int Add(int a, int b)&#123; //命名空间中可以有函数的存在 return a + b; &#125; namespace N2&#123; //命名空间中可以出现嵌套式的命名空间 //引用时只需要注意调用方式即可 int Swap(int x, int y)&#123; return x*y; &#125; &#125; &#125; int main()&#123; int a,b; cin &gt;&gt; a; //c++语言的输入格式 cin &gt;&gt; b; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; //C++语言的输出格式，其中""中间的部分为输出的格式，而后面紧跟的 //则为输出的内容，“&lt;&lt;endl”表示的是“\n”-&gt;换行符 cout &lt;&lt;"b=" &lt;&lt;b &lt;&lt; endl; cout &lt;&lt; "a="&lt;&lt;N1::a &lt;&lt; endl; cout &lt;&lt; "b=" &lt;&lt; N1::b &lt;&lt; endl; cout &lt;&lt; "a+b="&lt;&lt;N1::Add(a,b) &lt;&lt; endl; cout &lt;&lt; "a*b=" &lt;&lt; N1::N2::Swap(a, b) &lt;&lt; endl; system("pause"); return 0; &#125; 5.函数重载5.1 概念：c++允许在同一作用域中声明几个功能相似的几个同名函数，这些函数的形参列表（参数的个数或类型或顺序）必须不同， 常用来处理实现功能类似数据类型不同的问题 ++123456789101112131415161718192021222324252627282930//函数重载实例#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;int Add(int a,int b)&#123; return a + b;&#125;double Add(double a, double b)&#123; //相较第一个而言形参的类型不同 return a + b;&#125;double Add(double a, int b, float c)&#123; //相较第一个而言形参的类型不同既个数不同 return a + b + c;&#125;int main()&#123; int a = 10; int b = 20; double c = 2.0; double d = 3.0; float f = 3; cout&lt;&lt;Add(a,b)&lt;&lt;endl; cout &lt;&lt; Add(c, d) &lt;&lt; endl; cout &lt;&lt; Add(d, a, f) &lt;&lt; endl; system("pause"); return 0;&#125; 5.2名字修饰 [ ] 在c/c++中，一个程序要跑起来需要经历：预处理、编辑、汇编、链接等步骤 5.2.1 预处理：去注释，宏替换，头文件展开5.2.2 汇编：语法检查，转换成汇编代码5.2.3 编译：汇编代码————&gt;机器码5.2.4 链接：生成可执行文件5.2.5 在Linux下的修饰 void F1(int a); ——Z2F1I 其中—Z为前缀，2代表函数名有两个字符，F1为函数名，而i(int)为参数的类型的首字母void F1(char b);//_Z2F1Cvoid F1(int a,char b);//——Z2F1IC 5.2.6 C语言的名字修饰规则非常简单，只是在函数名字前面加一个下划线(_函数名)， [ ] 而在C++文件(xx.cpp)中在函数名字前面加一个 extern “c”既是告诉编辑器该函数按照c语言规则来编译 ++1234567extern "c" int Add(int a,int b)//一个函数的形式// 若需要全部都用C语言的风格来编辑，形式如下extern "c"&#123; //很多行C语言代码;&#125; 函数重载总结 1 C语言不支持，C++支持 2 特点：函数名相同，参数不同(1.类型不同。2.顺序不同 3.参数个数不同)-3 C++语言支持重载：函数名修饰规则 name mangling 4 C语言中底层函数名：”_” + 函数名 -5 C++底层函数名： 前缀+函数名+参数类型首字母 6：引用6.1 引用概念：引用不是重新定义了一个变量，而是给已经存在的变量取个别名，编译器不会为引用变量开辟内存空间。它和它引用的变量公用同一块内存空间 示例代码如下： 引用格式：类型名&amp; 引用变量名(对象名) = 引用对象 ++12345678910111213141516171819#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;void Testfun()&#123; int a = 10; int &amp;ra = a; cout &lt;&lt; ra &lt;&lt; endl; //结果出现一个10 cout &lt;&lt; ra &lt;&lt;endl&lt;&lt; a&lt;&lt;endl; //结果出现两个10&#125;int main()&#123; Testfun(); system("pause"); return 0;&#125; [ ] 监视结果：&amp;ra=&amp;a,ra=a=10; 注意点： 引用类型和引用实体必须是相同类型的 上例中如果出现 double &amp;ra=a; 则会报错 6.2 引用特性 1.引用在定义时必须初始化 [ ] 错误示例： int &ra; 2.一个变量可以有多个引用 ++12345//正确用法示例： int a=10; int &amp;ra=a; int &amp;rra=a; int &amp;rrra=a; 3.引用一旦引用一个实体则不能在引用其他实体 6.3 常引用++12345678910111213void TestContRef()&#123; const int a=10; //int &amp; ra=1; //该语句编译时出错，a为常量 const int &amp;ra=a; //int&amp; b=10; //该语句编译时出错，b为常量 const int&amp; b=10; double d=12.34; const int&amp; rd==d; //隐式类型转换---&gt;临时变量具有常性 int c=d; //int&amp; rd=d; //该语句编译时出错，类型不同 const int&amp; rd=d; &#125; 6.4 使用场景 [ ] 1. 做参数 传指针和传引用效果一样； ++123456789101112131415161718192021222324252627 //示例代码：#include&lt;iostream&gt;#include&lt;windows.h&gt; using namespace std; void Swap(int *pa,int *pb)&#123; int tmp = *pa; *pa = *pb; *pb = tmp;&#125;void Swap(int &amp;ra,int &amp;rb)&#123; int tmp = ra; ra = rb; rb = tmp;&#125;int main()&#123; int a = 10; int b = 20; Swap(a, b); Swap(&amp;a, &amp;b); system("pause"); return 0;&#125; 2.做返回值 ++12345678910111213141516 #include&lt;iostream&gt; #include&lt;windows.h&gt;using namespace std; int&amp; Testfuc(int &amp;a)&#123; a+=10; return 0; &#125; int main()&#123; int a = 10; int &amp;ra=Testfuc(a); system("pause"); return 0; &#125; //注意：如果函数返时，离开函数作用域后，其栈上空间已经还给了系统，因此不能用栈上的 //空间做为引用类型的返回，如果函数类型返回，返回值的生命周期必须不受函数的限制(既函数周期比较长) ++1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;time.h&gt;using namespace std;int main()&#123; size_t beginl = clock(); for (int i = 0; i &lt; 10000; i++)&#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; &#125; size_t endl = clock(); cout &lt;&lt; (endl- beginl) /CLOCKS_PER_SEC&lt;&lt; endl; system("pause"); return 0;&#125;//以毫秒的形式输出循环的//引用传值的效率高于值拷贝的形式 6.6 指针与引用的区别 引用语法层面：和指针指向同一块内存空间，引用没有开辟新的空间 引用底层实现：引用开辟新的空间，和指针的的实现相同 12345678910111213141516171819int a=10; inta=10;mov dword ptr [a], OAh mov dword ptr [a], 0Ah int&amp; ra = a; int* pa = &amp;a;lea eax, [a] lea еах,[a] mov dword ptr [ra], eax mov dword ptr [pa], eax ra = 20; *pa = 20；mov eax, dword ptr [ra] mov eax, dword ptr[ра]mov dword ptr [eax], 14h mov dword ptr [eax], 14h 引用和指针的不同点:6.6.1. 引用在定义时必须初始化，指针没有要求6.6.2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体6.6.3. 没有NULL引用，但有NULL指针6.6.4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)cout &lt;&lt; sizeof(*a)&lt;&lt;endl; //结果为46.6.5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小6.6.6. 有多级指针，但是没有多级引用6.6.7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理6.6.8. 引用比指针使用起来相对更安全7.内联函数7.1 概念：以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。++1234567inline Add(int a,int b)&#123; return a+b;&#125;int main()&#123; int ret=Add(1,3) -------&gt; return 0;&#125; 面试题： 【面试题】宏的优缺点？ 优点： 1.增强代码的复用性。 2.提高性能。缺点： 1.不方便调试宏。（因为预编译阶段进行了替换) 2.导致代码可读性差，可维护性差，容易误用。 3.没有类型安全的检查 。 C++有哪些技术替代宏 1. 常量定义 换用const 2. 函数定义 换用内联函数8.关键字auto 特点：使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化 表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明 时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。 ++1234567891011121314151617#include&lt;iostream&gt;#include&lt;windows.h&gt; using namespace std;int main()&#123; int a = 10; auto b = a; double c = 20.3; auto d = c; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; cout &lt;&lt; typeid(c).name() &lt;&lt; endl; cout &lt;&lt; typeid(d).name() &lt;&lt; endl; system("pause"); return 0;&#125;//显示出了类型的名称 8.2 使用规则8.2.1. auto与指针和引用结合起来使用用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;++1234567891011121314int main()&#123; int x = 10; auto a = &amp;x; auto* b = &amp;x; auto&amp; c = x; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; cout &lt;&lt; typeid(c).name() &lt;&lt; endl; *a = 20; *b = 30; c = 40; return 0;&#125; 8.2.2 在同一行定义多个变量 当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错， 为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。 ++12345void TestAuto()&#123; auto a = 1, b = 2; auto c = 3, d = 4.0; // 该行代码会编译失败，因为c和d的初始化表达式类型不同&#125; 若同一个程序中同时定义了多个 auto ，其会根据第一个变量表达式去推导类型。8.3 auto不能推导的场景。8.3.1 auto不能做函数的参数 ++123// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导void TestAuto(auto a)&#123;&#125; 8.3.2 auto不能直接用来声明数组++12345void TestAuto()&#123; int a[] = &#123;1,2,3&#125;; auto b[] = &#123;4，5，6&#125;;&#125; 8.3.3为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法8.3.4 auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用。 8.3.5 auto不能定义类的非静态成员变量(暂不做讲解，后面讲)8.3.6实例化模板时不能使用auto作为模板参数(暂不做讲解，后面讲)9. 基于范围的for循环(C++11)9.1 for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。++1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3,4,5,6,7,8,9&#125;; int size = sizeof(arr) / sizeof(arr[0]); int i = 0; for (; i &lt; size; i++)&#123; cout &lt;&lt; "arr1[i]=" &lt;&lt; arr[i] &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (int e : arr)&#123; cout &lt;&lt; "arr2[i]=" &lt;&lt; e &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (auto&amp; e : arr)&#123; cout &lt;&lt; "arr3[i]=" &lt;&lt;e &lt;&lt; endl; &#125; system("pause"); return 0;&#125; 注意：与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环9.2 范围for的使用条件1. for循环迭代的范围必须是确定的 对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提 供begin和end的方法，begin和end就是for循环迭代的范围。 注意：以下代码就有问题，因为for的范围不确定 ++12345void TestFor(int array[]) &#123; for(auto&amp; e : array) cout&lt;&lt; e &lt;&lt;endl; &#125; 10.指针空值nullptr(C++11)++12345678910111213141516#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std; int main()&#123; int *p = NULL; int *pp = nullptr; cout &lt;&lt; typeid(pp).name() &lt;&lt; endl; cout &lt;&lt; typeid(nullptr).name() &lt;&lt; endl; system("pause"); return 0;&#125;结果如下： //int *//std::nullptr_t 程序本意是想通过f(NULL)调用指针版本的f(int)函数，但是由于NULL被定义成 0，因此与程序的初衷相悖。在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void)常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void*)0。 10.2 nullptr 与 nullptr_t 为了考虑兼容性，C++11并没有消除常量0的二义性，C++11给出了全新的nullptr表示空值指针。C++11为什么不在NULL的基础上进行扩展，这是因为NULL以前就是一个宏，而且不同的编译器厂商对于NULL的实现可能不太相同，而且直接扩展NULL，可能会影响以前旧的程序。因此：为了避免混淆，C++11提供了nullptr， 即：nullptr代表一个指针空值常量。nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类型，nullptr_t被定义在头文件中 1typedef decltype(nullptr) nullptr_t; 注意： 1 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。 2 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。 3 为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++ 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构->链表]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[SList.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#pragma once#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;assert.h&gt;typedef int SLDataType;typedef struct SLNode&#123;//链表中的一个节点 SLDataType value; struct SLNode *next; //指向链表中的下一个结点地址&#125;SLNode;typedef struct SList&#123; //一个链表 SLNode *first; //指向链表中的第一个结点地址&#125;SList;//初始化void SListInit(SList*list);//销毁过程void SListDestory(SList *list);//增//头插void SListPushFront(SList *list,SLDataType value);//尾插void SListpushBack(SList *list, SLDataType value);//删//头删void SListPopFront(SList *list);//尾删void SListPopBack(SList *list);//打印void SListPrint(SList *list);//查SLNode * SListFind(const SList *list, SLDataType value);//改void SlistNodeUpdate(SLNode *node, SLDataType value);//指定位置插入元素//1--&gt;2--&gt;3--&gt;NULLvoid SListInsertAfter(SLNode *pos, SLDataType value);//删除给定pos位置后面的结点void SListEraseAfter(SLNode *pos);//指定位置pos 前面插入新结点void SListInsertBefore(SList *list, SLNode *pos, SLDataType value); SList.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147 #include"SList.h"//初始化void SListInit(SList*list)&#123; assert(list!= NULL); list-&gt;first = NULL;&#125;//销毁过程void SListDestory(SList *list)&#123; assert(list!=NULL); SLNode *cur = list-&gt;first; SLNode *next=NULL; while (cur != NULL)&#123; next = cur-&gt;next; free(cur); cur = next; &#125; list-&gt;first = NULL;&#125;//头插void SListPushFront(SList *list, SLDataType value)&#123; assert(list!=NULL); SLNode *node = (SLNode*)malloc(sizeof(SLNode)); assert(node); node-&gt;value = value; node-&gt;next = list-&gt;first; list-&gt;first = node;&#125;//尾插void SListpushBack(SList *list, SLDataType value)&#123; assert(list != NULL); if (list-&gt;first == NULL)&#123; //链表中没有结点,调用头插法 SListPushFront(list,value); return; &#125; //链表中有节点的情况 //找链表中的最后一个节点 SLNode *ptr; for (ptr = list-&gt;first; ptr-&gt;next != NULL; ptr = ptr-&gt;next)&#123; &#125; //ptr就是最后一个节点 SLNode *new_node = (SLNode*)malloc(sizeof(SLNode)); ptr-&gt;next = new_node; new_node-&gt;value = value; new_node-&gt;next = NULL;&#125;//头删void SListPopFront(SList *list)&#123; assert(list != NULL); //保证链表是有的 assert(list-&gt;first!=NULL); //保证链表不为空 SLNode *old_first = list-&gt;first; //拷贝原来的空间，防止丢失。 list-&gt;first = list-&gt;first-&gt;next; free(old_first);//释放老空间&#125;//尾删void SListPopBack(SList *list)&#123; assert(list != NULL); //保证链表是有的 assert(list-&gt;first != NULL); //保证链表不为空 //自己的想法 /*SLNode *ret; for (ret = list-&gt;first; ret-&gt;next-&gt;next != NULL; ret= ret-&gt;next)&#123; &#125; SLNode *cur = ret-&gt;next; ret-&gt;next = NULL; free(cur);*/ //如果只有一个节结点 if (list-&gt;first-&gt;next == NULL)&#123; SListPopFront(list); return; &#125; SLNode *ret = list-&gt;first; while (ret-&gt;next-&gt;next != NULL)&#123; ret = ret-&gt;next; &#125; free(ret-&gt;next); ret-&gt;next = NULL;&#125;//打印void SListPrint(SList *list)&#123; for (SLNode *cur = list-&gt;first; cur != NULL; cur = cur-&gt;next)&#123; printf("%d--&gt; ",cur-&gt;value); &#125; printf("NULL\n");&#125;//查找value//找到链表中遇到的第一个value ,如果没找到，返回NULLSLNode * SListFind(const SList *list, SLDataType value)&#123; assert(list != NULL); //自己的版本 /*SLNode *ret = list-&gt;first; while ( ret != NULL)&#123; if (ret-&gt;value == value)&#123; return ret; &#125; else&#123; ret = ret-&gt;next; &#125; &#125; return NULL;*/ for (SLNode *ret = list-&gt;first; ret != NULL; ret = ret-&gt;next)&#123; if (ret-&gt;value == value)&#123; return ret; &#125; &#125; return NULL;&#125;//改void SlistNodeUpdate(SLNode *node, SLDataType value)&#123; node-&gt;value = value;&#125;//指定位置插入元素//1--&gt;2--&gt;3--&gt;NULL//pos必须是链表中的有效结点void SListInsertAfter(SLNode *pos, SLDataType value)&#123; //给 value 申请结点 SLNode *node = (SLNode *)malloc(sizeof(SLNode)); node-&gt;value = value; node-&gt;next = pos-&gt;next; pos-&gt;next = node;&#125;//删除给定pos位置后面的结点void SListEraseAfter(SLNode *pos)&#123; SLNode *new_node = pos-&gt;next; pos-&gt;next = new_node-&gt;next; free(new_node);&#125;//指定位置pos 前面插入新结点void SListInsertBefore(SList *list, SLNode *pos, SLDataType value)&#123; assert(list != NULL); SLNode *cur = list-&gt;first; while (cur-&gt;next != pos)&#123;//判断cur 指向的是不是pos的前一个结点 cur = cur-&gt;next; &#125; SLNode *new_node = (SLNode*)malloc(sizeof(SLNode)); new_node-&gt;value = value; cur-&gt;next = new_node; new_node-&gt;next = pos;&#125; main.c12345678910111213141516171819202122232425262728293031323334353637383940414243#include"SList.h"void TestSList()&#123; SList list; SListInit(&amp;list); //检验头插尾插 /*SListPushFront(&amp;list,1); SListPushFront(&amp;list, 2); SListPushFront(&amp;list, 3); SListpushBack(&amp;list,11); SListpushBack(&amp;list,12); SListpushBack(&amp;list,13);*/ //检测没有节点时的尾插 SListpushBack(&amp;list,11); SListpushBack(&amp;list,12); SListpushBack(&amp;list,13); SListpushBack(&amp;list,14); SListpushBack(&amp;list,15); SListPrint(&amp;list); //尾删 SListPopFront(&amp;list); SListPopBack(&amp;list); SLNode *node = SListFind(&amp;list,14); assert(node!=NULL); SListInsertAfter(node, 103); SListPrint(&amp;list); SListEraseAfter(node); SListPrint(&amp;list); SListInsertBefore(&amp;list, node, 101); SListPrint(&amp;list); &#125;int main()&#123; TestSList(); printf("程序运行成功!\n"); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存管理]]></title>
    <url>%2F2019%2F03%2F17%2FC%2B%2B%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1 . 例题 ++123456789101112131415 int globalVar = 1; static int staticGlobalVar = 1; void Test() &#123; static int staticVar = 1; int localVar = 1; int num1[10] = &#123;1, 2, 3, 4&#125;; char char2[] = "abcd"; char* pChar3 = "abcd"; int* ptr1 = (int)malloc(sizeof (int)4); int* ptr2 = (int*)calloc(4, sizeof(int)); int* ptr3 = (int)realloc(ptr2, sizeof(int)4); free (ptr1); free (ptr3);&#125; 1.选择题：选项: A.栈 B.堆 C.数据段 D.代码段 globalVar在哪里？_C_ staticGlobalVar在哪里？C__staticVar在哪里？_C_ localVar在哪里？A__num1 在哪里？_A___char2在哪里？A_ char2在哪里？ApChar3在哪里？_A _ pChar3在哪里？Dptr1在哪里？_A *ptr1在哪里？B 全局变量放在数据段,静态的也放在数据段局部变量放在栈上(属于栈帧)，数组若为局部变量也放在栈上2. 填空题： sizeof(num1) =40 ; sizeof(char2) = 5; strlen(char2) =4 ; sizeof(pChar3) = _4 或者 8; strlen(pChar3) = _4;sizeof(ptr1) = _4 或者 8__; //跟系统有关系，32位的为4，64位的为8。32/64 位与虚拟机的地址空间有关，虚拟机的地址空间又与进程有关 sizeof(ptr2)= 4/8 sizeof:类型大小 strlen: 有效字符长度 sizeof 用来计算类型或者是对象的大小strlen 遇到’\0’就结束，计算自字符的大小。3.总结 定义的局部变量(不管类型)都在栈空间上。 动态加载的都在堆上。 解引用的空间在堆上，本身的空间在栈上。 3.【说明】 1.栈又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的。 2.内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。（Linux课程如果没学到这块，现在只需要了解一下） 3.堆用于程序运行时动态内存分配，堆是可以上增长的。 4.数据段–存储全局数据和静态数据。 5.代码段–可执行的代码/只读常量。 2. c 语言中动态内存管理方式2.1 malloc/calloc/realloc和free1234//验证32位平台中malloc 可以申请多大空间void * malloc(1024*1024*1024);//申请了1G的空间。管理在堆上的空间malloc//用于动态申请空间calloc 用于开辟空间并进行初始化 管理在堆上的空间 ######malloc 用于动态申请空间 calloc 用于开辟空间并进行初始化realloc 用于调整大小，用于扩容++123456789101112131415161718void Test () &#123; int* p1 = (int*) malloc(sizeof(int)); free(p1); // 1.malloc/calloc/realloc的区别是什么？ int* p2 = (int*)calloc(4, sizeof (int)); int* p3 = (int)realloc(p2, sizeof(int)10);//给p2 阔占空间 // 这里需要free(p2)吗？ free(p3 ); &#125; 2.1.1 malloc 动态申请内存 2.1.2 calloc 不光申请空间，还对这个空间进行初始化 初始化的空间用户不能指定，它自己规定为 0 2.1.3 realloc 调整空间 空间已经存在，只需要做调整空间大小 ++12345678910111213141516void realloc(int *ptr,int size) //ptr 指向需要调整的空间，而size 表示需要的空间大小 #include&lt;iostream&gt; using namespace std; int main()&#123; int *pi=(int *)malloc(sizeof(int )*20); //申请动态内存 free(pi); //将申请的内存释放掉 char *pc=(char *)malloc(20); char *ppc=(char *)realloc(pc,40); //free(pc); 释放pc 不保险 free(ppc); return 0; &#125; 3.C++ 的内存管理方式 C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：通过new和delete操作符进行动态内存管理。 3.1 new/delete操作内置类型++12345678910111213141516#include&lt;iostream&gt; using namespace std; int main()&#123; int *pa = new int; //new 为关键字， 而int 为需要申请的空间类型 int *pb = new int(1); //申请一块空间，并且初始值赋为 1 delete pb; //c++释放单个空间的方式 int *pc = new int[10]; //申请一块连续的空间，空间为10个int类型的空间大小为 40 字节 delete[]pc; //c++释放连续空间的方式 //new/delete new[]/delete [] return 0; &#125; 注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[] 内置类型 malloc 和 new 效果一样 自定义类型 malloc 和new 不一样 C++推荐使用new 3.2 new和delete操作自定义类型++12345678910111213141516171819//例一#include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; class A&#123; private: int _a; int _b; &#125;; int main()&#123; A* pa = (A *)malloc(sizeof(A)); free(pa); A *pb = new A; delete pb; A *pc = new A[10]; delete[]pc; return 0; &#125; 123456789101112131415161718192021222324252627282930313233343536373839//例二 #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;windows.h&gt; using namespace std; class A&#123; public: A()&#123; cout &lt;&lt; "A" &lt;&lt; endl; &#125; ~A()&#123; //释放空间 //if(_pi)&#123; //free(_pi); //_pi=nullptr; cout &lt;&lt; "~A" &lt;&lt; endl; &#125; private: int _a; int _b; int *_pi; //加入申请了空间 &#125;; int main()&#123; /*A* pa = (A *)malloc(sizeof(A)); free(pa);*/ A *pb = new A; //new 调用自定义类型的构造函数，malloc不会 delete pb; //delete 调用自定义类型的析构函数，free不会 /*A *pc = new A[10]; delete[] pc;*/ system("pause"); return 0; &#125; //总结：new-&gt;operator new -&gt;构造 // delete --&gt;析构 ---&gt;opeator delete 12345678910111213141516171819202122232425262728293031//例三#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Test&#123;public: Test() : _data(0) &#123; cout &lt;&lt; "Test():" &lt;&lt; this &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; "~Test():" &lt;&lt; this &lt;&lt; endl; &#125;private: int _data;&#125;;int main()&#123; Test* pa = (Test *)malloc(sizeof(Test));//只是开辟空间 free(pa); Test *pb = new Test; //new 对于自定义类型来说，他是开辟空间+调用构造函数(初始化) delete pb; Test *pc = new Test[10];//调用构造函数 delete[]pc; return 0;&#125; 课件例题 ++12345678910111213141516171819202122232425262728293031323334class Test &#123; public: Test() : _data(0) &#123; cout&lt;&lt;"Test():"&lt;&lt;this&lt;&lt;endl; &#125; ~Test() &#123; cout&lt;&lt;"~Test():"&lt;&lt;this&lt;&lt;endl; &#125; private: int _data; &#125;; void Test2() &#123; // 申请单个Test类型的空间 Test* p1 = (Test*)malloc(sizeof(Test)); free(p1); // 申请10个Test类型的空间 Test* p2 = (Test*)malloc(sizoef(Test) * 10); free(p2); &#125; void Test2() &#123; // 申请单个Test类型的对象 Test* p1 = new Test; delete p1; // 申请10个Test类型的对象 Test* p2 = new Test[10]; delete[] p2; &#125; 注意：在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc与free不会 4. operator new与operator delete函数 new和delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。 malloc 匹配 free new 匹配 delete new [] 匹配 delete [] 12345678内置类型new int==》operator new 开空间==》malloc==》构造函数malloc int ==》malloc int 也有构造函数；new Test ==&gt;operator new =&gt;malloc ==构造malloc Test== malloc ++12345678910111213141516171819 /* operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。 */ void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) &#123; // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) &#123; // report no memory // 如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); &#125; return (p); &#125;//用法上:opeartor new &lt;==&gt;封装了( malloc + 失败抛异常)//用法上:operatir delete &lt;==&gt; free 申请空间异常的情况 ++123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;windows.h&gt; using namespace std; int main()&#123; //两种处理异常的方式 cout &lt;&lt; "malloc:" &lt;&lt; endl; char *p = (char*)malloc(0x7ffffffff); cout &lt;&lt; (void*)p &lt;&lt; endl; free(p); cout &lt;&lt; "new:" &lt;&lt; endl; try&#123; char *p = new char[0X7fffffff]; cout &lt;&lt; (void*)p &lt;&lt; endl; &#125; catch (exception&amp; e)&#123; cout &lt;&lt; e.what() &lt;&lt; endl; //特殊接口：e.what() &#125; //operator new:malloc + 异常 //operator delete&lt;==&gt;free(相当于) system("pause"); return 0; &#125; 4.1双向链表中的应用++123456789101112131415161718192021struct ListNode&#123; ListNode *_prev; LisrNode *_next; int _date; void *operator new(size_t n)&#123; void *p=allocator&lt;ListNode&gt;().allocate(1); cout&lt;&lt;"mem pool allocate"&lt;&lt;endl; return p; &#125; void operator delete (void *p)&#123; allocator&lt;ListNode&gt; &#125; &#125;; int mian()&#123; List *p1=new List[10]; // free(p1); //用new 申请的空间必须要delete 来释放 delete[] p1; // return 0; &#125; new\delete\总结 自定义类型：new malloc delete free new: opeator new —-&gt;malloc + 构造 malloc: malloc new[N] : operator new [N]—&gt;opertor new —&gt;malloc + N次构造 delete :析构 + opeator delete —&gt;free free: free delete[]: N(析构 + operator delete –&gt; free) new 申请的空间，系统不会自己释放，需要自己手动释放(delete) 内置类型： new : malloc + 异常 malloc :malloc delete: 封装free free: free 5.new和delete的实现原理5.1 内置类型 如果申请的是内置类型的空间，new和malloc，delete和free基 本类似，不同的地方是：new/delete申请和释放的是单个元素的 空间，new[]和delete[]申请的是连续空间，而且new在申请空间 失败时会抛异常，malloc会返回NULL。 5.2 自定义类型 new的原理 : 调用operator new函数申请空间 在申请的空间上执行构造函数，完成对象的构造 delete的原理 在空间上执行析构函数，完成对象中资源的清理工作 new T[N]的原理 1.调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请 2.在申请的空间上执行N次构造函数 delete[]的原理 1.在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理 2.调用operator delete[]释放空间，实际在operator delete[]中 调用operator delete来释放空间 6.定位new表达式(placement-new) 定位new表达式是在已分配的原始内存空间中调用构造函数初始化一个对象。 使用格式： 1.new (place_address) type或者new (place_address) type(initializer-list) 2.place_address必须是一个指针，initializer-list是类型的初始化列表 使用场景： 定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化 ++1234567891011121314151617181920212223242526272829303132333435363738394041424344class Test &#123; public: Test() : _data(0) //初始化表达式 &#123; cout&lt;&lt;"Test():"&lt;&lt;this&lt;&lt;endl; &#125; ~Test() &#123; cout&lt;&lt;"~Test():"&lt;&lt;this&lt;&lt;endl; &#125; private: int _data; &#125;; void Test() &#123; // pt现在指向的只不过是与Test对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行 Test* pt = (Test*)malloc(sizeof(Test)); new(pt) Test; // 注意：如果Test类的构造函数有参数时，此处需要传参 &#125; //初始化表达式使用的例子 class Date&#123; public: Date(int year=1900,int month=1,int day=1) :_year(year) ,_month(month)//初始化表达式使用的例子 ,_day(day) &#123;&#125; private: int _year; int _month; int _day; &#125; int main()&#123; Date* pd=(Date*) malloc(sizeof(Date)); Date* pd2=(Date*) malloc(sizeof(Date)); //pd2的值是随机的 new(pd)Date; //不带参 new(pd2)Date（1939，2，3）; //带参 return 0; &#125; ++123456789class A&#123; int a; &#125;; int main()&#123; A* pa =new A; delete pa;//delete释放指针指向的那一快堆上的空间 return 0; &#125; 7.常见的面试题7.1 malloc/free和new/delete的区别 malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。不同的地方是： 1. malloc和free是函数，new和delete是操作符 2. malloc申请的空间不会初始化，new可以初始化 3.malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可 4.malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型 5 .malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常 6 .申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理 7. new/delete比malloc和free的效率稍微低点，因为new/delete的底层封装了malloc/free new 失败会抛异常，malloc 失败返回 0； 7.2 请设计一个类，该类只能在堆上创建对象 方法一：构造函数私有化 将类的构造函数私有，拷贝构造声明成私有。防止别人调用拷贝 在栈上生成对象 ++1234567891011121314151617class HeapOnly &#123; public: static HeapOnly* CreateObject() &#123; return new HeapOnly; &#125; private: HeapOnly() &#123;&#125; // C++98 // 1.只声明,不实现。因为实现可能会很麻烦，而你本身不需要 // 2.声明成私有 HeapOnly(const HeapOnly&amp;)； // or // C++11 HeapOnly(const HeapOnly&amp;) = delete; &#125;; ++123456789101112131415161718192021222324252627282930313233343536373839404142434445//上课例题代码 //指针访问 -&gt; //对象 . //1.构造函数私有化 //2.提供公共接口：在堆上创建对象 //3.在类外面无法创建对象，函数用类名调用，公共接口必须为static接口 //4.防止拷贝: //&lt;1&gt;:拷贝构造私有化，只声明不实现 //&lt;2&gt;：拷贝构造声明成delete函数(C++11的特性) class Heap &#123; friend void fun1(); public: static Heap* getHeap() &#123; return new Heap; &#125; //以下两种拷贝构造都可以 Heap(const Heap&amp; hp) = delete; private: Heap()&#123;&#125; //Heap(const Heap&amp; hp)； //&#123;&#125; //只申明不实习，因为实现可能会很麻烦，而你本身不需要 //2.申明成私有 &#125;; Heap::Heap(const Heap&amp; hp)&#123;&#125; void fun1() &#123; Heap* hp = Heap::getHeap(); Heap hp2(*hp); &#125; int main() &#123; /*Heap* hp = new Heap; Heap hhp; hp-&gt;getHeap(); hhp.getHeap();*/ Heap* hp = Heap::getHeap(); Heap hp2(*hp);//声明了不写编译器会自动生成 return 0; &#125; 7.3 请设计一个类，该类只能在栈上创建对象(类似上面) new 关键字是如何执行的 不能在堆上建造空间 ++123456789101112131415161718192021222324252627class Stack&#123; public: static Stack getStack()&#123; return Stack();//不能返回指针(也不能返回引用) //当前函数的返回值，在栈上 &#125; private: stack()&#123; &#125; &#125;; class statck2&#123; ///new --&gt; opeator new; void *operator new(size_t n)=delete; //放在公共的申明下，依旧不可调动 //无法使用，被删除的函数 private: void *operator new(size_t n); &#125;; int main()&#123; //Stack *ps=new Stack;//1.开空间 2.构造(已经用delete封死) Stack s=Stack :: getStack(): Stack cp(s); // cp在栈上 stack2 ps =new stack2; return 0; &#125; 只能在栈上创建对象的类 new —&gt;operator new –&gt;构造方法一： 1.构造函数私有化，间接阻止new 关键字的执行逻辑 2.构造公共接口：在栈上创建对象 3.在类外面无法创建对象，函数用类名调用，公共接口必须为static接口 方法二： 1.重载operator new 函数，申明成私有的，并且不实现 2.构造函数公有 1234匿名对象：定义对象的两种方式1.Date d1;2.Date (); //生命周期只是在这一行。 单例模式:全局唯一一份一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享 [ ] 1.饿汉模式 缺点： 1.启动比较慢 2.没有办法控制多个单例模式之间的启动顺序 ++1234567891011121314151617181920212223242526272829//饿汉模式//优点：简单// 缺点：可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。 class singleton&#123; public: static singlleton* getInstance()&#123; return &amp; _sin; &#125; //Singleton&amp; GetInstance()&#123; // return &amp;_sin; //&#125; private: singleton()&#123; &#125; //防拷贝 //singleton (const singlenton &amp;s);//或写成删除函数都可以 singleton (const singlenton &amp;s)=delete; //singlrton &amp;operator=(const singleton &amp;s); static singleton _sin; //c程序启动前，已经定义好了 //singleton _sin;//不能如此定义，其会自己调自己。 &#125;; singleton singleton::_sin; int main()&#123; singleton *ps=singleton :: getInstance; singleton s(*ps); return 0; &#125; [ ] 懒汉模式 如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好. 优点：第一次使用实例对象时，创建对象 缺点：复杂 ++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123class singleton&#123; public: singleton *getIntance()&#123; if(_ps==nullptr)&#123; _ps = new singleton; //第一次还没有，现场做 &#125; return _ps; //第二次以后已经做好了，直接拿去用 &#125; private: singleton()&#123;&#125; singleton(const singleton&amp; s);//只声明不是 static singleton* _ps;//全局唯一 &#125;; singleton *singleton ::_ps=nullptr; //先置空，啥时候需要再给你 int main()&#123; singleton* ps = singleton :: getIntance(); singleton *ps2 =singleton :: getIntance(); return 0; &#125; //加把锁 #include &lt;thread&gt; #include &lt;mutex&gt; class Singleton &#123; public: static Singleton* getInstance() &#123; // double check if (_ps == nullptr) &#123;//双检查 _mtx.lock();//加锁 if (_ps == nullptr) &#123;//第一次获取对象的时候会加锁 _ps = new Singleton; &#125; _mtx.unlock(); //解锁 &#125; return _ps; &#125; void testSing()//多线程 &#123; cout &lt;&lt; Singleton::getInstance() &lt;&lt; endl; &#125; int main() &#123; /*Singleton* ps = Singleton::getInstance(); Singleton* ps2 = Singleton::getInstance(); int i = 0; i++;*/ /*fun(); //串行 fun();*/ /*thread t1(fun); //并行，同时执行 thread t2(fun);*/ /*testSing(); testSing();*/ thread t1(testSing); thread t2(testSing); t1.join(); // 等待 t2.join(); return 0; &#125; //造成无限递归 ~Singleton()&#123; //析构函数 if(_ps)&#123; delete _ps; //无限递归 _ps=nullpte &#125; &#125; //能做到释放空间 ~Singleton() &#123; cout &lt;&lt; "~Singleton()" &lt;&lt; endl; &#125; class GC &#123; public: ~GC() &#123; if (_ps) &#123; delete _ps; _ps = nullptr; &#125; &#125; &#125;; int main() &#123; Singleton* ps = Singleton::getInstance(); //delete ps;//不能这样去释放堆上的空间，造成无限递归 //调用析构函数，造成栈溢出 return 0; &#125; // 实现一个内嵌垃圾回收类 class CGarbo &#123; public: ~CGarbo()&#123; if (Singleton::m_pInstance) delete Singleton::m_pInstance; &#125; &#125;; 多线程：多个人做一份工作(好处可以同时进行多个进程) 单线程：一个人做一份工作 多个线程加把锁 include _mtx.clock(); // 加锁 。。。。。_mtx.unlock(); //解锁加锁的代价 —&gt;多个进程同时进行时，锁只影响第一批进程。static mutex 123int main()&#123; return 0;&#125; 7.5 内存泄漏（指针丢失）7.5.1 什么是内存泄漏 内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内 存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程 序分配某段内存后，因为设计错误，失去了对该段内存的控制， 因而造成了内存的浪费 ++12345678910111213141516171819//当使用delet时，调用析构函数，导致无限递归 ~singleton()&#123; if(_ps)&#123; //无限递归，导致栈溢出 delete _ps; _ps = nulllpter; &#125; &#125;//常见的内存泄漏问题有一下两种 void MemoryLeaks() &#123; // 1.内存申请了忘记释放 int* p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p3 = new int[10]; Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被放. delete []p3; &#125; 7.5.2 内存泄漏的分类 C/C++程序中一般我们关心两种方面的内存泄漏： 堆内存泄漏(Heap leak) 堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。 系统资源泄漏 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定 7.5.3 如何检测内存泄漏 在linux下内存泄漏检测：linux下几款内存泄漏检测工具，valgrind 在windows下使用第三方工具：VLD工具说明&lt;(windows 自带的) 其他工具：内存泄漏工具比较 7.5.4如何避免内存泄漏 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状 态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。 泄露的空间是虚拟空间，不会对电脑造成伤害。进程结束后，系统内存会被返还。 在嵌入式的设备里面会对系统造成影响 ++12345678910111213141516//1. 采用RAII思想或者智能指针来管理资源。 void MemoryLeaks() &#123; // 1.内存申请了忘记释放 int* p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p3 = new int[10]; Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放. delete[] p3; &#125; 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。 出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。 总结一下: 内存泄漏非常常见，解决方案分为两种： 1、事前预防型。如智能指针等。 2、事后查错型。如泄漏检测工具。 7.6 如何一次在堆上申请4G的内存 ++123456789// 将程序编译成x64的进程，运行下面的程序试试？ #include &lt;iostream&gt; using namespace std; int main() &#123; void* p = new char[0xfffffffful]; cout &lt;&lt; "new:" &lt;&lt; p &lt;&lt; endl; return 0; &#125;]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C ++ 类与对象]]></title>
    <url>%2F2019%2F03%2F14%2FC%2B%2B%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1.类的引入 1.1 c语言中对结构体的引用12345678910111213141516171819202122struct ListNode&#123; int data; struct ListNode* next; struct ListNode* prev;&#125;;//类型：struct ListNode//c++兼容c语言int main()&#123; struct ListNode node; return 0;&#125; 1.2 c++中也可以编过1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;struct ListNode&#123; int data; ListNode* next; ListNode* prev; //两个程序中的不同引用方式&#125;;//类型：struct ListNode//c++兼容c语言 int main()&#123; struct ListNode node; system("pause"); return 0;&#125; 1.3 struct的双重身份 1.3.1 c语言中表示结构体。 类型：struct ListNode 1.3.2 C++中升级成了类。类型：ListNode ， struct 为关键字，而 LIstnode为类名,就可以当作类型 [ ] struct 类里面既可以定义变量，也可以定义函数. [ ] struct 与 class的区别是啥？ struct 在c语言阶段就是一个结构体，而在c++中做为类存在。 class在c++中就是一个类， 两者做为类在c++中的区别是什么？ struct 是公有的，class 是私有的 2.类的定义2.1 类的定义方式：12345678 class classname&#123; //类体由成员变量和成员函数组成 &#125;; //一定要注意后面的分号//class 为关键字，classname 为类的名字 ，&#123;&#125;中的类为主体，注意类定义结束时后面的分号。//类中的元素称为类的成员：类的数据称为类的属性或者成员变量；类中的函数称为类的方法或者成员函数 2.2 类的两种定义方式2.2.1 : 声明和定义全都放到类体中123456789class A&#123; //成员函数 void fun()&#123; &#125; //成员变量 int a; int b; int c; &#125;; 需要注意的是：成员函数如果在类中定义，编译器可能会将 其当成内联函数处理 2.2.1.1 ；声明和定义全都放到类体中12345678910class A&#123; //成员函数 void fun()&#123; &#125; //成员变量 int a; int b; int c; &#125;; 2.2.1.2 :在类里面声明在外定义12345678class B&#123; void fun(); &#125;; void B::fun()&#123; //::作用域限定符 &#125; 2.2.2:声明在.h中，类的定义在.cpp中12345678//b.h class B&#123; void fun() ; &#125;; //b.cpp #include "p.h" void B::fun()&#123; //::作用域解析符 &#125; 3.类的访问限定符及封装3.1 访问限定符 C++实现封装的方式：用类将对象的属性与方法结合在一 块，让对象更加完善，通过访问权限选择性的将其 接口提供给外部的用户使用。 访问限定符； 1.public(公有) 2.protected(保护) 3.private (私有) ​ 1234567891011121314151617class A&#123; public: //公有成员函数 void fun()&#123; &#125; private: //私有成员变量 int a; int b; int c; &#125;; int main()&#123; A x; x.fun(); //可以访问到 x.b;//访问不到b return 0; &#125; 被访问限定符修饰的变量或函数在类里面是通用的，在类外 面private 修饰的变量或者函数在类外面不可以访问。 私有限定的是你不能类外面修改类内部的东西，而在类内部可修改 【访问限定符说明】 public 修饰的成员在类外可以直接被访问 ​ 2. protected 和 private 修饰的成员在类外不能直接被访问(此处 protected 和 private 是类似的) 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止 ​ class的默认访问权限为 private ， struct 为 public(因为struct要兼容C) 注意：访问限定符只在编译时有用，当数据映射到内存后， 没有任何访问限定符上的区别 而 struct 定义的变量还是函数都是公有的，但 class 类中 由公有的也有私有的 1234567891011121314151617181920class SeqList&#123; void PopBack();//默认是私有的 public: void PushBack(int x)&#123; ++size; //操作可以正确运行， //原因是访问限定符限制的类的外面，不限制类的里面 &#125; //将x 插到SeqList这个类中去 private: int *a; size_t size; szie_t capacity;&#125;;int main()&#123; SeqList s; //s叫做对象 s.PushBack(1);//把一插入到SeqList这个顺序表中 //s.size++;//语句错误，size 为私有成员 //S.PopBack() //私有成员不可以访问 return 0;&#125; 【面试题】 问题：C++中struct和class的区别是什么？ 解答：C++需要兼容C语言，所以C++中struct可以当成结构体去使用。另外C++中struct还可以用来定义类。和class是定义类是一样的，区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式是private。 3.2 封装3.2.1 【面试题】 面向对象的三大特性：封装、继承、多态。 分装就是为了管理 [ ] ​在类和对象阶段，我们只研究类的封装特性，那什么是封装呢？ 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。 1234567891011121314151617//封装//C语言的结构体struct SeqList&#123; int *a; size_t size; ....&#125;void PushBack(struct SeqList *ptr,int x)//将插到struct SeqList中//c++中class SeqList&#123; void PushBack(int x); //将x 插到SeqList这个类中去 int *a; size_t size; szie_t capacity;&#125;; 3.2.2 封装本质上是一种管理.4.类的作用域4.1:类定义了一个新的作用域，类的所有成员都在类的作用域中。 在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。 123456789101112class Person&#123;public: void PrintPersonInfo();private:char _name[20];char _gender[3];int _age;&#125;;// 这里需要指定PrintPersonInfo是属于Person这个类域void Person::PrintPersonInfo()&#123; cout&lt;&lt;name&lt;&lt;" "gender&lt;&lt;" "&lt;&lt;_age&lt;&lt;endl;&#125; 5.类的实例化 用类类型创建对象的过程，称为类的实例化 类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它 一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间类在计算机当中不占内存，只有来定义的对象才占内存 int a; int—&gt;变量类型 a—-&gt;int 类型的变量 class A( 楼房的设计图纸 ) A ra A —&gt;类型 ra—&gt; A类型的变量 —&gt;类的对象(按照图纸建造的房子) 1234567891011121314151617181920class SeqList&#123; public: void PushBack(int x)&#123;//类内部的申明 &#125; private: int *_a; //声明 size_t size; size_t capacity;&#125; void SeqList::PushBack(int x)//定义 int main()&#123; SeqList s;//现在才被定义出来 cout&lt;&lt;sizeof(SeqList)&lt;&lt;endl;//结果为12 return 0; &#125;//声明只是告诉说明它的类型与名称//定义是将声明的东西创建出来 拿着Person这个类定义man 这个对象 6.类对象模型 结论：一个类的大小，实际就是该类中”成员变量”之和，当 然也要进行内存对齐，注意空类的大小，空类比较特殊，编 译器给了空类一个字节来唯一标识这个类。 7.结构体内存对齐的规则7.1如何计算类对象的大小12345678910class A&#123;public: void PrintA &#123; cout&lt;&lt;_a&lt;&lt;endl; &#125;private: char _a;&#125;; 问题：类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大小 7.2 类对象的存储方式猜测7.2.1对象中包含类的各个成员 7.2.2:只保存成员变量，成员函数存放在公共的代码段 123456789101112131415// 类中既有成员变量，又有成员函数class A1 &#123;public: void f1()&#123;&#125;private: int _a;&#125;;// 类中仅有成员函数class A2 &#123;public: void f2() &#123;&#125;&#125;;//大小为1，不存储数据，占位，表示对象存在过// 类中什么都没有---空类class A3&#123;&#125;; sizeof(A1) : _4_ sizeof(A2) : _1_ sizeof(A3) : _1_结论：一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类。 7.3 内存对齐7.3.1. 第一个成员在与结构体偏移量为0的地址处。7.3.2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。VS中默认的对齐数为8，gcc中的对齐数为4 7.3.3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。7.3.4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处， 结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。 1234567891011121314151617#include &lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class A1&#123; char _ch; double _d;&#125;;class A2&#123; double _d; char _ch;&#125;;int main()&#123; cout &lt;&lt; "A1的大小="&lt;&lt;sizeof(A1) &lt;&lt; endl; cout &lt;&lt; "A2的大小=" &lt;&lt; sizeof(A2) &lt;&lt; endl; system("pause"); return 0;&#125; 8.this指针8.1 this指针的引出12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Date&#123;public: void Print()&#123; cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125; void SetDate(int year, int month, int day)&#123; //构造的函数类似于买门票才能看到兵马用内部的东西 //公有函数提供了访问内部成员的机会 _year = year; // 加上"_"可以避免冲突 _month = month; _day = day; &#125;private://类似与兵马俑里面的展品。 int _year; int _month; int _day;&#125;;int main()&#123; Date d1; Date d2; d1.SetDate(2019, 3, 9); d2.SetDate(2018,3,9); d1.Print();//如何识别打印那个对象对应的日期--&gt;引出this指针 d2.Print();//如何识别打印那个对象对应的日期 //this指针隐含在形参的首位，把d2的地址传给对应函数Print system("pause"); return 0;&#125; 8.2 解释1234567891011//经过改造编译器后 d1.Print(); ===&gt;d1.Print(&amp;d1); d2.Print();====&gt;d2.Print(&amp;d2);void Print()&#123; \\ 改造后() 中间加入了 Date* this cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;//这一句中语句变成了 year ==&gt;this-&gt;year month ==&gt;this-&gt;month day ===&gt; this -&gt;day &#125;//此时d1.Print(&amp;d1) 或者 d2.Print(&amp;d2); 谁调用 Print 函数 this 指针就指向谁； this 指针类似于形参，谁调用就指向谁。 所以其存储在栈上,且其可以为空。 是否可以为空，面试题 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std; class Date&#123;public: void Func()&#123;//此处this传过来的地址为空时不影响该函数的输出 cout &lt;&lt; "Date::Func()" &lt;&lt; endl; &#125; void Print()&#123; //此处this传过来的地址为空时this-&gt;_year出错 cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; // cout &lt;&lt;this-&gt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; &#125;private: //类似与兵马俑里面的展品。 int _year; int _month; int _day;&#125;;int main()&#123; Date* p1 = NULL;//此处为空，this解引用没有访问，可以运行 p1-&gt;Func(); //this指针隐含在形参的首位，把p1的地址传给对应函数 Date* p2 = NULL;//此处为空，解引用this 时， //this为空不能被访问，程序奔溃 p2-&gt;Print(); system("pause"); return 0;&#125;//内存访问是按最大对齐数整数倍访问的 即：C++编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。 8.3 this指针的特性 8.3.1. this指针的类型：类型* const 8.3.2. 只能在“成员函数”的内部使用 8.3.3. this指针本质上其实是一个成员函数的形参，是对象调用成员函数时， 将对象地址作为实参传递给this形参。所以对象中不存储this指针。 8.3.4. this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过 ecx寄存器自动传递，不需要用户传递 this 指针可以为空]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>类与对象(上)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F03%2F14%2Fc%20%E8%AF%AD%E8%A8%80%E7%89%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%A1%BA%E5%BA%8F%E8%A1%A8)%2F</url>
    <content type="text"><![CDATA[顺序表 一：前言(初步认识) 1.1 顺序表概念顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用 **数组** 存储。在数组上完成数据的增删查改。 1.2 顺序表一般可以分为：a. 静态顺序表：使用定长数组存储。 b. 动态顺序表：使用动态开辟的数组存储。 二：代码实现A:顺序表的两种定义方式首先定义一个全局变量 1typedef int SDataType; a.定义静态存储结构 123456typedef struct SeqList&#123; //静态顺序表定义 int array[100]; // 能存 100 个数的静态顺序表 int size; //当前顺序表中存放的数，顺序表为空size=0 //顺便表示了即将插入的下标&#125; Seqlist; b.定义动态存储结构 123456typedef struct SeqList&#123; //动态顺序表定义 SDataType *array; int size; //当前顺序表中存放的数，顺序表为空size=0，当顺序表不为空是表示数据中元素的下标 int capacity; //顺序表的容量&#125; SeqList; B：顺序表的初始化与销毁a:初始化123456void SeqListInit(SeqList *seqlist, int capacity)&#123; assert(seqlist != NULL); seqlist-&gt;array = (SDataType*)malloc(sizeof(SDataType)*capacity); seqlist-&gt;size = 0; seqlist-&gt;capacity = capacity;&#125; 首先需要申请空间，而参数中的 capacity 指的是你在初始化时所需要的空间大小。 b:销毁建立的顺序表 代码 12345678void SeqListDestroy(SeqList *seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array!=NULL); seqlist-&gt;array = NULL; seqlist-&gt;size = 0; seqlist-&gt;capacity = 0; free(seqlist-&gt;array); //重点&#125; 辅助理解 在销毁时只需要将指向定义数组的指针设置为空(而非将顺序表中的元素一个一个的往掉删除)，并且将记录顺序表中元素数量的 size 置为 将申请的空间释放。(必须释放，不然会造成内存泄漏) C：增(往顺序表中添加元素)a:头插 代码 12345678910111213141516171819//头插//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标[size,0)// i 数据下标[size-1,0]//3. 搬移 // i对应空间下标： array[i]=array[i-1];// i对应数据下标： array[i+1]=array[i];void SeqListPushFront(SeqList *seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); for (int i = seqlist-&gt;size ; i &gt; 0; i--)&#123; //做数据的搬移，i代表空间下标 seqlist-&gt;array[i] = seqlist-&gt;array[i - 1]; &#125; seqlist-&gt;array[0] = value; seqlist-&gt;size++;&#125; 辅助理解 在进行头插运算时，需要考虑将原来顺序表中的元素从最后一位开始往后挪动一位，防止数据的丢失。 (若从第一位开始挪动，则会造成数的丢失。当打印时打印出来的顺序表元素全都是一个数字) 如下例中将value插入数组首地址时，应按顺序将数组中的元素往后移，然后再家将value的值插入。 b:尾插 代码 1234567891011void SeqListPushBack(SeqList *seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); CheckCapccity(seqlist); seqlist-&gt;array[seqlist-&gt;size] = value; seqlist-&gt;size++;&#125;//尾插时直接将 value 的值插入到顺序表的最后一位即可。 c: 从指定的位置 (position)处插入value 代码示例 123456789101112void SeqListInsert(SeqList *seqlist, int pos, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(pos &gt;= 0 &amp;&amp; pos &lt;= seqlist-&gt;size); //检查要插入的位置是否合法 for (int i = seqlist-&gt;size - 1; i &gt;= pos; i--)&#123; seqlist-&gt;array[i+1] = seqlist-&gt;array[i]; &#125;//做数组搬移，将pos位置往后的元素按顺序依次从往后移动一位 seqlist-&gt;array[pos] = value; seqlist-&gt;size++;&#125; D: 删(从顺序表中删除制定的元素)a:头删 代码示例 12345678910111213141516171819//头删//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标 [0,size-2]// i 数据下标 [1,size-1]//3. 搬移 // i对应空间下标： array[i-1]=array[i];// i对应数据下标： array[i]=array[i+1];void SeqListPopFront(SeqList* seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(seqlist-&gt;size &gt; 0); //i 代表的是空间下标 for (int i = 1; i &lt;seqlist-&gt;size ; i++)&#123; seqlist-&gt;array[i - 1] = seqlist-&gt;array[i]; &#125; seqlist-&gt;size--;&#125; b:中间删除(指定位置删除某位置元素) 代码示例 123456789101112//删除 pos 所在的下标数据void SeqListErase(SeqList *seqlist, int pos)&#123; assert(seqlist!=NULL); assert(seqlist-&gt;array!=NULL); assert(seqlist -&gt;size&gt;0); assert(pos &gt;= 0 &amp;&amp; pos &lt; seqlist-&gt;size); //做数据的搬移，因为是将指定位置的元素删除既可直接将其覆盖 for (int i = pos; i &lt;seqlist-&gt;size; i++)&#123; seqlist-&gt;array[i] = seqlist-&gt;array[i+1]; &#125; seqlist-&gt;size--;&#125; c:尾删 代码示例 123456void SeqListPopBack(SeqList*seqlist)&#123;gai assert(seqlist!=NULL); assert(seqlist-&gt;array!=NULL); assert(seqlist-&gt;size &gt; 0); seqlist-&gt;size--;&#125; E:改（修改pos 所在下标的所在数据） 代码示例 12345//修改pos 所在下标的所在数据为 valuevoid SeqListModify(SeqList *seqlist, int pos, SDataType value)&#123; assert(pos&gt;=0&amp;&amp;pos&lt;seqlist-&gt;size); seqlist-&gt;array[pos] = value;&#125; F:查(查找指定元素)a:查找 代码示例 1234567891011//查找//如果找到，返回第一个找到的下标//如果没找到返回-1int SeqListFind(const SeqList *seqlist, SDataType value)&#123; assert(seqlist!=NULL); for (int i - 0; i &lt; seqlist-&gt;size;i++)&#123; if (seqlist-&gt;array[i] == value) return i; &#125; return -1;&#125; b:找到并删除第一个遇到的 value 代码示例123456void SeqListRemove(SeqList *seqlist, SDataType value)&#123; int pos = SeqListFind(sqlist,value); if (pos != -1)&#123; SeqListErase(seqlist,pos); &#125;&#125; 以上即为数据结构顺序表中最基本的操作增 、删、改、查四种操作的代码示例。尽管理解起来比较抽象，但是只用自己敲一遍，并且理解透彻的话。你会发现也没有想象中的那么难以理解。 三：整体实现main.c1234567891011121314151617181920212223242526#include"SeqList.h"void TestSeqList()&#123; SeqList seqlist; SeqListInit(&amp;seqlist,100); SeqListPushBack(&amp;seqlist,1); SeqListPushFront(&amp;seqlist,11); SeqListPushBack(&amp;seqlist,2); SeqListPushFront(&amp;seqlist,12); SeqListPushBack(&amp;seqlist,3); SeqListPushFront(&amp;seqlist,13); SeqListInsert(&amp;seqlist,4,100); SeqListPopBack(&amp;seqlist); SeqListPopFront(&amp;seqlist); SeqListErase(&amp;seqlist, 3); SeqListPrint(&amp;seqlist); SeqListDestroy(&amp;seqlist);&#125;int main()&#123; TestSeqList(); system("pause"); return 0;&#125; SeqList.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include"SeqList.h"//扩容//条件:当size=capacity时说明顺序表已满static void CheckCapccity(SeqList *seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(seqlist-&gt;size &lt;= seqlist-&gt;capacity); if (seqlist-&gt;size &lt; seqlist-&gt;capacity)&#123; return; &#125; //走到这里，需要扩容 int capacity = 2 * seqlist-&gt;capacity; SDataType *array = (SDataType *)malloc(sizeof(SDataType)*capacity); assert(array); //把老数据搬过来 for (int i = 0; i &lt; seqlist-&gt;capacity; i++)&#123; array[i] = seqlist-&gt;array[i]; &#125; //释放老空间 free(seqlist-&gt;array); seqlist-&gt;array = array; //数组代表数组的首地址&#125;//顺序表的初始化void SeqListInit(SeqList *seqlist, int capacity)&#123; assert(seqlist != NULL); seqlist-&gt;array = (SDataType*)malloc(sizeof(SDataType)*capacity); seqlist-&gt;size = 0; seqlist-&gt;capacity = capacity;&#125;//顺序表的销毁//只管将数组的首地址置为空，将表示数组的数目size置为0即可//并且将原来初始化顺序表时申请的空间释放即可void SeqListDestroy(SeqList *seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array!=NULL); seqlist-&gt;array = NULL; seqlist-&gt;size = 0; seqlist-&gt;capacity = 0; free(seqlist-&gt;array); //重点&#125;//尾插，不需要搬移数组中的元素void SeqListPushBack(SeqList *seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); CheckCapccity(seqlist); seqlist-&gt;array[seqlist-&gt;size] = value; seqlist-&gt;size++;&#125;//头插void SeqListPushFront(SeqList *seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); CheckCapccity(seqlist); //做数据的搬移，i代表空间下标 for (int i = seqlist-&gt;size ; i &gt; 0; i--)&#123; seqlist-&gt;array[i] = seqlist-&gt;array[i - 1]; &#125; //注意循环的条件 seqlist-&gt;array[0] = value; seqlist-&gt;size++;&#125;//中间插入void SeqListInsert(SeqList *seqlist, int pos, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(pos &gt;= 0 &amp;&amp; pos &lt;= seqlist-&gt;size); CheckCapccity(seqlist); for (int i = seqlist-&gt;size - 1; i &gt;= pos; i--)&#123; seqlist-&gt;array[i+1] = seqlist-&gt;array[i]; &#125; seqlist-&gt;array[pos] = value; seqlist-&gt;size++;&#125;//尾删void SeqListPopBack(SeqList*seqlist)&#123; assert(seqlist!=NULL); assert(seqlist-&gt;array!=NULL); assert(seqlist-&gt;size &gt; 0); seqlist-&gt;size--;&#125;//头删//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标 [0,size-2]// i 数据下标 [1,size-1]//3. 搬移 // i对应空间下标： array[i-1]=array[i];// i对应数据下标： array[i]=array[i+1];void SeqListPopFront(SeqList* seqlist)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array != NULL); assert(seqlist-&gt;size &gt; 0); for (int i = 1; i &lt;seqlist-&gt;size ; i++)&#123; seqlist-&gt;array[i - 1] = seqlist-&gt;array[i]; &#125; seqlist-&gt;size--;&#125;//删除 pos 所在的下标数据void SeqListErase(SeqList *seqlist, int pos)&#123; assert(seqlist!=NULL); assert(seqlist-&gt;array!=NULL); assert(seqlist -&gt;size&gt;0); assert(pos &gt;= 0 &amp;&amp; pos &lt; seqlist-&gt;size); for (int i = pos; i &lt;seqlist-&gt;size; i++)&#123; seqlist-&gt;array[i] = seqlist-&gt;array[i+1]; &#125; seqlist-&gt;size--;&#125;//打印void SeqListPrint(const SeqList *seqlist)&#123; for (int i = 0; i &lt; seqlist-&gt;size; i++)&#123; printf("%d ", seqlist-&gt;array[i]); &#125; printf("\n");&#125;//修改pos 所在下标的所在数据为 valuevoid SeqListModify(SeqList *seqlist, int pos, SDataType value)&#123; assert(pos&gt;=0&amp;&amp;pos&lt;seqlist-&gt;size); seqlist-&gt;array[pos] = value;&#125;//查找//如果找到，返回第一个找到的下标//如果没找到返回-1int SeqListFind(const SeqList *seqlist, SDataType value)&#123; assert(seqlist!=NULL); for (int i = 0; i &lt; seqlist-&gt;size;i++)&#123; if (seqlist-&gt;array[i] == value) return i; &#125; return -1;&#125;//找到并删除第一个遇到的 valuevoid SeqListRemove(SeqList *seqlist, SDataType value)&#123; int pos = SeqListFind(seqlist,value); if (pos != -1)&#123; SeqListErase(seqlist,pos); &#125;&#125;//判断顺序表是否为空，bool SeqListEmpty(const SeqList *seqlist)&#123; return seqlist-&gt;size == 0;&#125;//返回数据个数int SeqListSize(const SeqList *seqlist)&#123; return seqlist-&gt;size;&#125;void SeqListRemoveALl(SeqList* seqlist, SDataType value)&#123; assert(seqlist != NULL); assert(seqlist-&gt;array!=NULL); //方法一： ////申请一个与原数组等长的数组 //SDataType *array = (SDataType*)malloc(sizeof(SDataType)*seqlist-&gt;size); //assert(array); //int index = 0; //for (int i = 0; i &lt; seqlist-&gt;size; i++)&#123; // if (seqlist-&gt;array[i] != value)&#123; // array[index] = seqlist-&gt;array[i]; // index++; // &#125; //&#125; //for (int j = 0; j &lt; index; j++)&#123; // seqlist-&gt;array[j] = array[j]; //&#125; //seqlist-&gt;size = index; //法二 int index = 0; for (int i = 0; i &lt; seqlist-&gt;size; i++)&#123; if (seqlist-&gt;array[i] != value)&#123; seqlist-&gt;array[index] = seqlist-&gt;array[i]; index++; &#125; &#125; seqlist-&gt;size++;&#125; SeqList.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdint.h&gt;#include&lt;stdbool.h&gt;#include&lt;assert.h&gt;#include&lt;windows.h&gt;#pragma once//typedef struct SeqList&#123; // //静态顺序表定义// int array[100]; // 能存 100 个数的静态顺序表// int size; //当前顺序表中存放的数，// //顺序表为空size=0顺便表示了即将插入的下标//&#125; Seqlist;typedef int SDataType;typedef struct SeqList&#123; //动态顺序表定义 SDataType *array; int size; int capacity; //容量&#125; SeqList;//顺序表的初始化/销毁//seqlist 是一个变量的地址//capacity是顺序表的初始容量void SeqListInit(SeqList *seqlist, int capacity);void SeqListDestroy(SeqList *seqlist);//增删改查//1.增//尾插void SeqListPushBack(SeqList *seqlist, SDataType value);//头插//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标[size,0)// i 数据下标[size-1,0]//3. 搬移 // i对应空间下标： array[i]=array[i-1];// i对应数据下标： array[i+1]=array[i];void SeqListPushFront(SeqList *seqlist,SDataType value);//中间插入,往pos所在的下标插入value//1.从后往前// [size-1,pos] i 数据// array[i+1]=array[i];void SeqListInsert(SeqList *seqlist,int pos,SDataType value);//删//1.尾删void SeqListPopBack(SeqList* seqlist);//2.头删//1.从后往前搬，避免覆盖//2.写循环// 先确定循环的边界// i 空间下标 [0,size-2]// i 数据下标 [1,size-1]//3. 搬移 // i对应空间下标： array[i]=array[i+1];// i对应数据下标： array[i-1]=array[i];void SeqListPopFront(SeqList* seqlist);//删除 pos 所在的下标数据void SeqListErase(SeqList *seqlist,int pos);//打印void SeqListPrint(const SeqList *seqlist);//修改pos 所在下标的所在数据为 valuevoid SeqListModify(SeqList *seqlist,int pos, SDataType value);//查找int SeqListFind(const SeqList *seqlist,SDataType value);//找到并删除第一个遇到的 valuevoid SeqListRemove(SeqList *seqlist,SDataType value);//判断顺序表是否为空，bool SeqListEmpty(const SeqList *seqlist);//返回数据个数int SeqListSize(const SeqList *seqlist);//删除所有遇到的value值void SeqListRemoveALl(SeqList* seqlist,SDataType value);]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>顺序表</tag>
      </tags>
  </entry>
</search>
